/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {};}

// Copy all i18n to ux.i18n
if (!Ext.ux.i18n){
	Ext.ux.i18n = Ext.apply({}, (window.Signavio||{}).I18N || {}, (window.ORYX||{}).I18N || {});
}

new function() {
	
	/**
	 * Define the special I18N strings 
	 * for the ux-package.
	 */
	var strings = {};

	
	
	/**
	 * GERMAN TRANSLATION
	 * First translation into German: -
	 * Translator: -
	 * @translationchecker -
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_de = "Hinzufügen";
	strings.btnopen_de = "Öffnen";
	strings.btnremove_de = "Löschen";
	strings.btnedit_de = "Editieren";
	strings.btnreset_de = "Zurücksetzen";
	strings.btnclose_de = "Schließen";
	strings.btnsave_de = "Speichern";
	strings.btnapply_de = "Übernehmen";
	strings.moveup_de = "Nach oben";
	strings.movedown_de = "Nach unten";
	strings.url_de = "Link";
	strings.label_de = "Beschriftung";
	strings.year_de = "Jahr";
	strings.years_de = "Jahre";
	strings.month_de = "Monat";
	strings.months_de = "Monate";
	strings.day_de = "Tag";
	strings.days_de = "Tage";
	strings.hour_de = "Stunde";
	strings.hours_de = "Stunden";
	strings.minute_de = "Minute";
	strings.minutes_de = "Minuten";
	strings.second_de = "Sekunde";
	strings.seconds_de = "Sekunden";
	strings.msecond_de = "Millisekunde";
	strings.mseconds_de = "Millisekunden";

	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_de = "'#{0}' erzeugen als #{1}";
	strings.createglossarynew_de = "Neu erzeugen";

	// GLOSSARY CATEGORIES
	strings.document_de = "Dokumente";
	strings.org_unit_de = "Organisation";
	strings.it_system_de = "IT Systeme";
	strings.activity_de = "Aktivitäten";
	strings.state_de = "Ereignisse";

	strings.noglossary_entry_de = "Kein Glossarbegriff";

	// FEEDBACK WINDOW
	strings["views.feedbacktitleenterprise_de"] = "Supportanfrage senden";
	strings["views.feedbacktitle_de"] = "Supportanfrage an Signavio senden";
	strings["views.feedbacktitleenterprise_de"] = "Supportanfrage senden";
	strings["views.feedbacktitle_de"] = "Supportanfrage an Signavio senden";
	strings["views.feedbackentersubject_de"] = "Bitte geben Sie als Betreff eine kurze Beschreibung Ihres Problems oder Ihrer Frage an.";
	strings["views.feedbackenterdescription_de"] = "Bitte beschreiben Sie Ihr Problem oder Ihre Frage so genau wie möglich, um Ihnen eine schnelle und konkrete Antwort geben zu können.";
	strings["views.feedbackpmsg_de"] = "Detaillierte Beschreibung des Fehlers";
	strings["views.feedbackpempty_de"] = "* Bitte geben Sie uns so genaue Informationen wie möglich.\n* Falls Sie einen Fehler gefunden haben, beschreiben Sie bitte die Schritte, die den Fehler verursacht haben.";
	strings["views.feedbackpsubject_de"] = "Problem mit dem Signavio Process Editor";
	strings["views.feedbackpbrowser_de"] = "Browser- und Systeminformationen";
	strings["views.feedbackpbrowserdesc_de"] = "Diese Informationen wurde automatisch von Ihrem Browser ermittelt und können uns helfen, den Fehler zu finden.";
	strings["views.feedbackclosetitle_de"] = "Schließen";
	strings["views.feedbackfailure_de"] = "Fehler";
	strings["views.feedbackfailuremsg_de"] = "Beim Senden der Nachricht ist ein Fehler aufgetreten.";
	strings["views.feedbacksuccess_de"] = "Nachricht gesendet";
	strings["views.feedbacksuccessmsg_de"] = "Vielen Dank. Ihre Supportanfrage wurde an uns übermittelt.";
	strings["views.feedbacksending_de"] = "Sende Nachricht...";
	strings["views.sendfeedback_de"] = "Supportanfrage senden";
	strings["views.feedbackcopy_de"] = "Kopie der Supportanfrage an mich senden.";
	strings["views.feedbackcopydesc_de"] = "Sendet eine Kopie Ihrer Supportanfrage an Ihre E-Mail-Adresse.";
	strings["views.feedbackpattach_de"] = "Das Diagramm darf der Supportanfrage angefügt werden.";
	strings["views.feedbackpattachdesc_de"] = "Ihr Diagramm kann uns bei der Fehlersuche helfen. Der Inhalt des Diagramms wird vertraulich behandelt. Wenn Sie nicht möchten, dass das Diagramm an uns geschickt wird, entfernen Sie bitte das Häckchen.";
	strings["views.feedbackreceiver_de"] = "Empfänger";
	strings["views.feedbackreceiversignavio_de"] = " Signavio Support ([mail])";
	strings["views.feedbackreceiverenterprise_de"] = " Ihr Support ([mail])";
	strings["views.feedbackmissingheader_de"] = "Kein Betreff";
	strings["views.feedbackmissingheadermsg_de"] = "Bitte geben Sie einen Betreff an.";
	strings["views.feedbackmissingbody_de"] = "Keine Nachricht";
	strings["views.feedbackmissingbodymsg_de"] = "Bitte geben Sie eine Nachricht ein.";
	strings["views.feedbackerrorlength_de"] = "Die Beschreibung ist zu kurz. Sie muss mindestens 40 Zeichen lang sein.";
	strings["views.feedbackerrorlengthtitle_de"] = "Nachricht is zu kurz";
	strings["views.feedbacksignavio_de"] = "Sie haben ein Problem mit der Bedienung des Signavio Process Editors oder Sie haben einen Fehler festgestellt? Bitte nutzen Sie in diesem "+
		"Falle das Support-Formular um direkten Kontakt mit Signavio aufzunehmen. Bitte beachten Sie, dass eine Bearbeitung Ihrer Anfrage "+
		"ca. 1-2 Werktage in Anspruch nehmen kann. Sie erhalten unsere Antwort anschließend per Email. Sämtliche Informationen werden unverschlüsselt "+
		"übertragen.";
	strings["views.feedbackenterprise_de"] = "Sie haben ein Problem mit der Bedienung des Signavio Process Editors oder Sie haben einen Fehler festgestellt? Bitte nutzen Sie in diesem "+
		"Falle das Support-Formular um direkten Kontakt mit Ihrem Support/Administrator aufzunehmen. Sämtliche Informationen werden unverschlüsselt "+
		"übertragen.";

	// PDF EXPORT WINDOW
	strings["views.offertitle_de"] = "PDF (Einzeldiagramm)";
	strings["views.offertitledesc_de"] = "Um ein einzelnes Diagramm im PDF-Format auszugeben, wählen Sie bitte unten aus wie das Diagramm auf mehrere Seiten verteilt werden soll.";
	strings["views.optionwindowtitle_de"] = "PDF-Export (einzelnes Diagramm)";
	strings["views.buttontitle_de"] = "PDF erzeugen";
	strings["views.closetitle_de"] = "Abbrechen";
	strings["views.fittopage_de"] = "Auf 1 Seite";
	strings["views.clipallsides_de"] = "Endlos-Druck (2-dimensional)";
	strings["views.clipbottom_de"] = "Endlos-Druck (vertikal)";
	strings["views.clipright_de"] = "Endlos-Druck (horizontal)";
	strings["views.landscape_de"] = "Querformat";
	strings["views.portrait_de"] = "Hochformat";
	strings["views.defaultname_de"] = "Export";
	strings["views.branding_de"] = "Signavio-Logos ausblenden";
	strings["views.premiumonly_de"] = "Diese Funktion ist nur in der Professional Edition verfügbar.";
	strings["views.waiting_de"] = "Prozessdokumentation wird erstellt.<br/>Dies kann einen Moment dauern...";
	strings["views.resetview_de"] = "Original";
	strings["views.windowdescription_de"] = "Bitte einen View für den Export auswählen:";


	strings["panel.businessrule_de"] = "Business Regel";
	strings["panel.static_de"] = "Statisch";
	strings["panel.dynamic_de"] = "Dynamisch";
	strings["panel.operation_de"] = "Operation";
	strings["panel.add_de"] = "hinzufügen";
	strings["panel.remove_de"] = "entfernen";
	strings["panel.no_description_de"] = "Keine Beschreibung";
	strings["panel.no_performer_de"] = "Kein Bearbeiter definiert.";
	strings["panel.no_users_de"] = "Keine Nutzer verfügbar.";
	strings["panel.no_free_userselection_de"] = "Freie Benutzerauswahl";
	strings["panel.no_parallel_title_de"] = "Hinzufügen einer Gruppe";
	strings["panel.no_parallel_description_de"] = "Für das aktuelle Element ist der Schleifentyp auf parallel oder sequentiell gestellt, das bedeutet, dass mehrere Nutzer diese Aufgabe durchführen können. Um dies zu vereinfachen, möchten Sie anstelle der Gruppe lieber alle ihre Mitglieder hinzufügen?";
	strings["panel.no_parallel_no_user_de"] = "In der aktuellen Gruppe sind keine Nutzer enthalten.";
	strings["panel.no_defined_role_label_de"] = "Vorselektion";
	strings["panel.no_defined_role_single_user_de"] = "Einzelner Benutzer";
	strings["panel.no_defined_role_role_member_de"] = "Gruppen-/Rollen-Mitglied";
	strings["panel.no_defined_role_group_de"] = "Gruppen-/Rollen";
	strings["panel.label_free_userselection_de"] = "(Freie Benutzerauswahl)";

	strings["wizard.nextbtnlabel_de"] = "Weiter >";
	strings["wizard.previousbtnlabel_de"] = "< Zurück";

	// RICHTEXT
	strings["richtext.title.undo_de"] = "Rückgängig (Strg+Z)";
    strings["richtext.text.undo_de"] = "Die letzte Aktion rückgängig machen.";
    strings["richtext.title.redo_de"] = "Wiederherstellen (Umschalt+Strg+Z)";
    strings["richtext.text.redo_de"] = "Die letzte rückgängig gemachte Aktion wiederherstellen.";
    strings["richtext.title.bold_de"] = "Fett (Strg+B)";
    strings["richtext.text.bold_de"] = "Den markierten Text fett schreiben.";
    strings["richtext.title.italic_de"] = "Kursiv (Strg+I)";
    strings["richtext.text.italic_de"] = "Den markierten Text kursiv schreiben.";
    strings["richtext.title.underline_de"] = "Unterstreichen (Strg+U)";
    strings["richtext.text.underline_de"] = "Den markierten Text unterstreichen.";
    strings["richtext.title.fontselect_de"] = "Schriftart";
    strings["richtext.text.fontselect_de"] = "Die Schriftart des markierten Textes ändern.";
    strings["richtext.title.fontsizeselect_de"] = "Schriftgröße";
    strings["richtext.text.fontsizeselect_de"] = "Die Schriftgröße des markierten Textes ändern.";
    strings["richtext.title.h1_de"] = "Überschrift";
    strings["richtext.text.h1_de"] = "Fügt eine neue Überschrift ein.";
    strings["richtext.title.h2_de"] = "Unterüberschrift";
    strings["richtext.text.h2_de"] = "Fügt eine neue Unterüberschrift ein.";
    strings["richtext.title.h3_de"] = "Abschnittsüberschrift";
    strings["richtext.text.h3_de"] = "Fügt eine neue Abschnittsüberschrift ein.";
    strings["richtext.title.inserthorizontalrule_de"] = "Horizontale Linie";
    strings["richtext.text.inserthorizontalrule_de"] = "Fügt eine horizontale Linie ein.";
    strings["richtext.title.color_de"] = "Schriftfarbe";
    strings["richtext.text.color_de"] = "Ändert die Schriftfarbe des markierten Textes.";
    strings["richtext.title.markupcolor_de"] = "Hintergrundfarbe";
    strings["richtext.text.markupcolor_de"] = "Ändert die Hintergrundfarbe des markierten Textes.";
    strings["richtext.title.justifyleft_de"] = "Linksbündig";
    strings["richtext.text.justifyleft_de"] = "Richtet den Text linksbündig aus.";
    strings["richtext.title.justifycenter_de"] = "Zentriert";
    strings["richtext.text.justifycenter_de"] = "Richtet den Text mittig aus.";
    strings["richtext.title.justifyright_de"] = "Rechtsbündig";
    strings["richtext.text.justifyright_de"] = "Richtet den Text rechtsbündig aus.";
    strings["richtext.title.indent_de"] = "Einrücken (Tab)";
    strings["richtext.text.indent_de"] = "Text einrücken.";
    strings["richtext.title.outdent_de"] = "Ausrücken (Umschalt+Tab)";
    strings["richtext.text.outdent_de"] = "Text ausrücken.";
    strings["richtext.title.createlink_de"] = "Link";
    strings["richtext.text.createlink_de"] = "Den markierten Text in einen Link umwandeln.";
    strings["richtext.title.unlink_de"] = "Link entfernen";
    strings["richtext.text.unlink_de"] = "Entfernt den Link des markierten Textes.";
    strings["richtext.title.insertorderedlist_de"] = "Aufzählung (nummeriert)";
    strings["richtext.text.insertorderedlist_de"] = "Eine nummerierte Liste einfügen.";
    strings["richtext.title.insertunorderedlist_de"] = "Aufzählung";
    strings["richtext.text.insertunorderedlist_de"] = "Eine Liste einfügen.";
    strings["richtext.title.removeformat_de"] = "Formatierung entfernen";
    strings["richtext.text.removeformat_de"] = "Entfernt jegliche Formatierung des markierten Textes.";
    strings['richtext.colormenu.defaultcolor_de'] = 'Automatisch';
    strings['richtext.stub.more_de'] = 'mehr';
    strings['richtext.stub.less_de'] = 'weniger';
    strings['richtext.stub.openprint_de'] = 'Druckansicht öffnen';

    strings['richtext.simpleeditingmodetitle_de'] = 'Einfacher Editierungsmodus';
    strings['richtext.simpleeditingmodedesc_de'] = 'Zum einfachen Editierungsmodus wechseln';
    strings['richtext.simpleeditingmodewarning_de'] = 'Im einfachen Editierungsmodus stehen keine erweiterten Formatierungsoptionen zur Verfügung. Wenn Sie mit der Textbearbeitung fortfahren, gehen möglicherweise bisherige Formatierungen verloren.';
    strings['richtext.notavailable.title_de'] = "Erweiterte Formatierungsoptionen nicht verfügbar";
    strings['richtext.notavailable.warning_de'] = "Das Editieren von Texten mit erweiterten Formatierungsoptionen wird von ihrem aktuellen Browser nicht unterstützt.<br/>Wenn Sie mit der Textbearbeitung fortfahren, gehen möglicherweise bisherige Formatierungen verloren.";

    strings['richtext.link.address_de'] = 'Bitte geben Sie die Zieladresse ein:';
    strings['richtext.link.tooltip_de']= 'mit Strg+Klick öffnen';

    strings['commed.expression.otherwise_de'] = 'Ansonsten';
    strings['commed.expression.manual_de'] = 'Manuelle Nutzeraktion';

    // COMMED TRANSLATIONS
    strings['commed.expression.automaticrule_de'] = 'Automatische JavaScript-Regel';
    strings['commed.expression.jsrule_de'] = 'JavaScript-Regel';
    strings['commed.expression.standarderror_de'] = 'Standard-Fehler';
    strings['commed.expression.exception_de'] = 'Ausnahme';
    strings['commed.expression.exceptions_de'] = 'Ausnahmen';
    strings['commed.rolemapping.loadingroles_de'] = 'Rollen werden geladen.';
    strings['commed.servicecall.and_de'] = 'und';
    strings['commed.servicecall.aredefined_de'] = 'sind definiert.';
    strings['commed.servicecall.loadingformulars_de'] = 'Formulare werden geladen.';
    strings['commed.servicecall.loadingmeasures_de'] = 'Maßnahmen werden geladen...';
    strings['commed.servicecall.formulars_de'] = 'Formulare';
    strings['commed.servicecall.performingsearch_de'] = 'Suche wird durchgeführt...';
    strings['commed.servicecall.nofound_de'] = 'Keine Maßnahme gefunden.';
    strings['commed.servicecall.nomeasuresselected_de'] = 'Bisher keine Maßnahmen ausgewählt.';
    strings['commed.servicecall.pleaseselect_de'] = 'Bitte selektieren Sie auf der rechten Seite eine Maßnahme und fügen Sie diese zur Auswahl hinzu.';
    strings['commed.servicecall.measure_de'] = 'Measure';
    strings['commed.servicecall.nowfv_de'] = 'Keine definierte WFV.';
    strings['commed.servicecall.loadinginputs_de'] = 'Inputs wird geladen.';
    strings['commed.servicecall.noinputs_de'] = 'Keine Inputs vorhanden.';
    strings['commed.servicecall.loadingoutputs_de'] = 'Outputs wird geladen.';
    strings['commed.servicecall.nooutputs_de'] = 'Keine Outputs vorhanden.';
    strings['commed.servicecall.loadingservice_de'] = 'Dienst wird geladen.';
    strings['commed.servicecall.selectservice_de'] = 'Bitte selektieren Sie einen Dienst.';
    strings['commed.servicecall.remove_de'] = 'Entfernen';
    strings['commed.servicecall.parameteralert_de'] = "Für dieses Attribut muss eine 'Unterprozess-Referenz' definiert sein. Klicken Sie bitte dafür auf das vorgesehene Plus und verknüpfen einen Unterprozess.";
    strings['commed.servicecall.selectboandservice_de'] = 'Bitte selektieren Sie einen Dienst und ein BO.';
    strings['commed.servicecall.noinputsinsub_de'] = 'Keine Inputs im Unterprozess definiert.';
    strings['commed.servicecall.nooutputsinsub_de'] = 'Keine Outputs im Unterprozess definiert.';
    strings['commed.servicecall.noserviceinsub_de'] = 'Im verknüpften Unterprozess wurde kein Dienst definiert.';

    strings['attribute.mapper.loading_de'] = "Lade";
    strings['attribute.mapper.stencilsets_de'] = "Diagrammtypen";
    strings['attribute.mapper.attributes_selected_de'] = "#{count} verschiedene Attribut(e) ausgewählt";
    strings['attribute.mapper.attributes_deselected_de'] = "#{count} Attribut(e) ausgeschlossen";
    strings['attribute.mapper.deselected_de'] = "#{count} Element(e) ausgeschlossen";
    strings['attribute.mapper.selected_de'] = "#{count} Element(e) ausgewählt";
    strings['attribute.mapper.no_attributes_de'] = "Für diese Modellierungssprache stehen keine Attribute zur Verfügung.";
    strings['attribute.mapper.no_selection_de'] = "Keines";
    strings['attribute.mapper.exclusion_active_de'] = "Einschränkungen aktiv";
    strings['attribute.mapper.excluion_inactive_de'] = "Keine Einschränkungen";
    strings['attribute.mapper.list_de'] = "Liste";
    strings['attribute.mapper.selected_de'] = "#{count} ausgewählt";
    strings['attribute.mapper.untitled_group_de'] = "Unbenannte Gruppe";
    strings['attribute.mapper.config.all_attributes_de'] = "Alle Attribute";
    strings['attribute.mapper.config.own_attributes_de'] = "Eigene Attribute";
    strings['attribute.mapper.config.select_attributes_de'] = "Attribute selbst wählen";
    strings['attribute.mapper.config.all_elements_de'] = "Alle Elemente";
    strings['attribute.mapper.config.flow_elements_de'] = "Nur Kontrollflusselemente";
    strings['attribute.mapper.config.activities_de'] = "Nur Tätigkeiten";
    strings['attribute.mapper.config.select_elements_de'] = "Elemente selbst wählen";
    strings['attribute.mapper.config.name_de'] = "Name";
    strings['attribute.mapper.config.description_de'] = "Beschreibung";
    strings['attribute.mapper.config.hide_empty_attributes_de'] = "Leere Attribute ignorieren";
    strings['attribute.mapper.config.show_attribute_label_de'] = "Name des Attributs anzeigen";
    strings['attribute.mapper.config.separate_labels_de'] = "Attribute trennen durch";
    strings['attribute.mapper.config.separator_comma_de'] = "Komma";
    strings['attribute.mapper.config.separator_space_de'] = "Leerzeichen";
    strings['attribute.mapper.config.separator_linebreak_de'] = "Zeilenumbruch";
    strings['attribute.mapper.config.list_style_de'] = "Listen anzeigen als";
    strings['attribute.mapper.config.list_style_bullet_de'] = "Aufzählung";
    strings['attribute.mapper.config.list_style_numbered_de'] = "Nummerierte Liste";
    strings['attribute.mapper.config.main_properties_de'] = "Hauptattribute";
    strings['attribute.mapper.config.more_properties_de'] = "Weitere Attribute";
    strings['attribute.mapper.config.meta_properties_de'] = "Eigene Attribute";

    strings['glossary.mapper.type.document_de'] = "Dokumente";
    strings['glossary.mapper.type.org_unit_de'] = "Organisation";
    strings['glossary.mapper.type.it_system_de'] = "IT Systeme";
    strings['glossary.mapper.type.activity_de'] = "Aktivitäten";
    strings['glossary.mapper.type.state_de'] = "Ereignisse";
    strings['glossary.mapper.loading_groups_de'] = "Lade Glossarkategorien...";
    strings['glossary.mapper.all_categories_de'] = "Alle ausgewählt";
    strings['glossary.mapper.categories_chosen_de'] = "ausgewählt";
    strings['glossary.mapper.select_all_de'] = "Alle auswählen";
    strings['glossary.mapper.select_none_de'] = "Nichts auswählen";

    strings['glossary.new.languageswitch_de'] = "Sprachauswahl";
    
    strings['glossary.form.description_de'] = "Die folgenden Attribute können Sie mehrsprachig hinterlegen. Wechseln Sie dazu einfach während der Bearbeitung die Sprache, indem Sie über die Dropdown-Liste im oberen Bereich den gewünschten Eintrag auswählen.<br/>Bitte beachten Sie, dass der Titel in mindestens einer Sprache definiert sein muss.";

    strings['glossary.edit.title_de'] = "Glossarbegriff bearbeiten";
    strings['glossary.edit.save_de'] = "Speichern";
    strings['glossary.edit.description_de'] = "Hier können Sie einen vorhandenen Glossareintrag bearbeiten. Dabei aktualisieren sich nach dem Speichern Ihrer Änderungen automatisch alle Verweise auf diesen Glossarbegriff.";

    strings['glossary.new.title_de'] = "Neuer Glossarbegriff";
    strings['glossary.new.save_de'] = "Erzeugen";
    strings['glossary.new.create_de'] = "Erzeugt einen neuen Glossarbegriff.";

    strings['glossary.multilanguage.non_attributes_de'] = "Alle weiteren Attribute können nur in der Standardsprache definiert werden.";
    strings['glossary.multilanguage.copy_link_tt_de'] = "Beachten Sie bitte, dass beim Kopieren der Inhalte alle Inhalte auf der rechten Seiten ersetzt werden.";
    strings['glossary.multilanguage.remove_origin_column_de'] = "Linke Spalte ausblenden";
    strings['glossary.multilanguage.copy_link_title_de'] = "Alle Inhalte kopieren";

    strings['glossary.view.title_de'] = "Titel";
    strings['glossary.view.attachments_de'] = "Mitgeltende Dokumente";
    strings['glossary.view.description_de'] = "Beschreibung";

    strings['propertyeditor.itsm.assignee.company_de'] = "Unternehmen";
    strings['propertyeditor.itsm.assignee.organization_de'] = "Organisation";
    strings['propertyeditor.itsm.assignee.group_de'] = "Gruppe";
    strings['propertyeditor.itsm.location.region_de'] = "Region";
    strings['propertyeditor.itsm.location.sitegroup_de'] = "Standortgruppe";
    strings['propertyeditor.itsm.location.site_de'] = "Standort";
    strings['propertyeditor.itsm.servicecat.tier_de'] = "Schicht {0}";
    strings['propertyeditor.itsm.productcat.name_de'] = "Name";
    strings['propertyeditor.itsm.productcat.model_de'] = "Modell";
    strings['propertyeditor.itsm.variablemapping.header.variable_de'] = "Variable";
    strings['propertyeditor.itsm.variablemapping.header.input_de'] = "Input";
    strings['propertyeditor.itsm.variablemapping.header.output_de'] = "Output";
    strings['propertyeditor.itsm.variablemapping.error.title_de'] = "Zu viele Variablen";
    strings['propertyeditor.itsm.variablemapping.error.message_de'] = "Es werden zu viele Variablen vom Typ '{0}' verwendet.<br/> Das Maximum beträgt: {1}.";

    strings['propertyeditor.itsm.condition.add_de'] = "Hinzufügen der Variable...";

    // PRINT DIALOG
    strings["dialog.print.title_de"] = "PDF Export";
    strings["dialog.print.mask.load.defaults_de"] = "Standardeinstellungen werden geladen...";
    strings["dialog.print.mask.create.pdf_de"] = "Erzeuge PDF...";
   	strings["dialog.print.button.create_de"] = "PDF erzeugen";
   	strings["dialog.print.button.edit_de"] = "Bearbeiten";
   	strings["dialog.print.button.remove_de"] = "Entfernen";
   	strings["dialog.print.button.upload_de"] = "Logo einfügen";
   	strings["dialog.print.button.configure_de"] = "Konfigurieren";
   	strings["dialog.print.save.defaults.label_de"] = "Als Standard Einstellung übernehmen";
   	strings["dialog.print.orientation.landscape_de"] = "Querformat";
   	strings["dialog.print.orientation.portrait_de"] = "Hochformat";
   	strings["dialog.print.orientation.label_de"] = "Diagrammausrichtung";
   	strings["dialog.print.orientation.policy.label_de"] = "Diagramm ausrichten";
   	strings["dialog.print.orientation.policy.auto_de"] = "Automatisch";
   	strings["dialog.print.orientation.policy.always_de"] = "Immer";
   	strings["dialog.print.orientation.policy.never_de"] = "Niemals";
   	strings["dialog.print.orientation.cw_de"] = "Im Uhrzeigersinn";
   	strings["dialog.print.orientation.ccw_de"] = "Gegen den Uhrzeigersinn";
   	strings["dialog.print.paper.type.label_de"] = "Papiertyp"
   	strings["dialog.print.paper.type.a4_de"] = "DIN A4";
   	strings["dialog.print.paper.type.a3_de"] = "DIN A3";
   	strings["dialog.print.paper.type.us_letter_de"] = "US Letter";
   	strings["dialog.print.distribution.single_de"] = "Eine Seite";
   	strings["dialog.print.distribution.multi_de"] = "Mehrseitig";
   	strings["dialog.print.black.and.white_de"] = "Schwarz-Weiß-Druck";
   	strings["dialog.print.show.headers_de"] = "Zusätzliche Informationen anzeigen";
   	strings["dialog.print.label_de"] = "Expotieren Sie ein oder mehrere Diagramme zu PDF. Sie können generelle Exportoptionen festlegen, sowie spezielle Attribute zu dem expoertierten Diagramm anzeigen lassen.";
   	strings["dialog.print.label.download_de"] = "Ihr PDF wird nun erstellt. Der Download startet in wenigen Momenten automatisch.";
   	strings["dialog.print.label.more.models_de"] = "(und #{count} weitere(s))";
   	strings["dialog.print.header.general_de"] = "Allgemein";
   	strings["dialog.print.header.orientation_de"] = "Ausrichtung";
   	strings["dialog.print.header.distribution_de"] = "Verteilung";
   	strings["dialog.print.attribute.hint_de"] = "Fügen Sie hier bis zu 3 Attribute hinzu.";
   	strings["dialog.print.attribute.ownattribute_de"] = "Eigenes Attribut";
   	strings["dialog.print.attribute.lastauthor_de"] = "Letzer Autor";
   	strings["dialog.print.attribute.publishingdate_de"] = "Veröffentlicht am";
   	strings["dialog.print.attribute.publishingstatus_de"] = "Veröffentlicht";
   	strings["dialog.print.attribute.authors_de"] = "Autoren";
   	strings["dialog.print.attribute.updatedate_de"] = "Zuletzt geändert";
   	strings["dialog.print.attribute.modelpath_de"] = "Pfad";
   	strings["dialog.print.attribute.pagenumber_de"] = "Seitennummer";
   	strings["dialog.print.attribute.printdate_de"] = "Druckdatum";
   	strings["dialog.print.attribute.printedby_de"] = "Gedruckt von";
   	strings["dialog.print.diagram.name_de"] = "Diagrammname";
   	strings["dialog.print.error.no.models_de"] = "Bitte selektieren Sie mindestens ein Diagram oder einen Ordner.";

   	// UPLOAD DIALOG
   	strings["dialog.upload.title_de"] = "Datei auswählen oder hochladen";
   	strings["dialog.upload.label.new.file_de"] = "Neue Datei hochladen";
   	strings["dialog.upload.label.existing.file_de"] = "Datei/Bild aus Dateiablage auswählen";
   	strings["dialog.upload.label.external.file_de"] = "Datei/Bild auf Netzlaufwerk oder Webressource verlinken";
   	strings["dialog.upload.label.external.empty_de"] = "Es sind keine Einträge vorhanden.";
   	strings["dialog.upload.label.choose.spacer_de"] = "Datei auswählen";
   	strings["dialog.upload.label.spacer.or_de"] = "Oder";
   	strings["dialog.upload.label.description_de"] = "Bitte wählen Sie eine Datei oder ein Bild aus Ihrer Signavio Dateiablage aus. Alternativ können Sie eine Datei auch als Webresource über eine URL verlinken oder einen Pfad zu einer Datei oder einem Bild auf einem Netzlaufwerk angeben.";
   	strings["dialog.upload.label.disabled_de"] = "Die Signavio Dateiablage ist für Ihren Arbeitsbereich deaktiviert.";
   	strings["dialog.upload.label.upload.disabled_de"] = "Das Hochladen neuer Dateien ist für Ihren Arbeitsbereich deaktiviert.";
   	strings["dialog.upload.label.max.size_de"] = "Die maximale Dateigröße beträgt "
   	strings["dialog.upload.error.file.too.big.title_de"] = "Datei zu groß";
   	strings["dialog.upload.error.file.too.big.description_de"] = "Das Dokument/Bild ist zu groß oder würde das maximal zulässige Datenkontingent überschreiten. Bitte löschen Sie nicht mehr benötigte Dateien oder wenden Sie sich an den Signavio Support, um das Datenkontingent zu erweitern.";
   	strings["dialog.upload.error.file.too.big.single_de"] = "Die Datei ist größer als die maximal erlaubte Dateigröße";
   	strings["dialog.upload.error.file.too.big.all_de"] = "Die Datei würde das maximal zulässige Speicherkontingent überschreiten.";
   	strings["dialog.upload.error.no.folder.selected_de"] = "Bitte wählen Sie einen Ordner aus Ihrer Signavio Dateiablage, in welchem das neue Dokument/Bild gespeichert werden soll.";
   	strings["dialog.upload.error.no.file.selected_de"] = "Bitte wählen Sie eine Datei aus, die Sie hochladen möchten.";
   	strings["dialog.upload.error.no.image.selected_de"] = "Bitte wählen Sie ein Bild aus Ihrer Signavio Dateiablage aus.";
   	strings["dialog.upload.action.upload_de"] = "Daten werden hochgeladen...";

   	strings["component.folder.picker.empty_de"] = "Bitte wählen Sie einen Ordner aus.";
   	strings["component.folder.picker.custom_de"] = "Anderen Ordner wählen...";
   	strings["component.folder.picker.description_de"] = strings["component.folder.picker.empty_de"];
   	strings["component.folder.picker.head_de"] = "Ordnerauswahl";

   	strings["component.types.folder_de"] = "&raquo; Ordner";
   	strings["component.types.favorits_de"] = "&raquo; Favoriten";
   	strings["component.types.savedSearch_de"] = "&raquo; Gespeicherte Suche";
   	strings["component.types.public_de"] = "Gemeinsame Dokumente";
   	strings["component.types.private_de"] = "Meine Dokumente";
   	strings["component.types.published_de"] = "Öffentliche Dokumente";
   	strings["component.types.trash_de"] = "Papierkorb";


    strings['language_bg_de'] =  "Bulgarisch";
    strings['language_cz_de'] =  "Tschechisch";
    strings['language_da_de'] =  "Dänisch";
    strings['language_nl_de'] =  "Niederländisch";
    strings['language_ee_de'] =  "Estnisch";
    strings['language_fi_de'] =  "Finnisch";
    strings['language_fr_de'] =  "Französisch";
    strings['language_de_de'] =  "Deutsch";
    strings['language_gr_de'] =  "Griechisch";
    strings['language_hu_de'] =  "Ungarisch";
    strings['language_ie_de'] =  "Irisch";
    strings['language_it_de'] =  "Italienisch";
    strings['language_lv_de'] =  "Lettisch";
    strings['language_lt_de'] =  "Litauisch";
    strings['language_mt_de'] =  "Maltesisch";
    strings['language_pl_de'] =  "Polnisch";
    strings['language_pt_de'] =  "Portugiesisch";
    strings['language_ro_de'] =  "Romänisch";
    strings['language_sk_de'] =  "Slowakisch";
    strings['language_si_de'] =  "Slowenisch";
    strings['language_es_de'] =  "Spanisch";
    strings['language_se_de'] =  "Schwedisch";
    strings['language_en_de'] =  "Englisch";
    strings['language_lu_de'] =  "Luxemburgisch";
    strings['language_za_de'] = "Afrikaans";

    strings['country_at_de'] = "Österreich";
    strings['country_be_de'] = "Belgien";
    strings['country_bg_de'] = "Bulgarien";
    strings['country_ch_de'] = "Schweiz";
    strings['country_cz_de'] = "Tschechisch";
    strings['country_dk_de'] = "Dänemark";
    strings['country_gb_de'] = "Großbritannien";
    strings['country_nl_de'] = "Niederlande";
    strings['country_ee_de'] = "Estland";
    strings['country_fi_de'] = "Finnland";
    strings['country_fr_de'] = "Frankreich";
    strings['country_de_de'] = "Deutschland";
    strings['country_gr_de'] = "Griechenland";
    strings['country_hu_de'] = "Ungarn";
    strings['country_ie_de'] = "Irland";
    strings['country_it_de'] = "Italien";
    strings['country_lv_de'] = "Lettland";
    strings['country_lt_de'] = "Litauen";
    strings['country_mt_de'] = "Malta";
    strings['country_pl_de'] = "Polen";
    strings['country_pt_de'] = "Portugal";
    strings['country_ro_de'] = "Romänien";
    strings['country_sk_de'] = "Slowakei";
    strings['country_si_de'] = "Slowenien";
    strings['country_es_de'] = "Spanien";
    strings['country_se_de'] = "Schweden";
    strings['country_en_de'] = "England";
    strings['country_mx_de'] = "Mexiko";
    strings['country_us_de'] = "USA";
    strings['country_lu_de'] = "Luxemburg";
    strings['country_za_de'] = "Südafrika";
    strings['country_br_de'] = "Brasilien";
    strings['country_ca_de'] = "Kanada";
    strings['country_cl_de'] = "Chile";
    strings['country_li_de'] = "Liechtenstein";
    strings['country_nz_de'] = "Neuseeland";
    strings['country_au_de'] = "Australien";

    //TODO
    strings['multilanguage.label_de'] = "Sprache";

    strings['multilanguage.language.bg_de'] = "Bulgarisch";
	strings['multilanguage.language.cs_de'] = "Tschechisch";
	strings['multilanguage.language.dk_de'] = "Dänisch";
	strings['multilanguage.language.nl_de'] = "Niederländisch";
	strings['multilanguage.language.et_de'] = "Estnisch";
	strings['multilanguage.language.fi_de'] = "Finnisch";
	strings['multilanguage.language.fr_de'] = "Französisch";
	strings['multilanguage.language.de_de'] = "Deutsch";
	strings['multilanguage.language.el_de'] = "Griechisch";
	strings['multilanguage.language.hu_de'] = "Ungarisch";
	strings['multilanguage.language.ie_de'] = "Irisch";
	strings['multilanguage.language.it_de'] = "Italienisch";
	strings['multilanguage.language.lv_de'] = "Lettisch";
	strings['multilanguage.language.lt_de'] = "Litauisch";
	strings['multilanguage.language.mt_de'] = "Maltesisch";
	strings['multilanguage.language.pl_de'] = "Polnisch";
	strings['multilanguage.language.pt_de'] = "Portugiesisch";
	strings['multilanguage.language.ro_de'] = "Romänisch";
	strings['multilanguage.language.sk_de'] = "Slowakisch";
	strings['multilanguage.language.sl_de'] = "Slowenisch";
	strings['multilanguage.language.es_de'] = "Spanisch";
	strings['multilanguage.language.sv_de'] = "Schwedisch";
	strings['multilanguage.language.en_de'] = "Englisch";
	strings['multilanguage.language.lb_de'] = "Luxemburgisch";
	strings['multilanguage.language.af_de'] = "Afrikaans";

	strings['multilanguage.country.at_de'] = "Österreich";
	strings['multilanguage.country.be_de'] = "Belgien";
	strings['multilanguage.country.bg_de'] = "Bulgarien";
	strings['multilanguage.country.ch_de'] = "Schweiz";
	strings['multilanguage.country.cz_de'] = "Tschechisch";
	strings['multilanguage.country.dk_de'] = "Dänemark";
	strings['multilanguage.country.gb_de'] = "Großbritannien";
	strings['multilanguage.country.nl_de'] = "Niederlande";
	strings['multilanguage.country.ee_de'] = "Estland";
	strings['multilanguage.country.fi_de'] = "Finnland";
	strings['multilanguage.country.fr_de'] = "Frankreich";
	strings['multilanguage.country.de_de'] = "Deutschland";
	strings['multilanguage.country.gr_de'] = "Griechenland";
	strings['multilanguage.country.hu_de'] = "Ungarn";
	strings['multilanguage.country.ie_de'] = "Irland";
	strings['multilanguage.country.it_de'] = "Italien";
	strings['multilanguage.country.lv_de'] = "Lettland";
	strings['multilanguage.country.lt_de'] = "Litauen";
	strings['multilanguage.country.mt_de'] = "Malta";
	strings['multilanguage.country.pl_de'] = "Polen";
	strings['multilanguage.country.pt_de'] = "Portugal";
	strings['multilanguage.country.ro_de'] = "Romänien";
	strings['multilanguage.country.sk_de'] = "Slowakei";
	strings['multilanguage.country.si_de'] = "Slowenien";
	strings['multilanguage.country.es_de'] = "Spanien";
	strings['multilanguage.country.se_de'] = "Schweden";
	strings['multilanguage.country.en_de'] = "England";
	strings['multilanguage.country.mx_de'] = "Mexiko";
	strings['multilanguage.country.us_de'] = "USA";
	strings['multilanguage.country.lu_de'] = "Luxemburg";
	strings['multilanguage.country.za_de'] = "Südafrika";
	strings['multilanguage.country.br_de'] = "Brasilien";
	strings['multilanguage.country.ca_de'] = "Kanada";
	strings['multilanguage.country.cl_de'] = "Chile";
	strings['multilanguage.country.li_de'] = "Liechtenstein";
	strings['multilanguage.country.nz_de'] = "Neuseeland";
	strings['multilanguage.country.au_de'] = "Australien";

	// IKS
	strings['iks.title_de'] = "Risiken und Kontrollen";
	strings['iks.desc_de'] = "Definieren Sie mögliche Risiken und deren Kontrollen.";
	strings['iks.windowapply_de'] = "Übernehmen";
	strings['iks.overlayhint_de'] = "Klicken Sie hier um Risiken und Kontrollen dieses Elements zu bearbeiten";
	strings['iks.toolbarname_de'] = "Risiken und Kontrollen anzeigen";
	strings['iks.toolbardesc_de'] = "Risiken und Kontrollen am Prozesselement anzeigen";
	strings['iks.risk_de'] = "Risiko";
	strings['iks.risks_de'] = "Risiken";
	strings['iks.control_de'] = "Kontrolle";
	strings['iks.controls_de'] = "Kontrollen";
	strings['iks.newentry_de'] = "Klicken Sie hier, um ein{0}hinzuzufügen...";
	strings['iks.newentryrisk_de'] = " neues Risiko ";
	strings['iks.newentrycontrol_de'] = "e neue Kontrolle ";
	strings['iks.addcontrols_de'] = "Kontrollen hinzufügen";
	strings['iks.removerisk_de'] = "Dieses Risiko löschen";
	strings['iks.removecontrol_de'] = "Diese Kontrolle löschen";
	strings['iks.deletethistpl_de'] = "Diese";
	strings['iks.deletethisrisk_de'] = "s Risiko und alle zugehörigen Kontrollen löschen?";
	strings['iks.deletethiscontrol_de'] = " Kontrolle löschen?";
	strings['iks.yes_de'] = "Ja";
	strings['iks.no_de'] = "Nein";
	strings['iks.globalrisks_de'] = "Risiken auf Diagrammebene";
	
	// NestableEditorGridPanel
	strings['negp.nestedfield.emptytext_de'] = "Inhalt hinzufügen";
	strings['negp.delete_de'] = "Löschen?";
	strings['negp.yes_de'] = "Ja";
	strings['negp.no_de'] = "Nein";

	strings['propertyeditor.npb.title_de'] = "Pflichtattribute für die Nationale Prozessbibliothek";
	strings['propertyeditor.npb.topics.title_de'] = "Themenbereiche festlegen";
	strings['propertyeditor.npb.topics.desc_de'] = "Wählen Sie einen oder mehrere vordefinierte Themenbereiche aus oder geben Sie einen neuen Themenbereich an.";
	strings['propertyeditor.npb.topics.predefined_de'] = "vordefinierte Themenbereiche";
	strings['propertyeditor.npb.topics.other_de'] = "Sonstiges";
	strings['propertyeditor.npb.render_msg_de'] = " von 9 Attributen gesetzt";
    strings['propertyeditor.npb.invalid_leika_de'] = "Der eingebene Wert ist kein gültiger LeiKa-Schlüssel.";
    strings['propertyeditor.npb.no_leika_de'] = "Kein LeiKa-Eintrag.";
    strings['propertyeditor.npb.searching_de'] = "Suche...";

	// Glossary Controls
	strings['glossary.category.label_de'] = "Kategorie";
﻿
	/**
	 * ENGLISH TRANSLATION
	 * First translation into English: -
	 * Translator: -
	 * @translationchecker -
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd = "Add";
	strings.btnopen = "Open";
	strings.btnremove = "Remove";
	strings.btnedit = "Edit";
	strings.btnreset = "Reset";
	strings.btnclose = "Close";
	strings.btnsave = "Save";
	strings.btnapply = "Apply";
	strings.moveup = "Move up";
	strings.movedown = "Move down";
	strings.url = "URL";
	strings.label = "Label";
	strings.year = "Year";
	strings.years = "Years";
	strings.month = "Month";
	strings.months = "Months";
	strings.day = "Day";
	strings.days = "Days";
	strings.hour = "Hour";
	strings.hours = "Hours";
	strings.minute = "Minute";
	strings.minutes = "Minutes";
	strings.second = "Second";
	strings.seconds = "Seconds";
	strings.msecond = "Millisecond";
	strings.mseconds = "Milliseconds";

	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly = "'#{0}' create as #{1}";
	strings.createglossarynew = "Create new";

	// GLOSSARY CATEGORIES
	strings.document = "Documents";
	strings.org_unit = "Organizational Units";
	strings.it_system = "IT Systems";
	strings.activity = "Activities";
	strings.state = "Events";

	strings.noglossary_entry = "No dictionary entry.";

	//Feedback Window
	strings["views.feedbacktitleenterprise"] = "Signavio Support";
	strings["views.feedbacktitle"] = "Support";
	strings["views.feedbacktitleenterprise"] = "Support";
	strings["views.feedbacktitle"] = "Signavio Support";
	strings["views.feedbackentersubject"] = "Please enter a subject that briefly describes the problem or question.";
	strings["views.feedbackenterdescription"] = "Please describe your problem or question as detailed as possible.";
	strings["views.feedbackpmsg"] = "Detailed description of the error";
	strings["views.feedbackpempty"] = "* Please describe your request. Please provide as detailed information as possible.\n* For bug 	reports, please list the steps how to reproduce the problem and describe the output you expected.";
	strings["views.feedbackpsubject"] = "Problem with the Signavio Process Editor";
	strings["views.feedbackpbrowser"] = "Information about your browser and environment";
	strings["views.feedbackpbrowserdesc"] = "This information has been auto-detected from your browser. It can be helpful if you 	encountered a bug associated with browser-specific behavior.";
	strings["views.feedbackclosetitle"] = "Close";
	strings["views.feedbackfailure"] = "Failure";
	strings["views.feedbackfailuremsg"] = "The message could not be sent!";
	strings["views.feedbacksuccess"] = "Success";
	strings["views.feedbacksuccessmsg"] = "Thank you for your feedback!";
	strings["views.feedbacksending"] = "Sending message ...";
	strings["views.sendfeedback"] = "Send support request";
	strings["views.feedbackcopy"] = "Send a copy to e-mail.";
	strings["views.feedbackcopydesc"] = "Sends a copy of your support request to your e-mail.";
	strings["views.feedbackpattach"] = "Attach Current Diagram";
	strings["views.feedbackpattachdesc"] = "This information can be helpful for debugging purposes. If your diagram contains any sensitive data, remove it before sending or uncheck this behavior.";
	strings["views.feedbackreceiver"] = "Recipient";
	strings["views.feedbackreceiversignavio"] = " Signavio support ([mail])";
	strings["views.feedbackreceiverenterprise"] = " Your support ([mail])";
	strings["views.feedbackmissingheader"] = "No problem statement";
	strings["views.feedbackmissingheadermsg"] = "Please enter a short problem statement.";
	strings["views.feedbackmissingbody"] = "No detailed description";
	strings["views.feedbackmissingbodymsg"] = "Please describe in a detailed message: What kind of problems do you have? What is the expected behaviour?";
	strings["views.feedbackerrorlength"] = "The description is too short. Please type at least 40 letters.";
	strings["views.feedbackerrorlengthtitle"] = "Message is too short";
	strings["views.feedbacksignavio"] = "You have a problem with using the Signavio Process Editor or you have found an error? In this case please use the support form to contact the Signavio " +
										"support directly. Please notice, that the handling of your request can take about 1-2 business days. " +
										"We will respond by email. All information is transferred unencrypted.";
										   "Falle das Support-Formular um direkten Kontakt mit Signavio aufzunehmen. Bitte beachten Sie, dass eine Bearbeitung Ihrer Anfrage "+
										   "ca. 1-2 Werktage in Anspruch nehmen kann. Sie erhalten unsere Antwort anschließend per Email. Sämtliche Informationen werden unverschlüsselt "+
										   "übertragen.";
										  "Por favor tome en cuenta que el manejo de su solicitud puede tardar de 1-2 días hábiles." + "Le responderemos por correo electrónico. Toda la información se transmite cifrada";
	strings["views.feedbackenterprise"] = "You have a problem with using the Signavio Process Editor or you have found an error? In this case please use the support form to directly contact your " +
										  "support or administrator. All information is transferred unencrypted.";
											 "Falle das Support-Formular um direkten Kontakt mit Ihrem Support/Administrator aufzunehmen. Sämtliche Informationen werden unverschlüsselt "+
											 "übertragen.";
										  "Por favor tome en cuenta que el manejo de su solicitud puede tardar de 1-2 días hábiles." + "Le responderemos por correo electrónico. Toda la información se transmite cifrada";
	//PDF Export Window
	strings["views.offertitle"] = "PDF (single diagram)";
	strings["views.offertitledesc"] = "You can print your diagram across multiple pages. Please select the layout you would like to have your PDF export.";
	strings["views.optionwindowtitle"] = "PDF Export (single diagram)";
	strings["views.buttontitle"] = "Generate PDF";
	strings["views.closetitle"] = "Cancel";
	strings["views.fittopage"] = "Fit to one page";
	strings["views.clipallsides"] = "Continuous print (2-dimensional)";
	strings["views.clipbottom"] = "Continuous print (vertical)";
	strings["views.clipright"] = "Continuous print (horizontal)";
	strings["views.landscape"] = "Landscape";
	strings["views.portrait"] = "Portrait";
	strings["views.defaultname"] = "Export";
	strings["views.branding"] = "Remove Signavio logos";
	strings["views.premiumonly"] = "This feature is only available in the Professional edition.";
	strings["views.waiting"] = "Process documentation will be created.<br/>This might take some time...";
	strings["views.resetview"] = "Original";
	strings["views.windowdescription"] = "Please select a View for the Export:";


	strings["panel.businessrule"] = "Business Rule";
	strings["panel.static"] = "Static";
	strings["panel.dynamic"] = "Dynamic";
	strings["panel.operation"] = "Operation";
	strings["panel.add"] = "add";
	strings["panel.remove"] = "remove";

	strings["panel.no_description"] = "No description";
	strings["panel.no_performer"] = "No Performer defined.";
	strings["panel.no_users"] = "No Users available.";
	strings["panel.no_free_userselection"] = "Unrestricted user selection";
	strings["panel.no_parallel_title"] = "Add a group";
	strings["panel.no_parallel_description"] = "For the current element the loop type is set either to parallel or sequential, it means that several users might perform the task. To simplify this, do you want to use all members of the selected group instead of the group themselve?";
	strings["panel.no_parallel_no_user"] = "The current group has no members contained.";
	strings["panel.no_defined_role_label"] = "Pre-selection";
	strings["panel.no_defined_role_single_user"] = "Single user";
	strings["panel.no_defined_role_role_member"] = "Group/role members";
	strings["panel.no_defined_role_group"] = "Groups/roles";
	strings["panel.label_free_userselection"] = "(Unrestricted user selection)";

	strings["wizard.nextbtnlabel"] = "Next >";
	strings["wizard.previousbtnlabel"] = "< Previous";

	/** New Language Properties 27.07.2010 */
    strings["richtext.title.undo"] = "Undo (Ctrl+Z)";
    strings["richtext.text.undo"] = "Undoes the last changes.";

    strings["richtext.title.redo"] = "Redo (Shift+Ctrl+Z)";
    strings["richtext.text.redo"] = "Redoes the last changes.";
    strings["richtext.title.bold"] = "Bold (Ctrl+B)";
    strings["richtext.text.bold"] = "Make the selected text bold.";

    strings["richtext.title.italic"] = "Italic (Ctrl+I)";
    strings["richtext.text.italic"] = "Make the selected text italic.";

    strings["richtext.title.underline"] = "Underline (Ctrl+U)";
    strings["richtext.text.underline"] = "Underline the selected text.";

    strings["richtext.title.fontselect"] = "Font";
    strings["richtext.text.fontselect"] = "Change the font of the selected text.";

    strings["richtext.title.fontsizeselect"] = "Fontsize";
    strings["richtext.text.fontsizeselect"] = "Change the fontsize of the selected text.";

    strings["richtext.title.h1"] = "Headline";
    strings["richtext.text.h1"] = "Insert a headline.";

    strings["richtext.title.h2"] = "Subheadline";
    strings["richtext.text.h2"] = "Insert a subheadline.";

    strings["richtext.title.h3"] = "Section Headline";
    strings["richtext.text.h3"] = "Insert a new section headline.";

    strings["richtext.title.inserthorizontalrule"] = "Horizontal Rule";
    strings["richtext.text.inserthorizontalrule"] = "Inserts a horizontal rule.";

    strings["richtext.title.color"] = "Font Color";
    strings["richtext.text.color"] = "Change the color of the selected text.";

    strings["richtext.title.markupcolor"] = "Text Highlight Color";
    strings["richtext.text.markupcolor"] = "Change the background color of the selected text.";

    strings["richtext.title.justifyleft"] = "Align Text Left";
    strings["richtext.text.justifyleft"] = "Align text to the left.";

    strings["richtext.title.justifycenter"] = "Center Text";
    strings["richtext.text.justifycenter"] = "Center text in the editor.";

    strings["richtext.title.justifyright"] = "Align Text Right";
    strings["richtext.text.justifyright"] = "Align text to the right.";

    strings["richtext.title.indent"] = "Indent (Tab)";
    strings["richtext.text.indent"] = "Indent Text.";

    strings["richtext.title.outdent"] = "Outdent (Shift+Tab)";
    strings["richtext.text.outdent"] = "Outdent Text.";

    strings["richtext.title.createlink"] = "Hyperlink";
    strings["richtext.text.createlink"] = "Make the selected text a hyperlink.";

    strings["richtext.title.unlink"] = "Remove Hyperlink";
    strings["richtext.text.unlink"] = "Removes the Hyperlink of the selection.";

    strings["richtext.title.insertorderedlist"] = "List (numbered)";
    strings["richtext.text.insertorderedlist"] = "Start a numbered list.";

    strings["richtext.title.insertunorderedlist"] = "Bullet List";
    strings["richtext.text.insertunorderedlist"] = "Start a bulleted list.";

    strings["richtext.title.removeformat"] = "Remove Format";
    strings["richtext.text.removeformat"] = "Removes all formatting applied to the selection.";

    strings['richtext.colormenu.defaultcolor'] = 'Automatic';

    strings['richtext.stub.more'] = 'more';
    strings['richtext.stub.less'] = 'less';
    strings['richtext.stub.openprint'] = 'Open print view';

    strings['richtext.simpleeditingmodetitle'] = 'Simple Editing Mode';
    strings['richtext.simpleeditingmodedesc'] = 'Switch to simple Editing mode';
    strings['richtext.simpleeditingmodewarning'] = 'Advanced formating options are not available in the simple Editing mode. If you continue, all existing formating options can be lost.';
    strings['richtext.notavailable.title'] = "Advanced formating not available";
    strings['richtext.notavailable.warning'] = "The advanced Editing mode is not supported by your browser.<br/>If you continue, all existing formating options can be lost.";


    strings['richtext.link.address'] = 'Please enter the target address:';
    strings['richtext.link.tooltip'] = 'open with Ctrl+Click';


    // ComMed Translations
    strings['commed.expression.otherwise'] = 'Otherwise';
    strings['commed.expression.manual'] = 'Manual user action';
    strings['commed.expression.automaticrule'] = 'Automatic Rule for JavaScript';
    strings['commed.expression.jsrule'] = 'JavaScript-Rule';
    strings['commed.expression.standarderror'] = 'Standard error';
    strings['commed.expression.exception'] = 'Exception';
    strings['commed.expression.exceptions'] = 'Exceptions';
    strings['commed.rolemapping.loadingroles'] = 'Loading roles';
    strings['commed.servicecall.and'] = 'and';
    strings['commed.servicecall.aredefined'] = 'are defined.';
    strings['commed.servicecall.loadingformulars'] = 'Loading formular.';
    strings['commed.servicecall.loadingmeasures'] = 'Loading measures...';


    strings['commed.servicecall.formulars'] = 'Formulars';
    strings['commed.servicecall.performingsearch'] = 'Searching...';
    strings['commed.servicecall.nofound'] = 'Found no measure.';
    strings['commed.servicecall.nomeasuresselected'] = 'No measure selected so far.';
    strings['commed.servicecall.pleaseselect'] = 'Please select a measure on the right hand side to add it to your selection.';
    strings['commed.servicecall.measure'] = 'Measure';
    strings['commed.servicecall.nowfv'] = 'No WFV defined.';
    strings['commed.servicecall.loadinginputs'] = 'Loading Inputs.';
    strings['commed.servicecall.noinputs'] = 'No Inputs.';
    strings['commed.servicecall.loadingoutputs'] = 'Loading Outputs.';
    strings['commed.servicecall.nooutputs'] = 'No Outputs.';
    strings['commed.servicecall.loadingservice'] = 'Loading Service';
    strings['commed.servicecall.selectservice'] = 'Please select a service.';
    strings['commed.servicecall.remove'] = 'Remove';
    strings['commed.servicecall.parameteralert'] = "For this attribute you have to define a 'Subprocess-Reference'. Please press the plus button to link a subprocess ";
    strings['commed.servicecall.selectboandservice'] = 'Please select a Service and a BO.';
    strings['commed.servicecall.noinputsinsub'] = 'No Inputs in subprocess defined';
    strings['commed.servicecall.nooutputsinsub'] = 'No Outputs in subprocess defined';
    strings['commed.servicecall.noserviceinsub'] = 'The referenced subprocess has no Services defined';




    strings['attribute.mapper.loading'] = "Loading";
    strings['attribute.mapper.stencilsets'] = "diagram types";
    strings['attribute.mapper.deselected'] = "#{count} element(s) excluded";
    strings['attribute.mapper.attributes_selected'] = "#{count} different attribute(s) selected";
    strings['attribute.mapper.attributes_deselected'] = "#{count} attribute(s) excluded";
    strings['attribute.mapper.selected'] = "#{count} element(s) selected";
    strings['attribute.mapper.no_attributes'] = "There are no attributes available for this modeling language.";
    strings['attribute.mapper.no_selection'] = "None";
    strings['attribute.mapper.exclusion_active'] = "Restrictions set";
    strings['attribute.mapper.excluion_inactive'] = "No restrictions set";
    strings['attribute.mapper.list'] = "List";

    strings['attribute.mapper.selected'] = "#{count} selected";

    strings['attribute.mapper.untitled_group'] = "Untitled group";

    strings['attribute.mapper.config.all_attributes'] = "All attributes";
    strings['attribute.mapper.config.own_attributes'] = "Custom attributes";
    strings['attribute.mapper.config.select_attributes'] = "Select attributes";
    strings['attribute.mapper.config.all_elements'] = "All elements";
    strings['attribute.mapper.config.flow_elements'] = "Only flow elements";
    strings['attribute.mapper.config.activities'] = "Only activities";
    strings['attribute.mapper.config.select_elements'] = "Select elements";

    strings['attribute.mapper.config.name'] = "Name";
    strings['attribute.mapper.config.description'] = "Description";

    strings['attribute.mapper.config.hide_empty_attributes'] = "Hide attributes without value";
    strings['attribute.mapper.config.show_attribute_label'] = "Display attribute labels";
    strings['attribute.mapper.config.separate_labels'] = "Separate attributes by";
    strings['attribute.mapper.config.separator_comma'] = "Comma";
    strings['attribute.mapper.config.separator_space'] = "Space";
    strings['attribute.mapper.config.separator_linebreak'] = "Linebreak";
    strings['attribute.mapper.config.list_style'] = "Lists are shown as";
    strings['attribute.mapper.config.list_style_bullet'] = "Bullet list";
    strings['attribute.mapper.config.list_style_numbered'] = "Ordered list";

    strings['attribute.mapper.config.main_properties'] = "Main properties";
    strings['attribute.mapper.config.more_properties'] = "More properties";
    strings['attribute.mapper.config.meta_properties'] = "Custom attributes";

    // Glossary Controls
	strings['glossary.category.label'] = "Category";

	strings['glossary.form.description'] = "The following attributes can be defined in different languages. Please use the drop-down field in the top to change the language.<br/>Consider that the title must be defined in at least one language.";

	strings['glossary.edit.title'] = "Edit entry";
    strings['glossary.edit.save'] = "Save";
    strings['glossary.edit.description'] = "Edit the current dictionary entry.";

    strings['glossary.new.title'] = "New entry";
    strings['glossary.new.save'] = "Create";
    strings['glossary.new.create'] = "Create a new dictionary entry.";

    strings['glossary.multilanguage.non_attributes'] = "The following attributes can only be defined in the default language.";
    strings['glossary.multilanguage.copy_link_tt'] = "Please notice that all contents will be replace by the new contents.";
    strings['glossary.multilanguage.remove_origin_column'] = "Hide left column";
    strings['glossary.multilanguage.copy_link_title'] = "Copy all contents";

    strings['glossary.view.title'] = "Title";
    strings['glossary.view.attachments'] = "Relevant documents";
    strings['glossary.view.description'] = "Description";

    strings['glossary.mapper.type.document'] = "Documents";
    strings['glossary.mapper.type.org_unit'] = "Organizational Units";
    strings['glossary.mapper.type.it_system'] = "IT Systems";
    strings['glossary.mapper.type.activity'] = "Activities";
    strings['glossary.mapper.type.state'] = "Events";

    strings['glossary.mapper.loading_groups'] = "Loading dictionary groups...";
    strings['glossary.mapper.all_categories'] = "All chosen";
    strings['glossary.mapper.categories_chosen'] = "chosen";
    strings['glossary.mapper.select_all'] = "Select all";
    strings['glossary.mapper.select_none'] = "Select nothing";

    strings['propertyeditor.itsm.assignee.company'] = "Enterprise";
    strings['propertyeditor.itsm.assignee.organization'] = "Organization";
    strings['propertyeditor.itsm.assignee.group'] = "Group";

    strings['propertyeditor.itsm.location.region'] = "Region";
    strings['propertyeditor.itsm.location.sitegroup'] = "Site Group";
    strings['propertyeditor.itsm.location.site'] = "Site";

    strings['propertyeditor.itsm.servicecat.tier'] = "Tier {0}";

    strings['propertyeditor.itsm.productcat.name'] = "Name";
    strings['propertyeditor.itsm.productcat.model'] = "Model";

    strings['propertyeditor.itsm.variablemapping.header.variable'] = "Variable";
    strings['propertyeditor.itsm.variablemapping.header.input'] = "Input";
    strings['propertyeditor.itsm.variablemapping.header.output'] = "Output";

    strings['propertyeditor.itsm.variablemapping.error.title'] = "Too many variables";
    strings['propertyeditor.itsm.variablemapping.error.message'] = "Too many variables of type '{0}' are being used.<br/> The maximum is: {1}.";

    strings['propertyeditor.itsm.condition.add'] = "Add variable...";

    strings['glossary.new.languageswitch'] = "Language";

    strings["dialog.print.titlte"] = "PDF Export";
    strings["dialog.print.mask.load.defaults"] = "Loading default settings...";
    strings["dialog.print.mask.create.pdf_de"] = "Creating PDF...";
   	strings["dialog.print.button.create"] = "Create PDF";
   	strings["dialog.print.button.edit"] = "Edit";
   	strings["dialog.print.button.remove"] = "Remove";
   	strings["dialog.print.button.upload"] = "Add custom logo";
   	strings["dialog.print.button.configure"] = "Configure";
   	strings["dialog.print.save.defaults.label"] = "Save as defaults";
   	strings["dialog.print.orientation.landscape"] = "Landscape";
   	strings["dialog.print.orientation.portrait"] = "Portrait";
   	strings["dialog.print.orientation.label"] = "Diagram orientation";
   	strings["dialog.print.orientation.policy.label"] = "Orientate diagram";
   	strings["dialog.print.orientation.policy.auto"] = "Automatic";
   	strings["dialog.print.orientation.policy.always"] = "Always";
   	strings["dialog.print.orientation.policy.never"] = "Never";
   	strings["dialog.print.orientation.cw"] = "Clockwise";
   	strings["dialog.print.orientation.ccw"] = "Counterclockwise";
   	strings["dialog.print.paper.type.label"] = "Papertype"
   	strings["dialog.print.paper.type.a4"] = "DIN A4";
   	strings["dialog.print.paper.type.a3"] = "DIN A3";
   	strings["dialog.print.paper.type.us_letter"] = "US Letter";
   	strings["dialog.print.distribution.single"] = "Single page";
   	strings["dialog.print.distribution.multi"] = "Multiple pages";
   	strings["dialog.print.black.and.white"] = "Print in black and white";
   	strings["dialog.print.show.headers"] = "Show additional information";
   	strings["dialog.print.label"] = "Export one or more diagrams to PDF. You can change the general export settings as well as add additional attributes which should be printed along with the diagram.";
   	strings["dialog.print.label.download"] = "Your PDF is being created. The download will start automatically in a few moments.";
   	strings["dialog.print.label.more.models"] = "(and #{count} more)";
   	strings["dialog.print.header.general"] = "General";
   	strings["dialog.print.header.orientation"] = "Orientation";
   	strings["dialog.print.header.distribution"] = "Distribution";
   	strings["dialog.print.attribute.hint"] = "Add up to 3 attributes.";
   	strings["dialog.print.attribute.ownattribute"] = "Own attribute";
   	strings["dialog.print.attribute.lastauthor"] = "Last author";
   	strings["dialog.print.attribute.publishingdate"] = "Publishing date";
   	strings["dialog.print.attribute.publishingstatus"] = "Published";
   	strings["dialog.print.attribute.authors"] = "Authors";
   	strings["dialog.print.attribute.updatedate"] = "Last modified";
   	strings["dialog.print.attribute.modelpath"] = "Path";
   	strings["dialog.print.attribute.pagenumber"] = "Page number";
   	strings["dialog.print.attribute.printdate"] = "Print date";
   	strings["dialog.print.attribute.printedby"] = "Printed by";
   	strings["dialog.print.diagram.name"] = "Diagram name";
   	strings["dialog.print.error.no.models"] = "Please select at least one diagram or one folder.";

   	strings["dialog.upload.title"] = "Choose or upload a file/picture";
   	strings["dialog.upload.label.new.file"] = "Upload a new file/picture";
   	strings["dialog.upload.label.existing.file"] = "Choose a file/picture from your file storage";
   	strings["dialog.upload.label.external.file"] = "Link a file/picture on a web resource or network storage";
   	strings["dialog.upload.label.external.empty"] = "No list entries.";
   	strings["dialog.upload.label.choose.spacer"] = "Choose file/picture";
   	strings["dialog.upload.label.spacer.or"] = "Or";
   	strings["dialog.upload.label.description"] = "Please choose a file from your Siganvio file storage. As an alternative it you can define a URL that points to a webresource or a link to a file on a network storage.";
   	strings["dialog.upload.label.disabled"] = "The Signavio file storage is not available in your workspace.";
   	strings["dialog.upload.label.upload.disabled"] = "The upload of new files has been disabled for your workspace.";
   	strings["dialog.upload.label.max.size"] = "The maximum file size is "
   	strings["dialog.upload.error.file.too.big.title"] = "File too large";
   	strings["dialog.upload.error.file.too.big.description"] = "The Document/Picture is too big or would exceed the size of your Signavio file storage. Please delete unused files or contact the Signavio Support to order additional storage.";
   	strings["dialog.upload.error.file.too.big.single"] = "The file exceeds the maximum file size.";
   	strings["dialog.upload.error.file.too.big.all"] = "The file would exceed the storage capacity.";
   	strings["dialog.upload.error.no.folder.selected"] = "Please select a folder from your Signavio file storage where the document/picture will be stored.";
   	strings["dialog.upload.error.no.file.selected"] = "Please choose a file/picture you want to upload.";
   	strings["dialog.upload.error.no.image.selected"] = "Please chosse a file/picture form your Signavio file storage.";
   	strings["dialog.upload.action.upload"] = "Upload in progress...";

   	strings["component.folder.picker.empty"] = "Please choose a folder.";
   	strings["component.folder.picker.custom"] = "Choose another folder...";
   	strings["component.folder.picker.description"] = strings["component.folder.picker.empty"];
   	strings["component.folder.picker.head"] = "Folder selection";

   	strings["component.types.folder"] = "&raquo; Folder";
   	strings["component.types.favorits"] = "&raquo; Favorites";
   	strings["component.types.savedSearch"] = "&raquo; Saved Search";
   	strings["component.types.public"] = "Shared documents";
   	strings["component.types.private"] = "My documents";
   	strings["component.types.published"] = "Public documents";
   	strings["component.types.trash"] = "Trash";

    strings['language_bg'] = "Bulgarian";
    strings['language_cz'] = "Czech";
    strings['language_da'] = "Danish";
    strings['language_nl'] = "Dutch";
    strings['language_et'] = "Estonian";
    strings['language_fi'] = "Finnish";
    strings['language_fr'] = "French";
    strings['language_de'] = "German";
    strings['language_el'] = "Greek";
    strings['language_hu'] = "Hungarian";
    strings['language_ie'] = "Irish";
    strings['language_it'] = "Italian";
    strings['language_lv'] = "Latvian";
    strings['language_lt'] = "Lithunian";
    strings['language_mt'] = "Maltese";
    strings['language_pl'] = "Polish";
    strings['language_pt'] = "Portuguese";
    strings['language_ro'] = "Romanian";
    strings['language_sk'] = "Slovak";
    strings['language_sl'] = "Slovene";
    strings['language_es'] = "Spanish";
    strings['language_sv'] = "Swedish";
    strings['language_mx'] = "Spanish";
    strings['language_en'] = "English";
    strings['language_lb'] = "Luxembourgish";
    strings['language_af'] = "Afrikaans";

    strings['country_at'] = "Austria";
    strings['country_be'] = "Belgium";
    strings['country_bg'] = "Bulgaria";
    strings['country_ch'] = "Switzerland";
    strings['country_cz'] = "Czech";
    strings['country_dk'] = "Denmark";
    strings['country_gb'] = "Great Britain";
    strings['country_nl'] = "Netherlands";
    strings['country_ee'] = "Estonia";
    strings['country_fi'] = "Finland";
    strings['country_fr'] = "France";
    strings['country_de'] = "Germany";
    strings['country_gr'] = "Greece";
    strings['country_hu'] = "Hungary";
    strings['country_ie'] = "Ireland";
    strings['country_it'] = "Italy";
    strings['country_lv'] = "Latvia";
    strings['country_lt'] = "Lithuania";
    strings['country_mt'] = "Malta";
    strings['country_pl'] = "Poland";
    strings['country_pt'] = "Portugal";
    strings['country_ro'] = "Romänien";
    strings['country_sk'] = "Slovakia";
    strings['country_si'] = "Slovenia";
    strings['country_es'] = "Spain";
    strings['country_se'] = "Sweden";
    strings['country_en'] = "England";
    strings['country_mx'] = "Mexico";
    strings['country_us'] = "USA";
    strings['country_lu'] = "Luxembourg";
    strings['country_za'] = "South Africa";
    strings['country_br'] = "Brazil";
    strings['country_ca'] = "Canada";
    strings['country_cl'] = "Chile";
    strings['country_li'] = "Liechtenstein";
    strings['country_nz'] = "New Zealand";
    strings['coutnry_au'] = "Australia";

    //TODO
    strings['multilanguage.label'] = "Language";

	strings['multilanguage.language.bg'] = "Bulgarian";
	strings['multilanguage.language.cz'] = "Czech";
	strings['multilanguage.language.dk'] = "Danish";
	strings['multilanguage.language.nl'] = "Dutch";
	strings['multilanguage.language.ee'] = "Estonian";
	strings['multilanguage.language.fi'] = "Finnish";
	strings['multilanguage.language.fr'] = "French";
	strings['multilanguage.language.de'] = "German";
	strings['multilanguage.language.gr'] = "Greek";
	strings['multilanguage.language.hu'] = "Hungarian";
	strings['multilanguage.language.ie'] = "Irish";
	strings['multilanguage.language.it'] = "Italian";
	strings['multilanguage.language.lv'] = "Latvian";
	strings['multilanguage.language.lt'] = "Lithunian";
	strings['multilanguage.language.mt'] = "Maltese";
	strings['multilanguage.language.pl'] = "Polish";
	strings['multilanguage.language.pt'] = "Portuguese";
	strings['multilanguage.language.ro'] = "Romanian";
	strings['multilanguage.language.sk'] = "Slovak";
	strings['multilanguage.language.si'] = "Slovene";
	strings['multilanguage.language.es'] = "Spanish";
	strings['multilanguage.language.se'] = "Swedish";
	strings['multilanguage.language.mx'] = "Spanish";
	strings['multilanguage.language.en'] = "English";
	strings['multilanguage.language.lu'] = "Luxembourgish";
	strings['multilanguage.language.za'] = "Afrikaans";

	strings['multilanguage.country.at'] = "Austria";
	strings['multilanguage.country.be'] = "Belgium";
	strings['multilanguage.country.bg'] = "Bulgaria";
	strings['multilanguage.country.ch'] = "Switzerland";
	strings['multilanguage.country.cz'] = "Czech";
	strings['multilanguage.country.dk'] = "Denmark";
	strings['multilanguage.country.gb'] = "Great Britain";
	strings['multilanguage.country.nl'] = "Netherlands";
	strings['multilanguage.country.ee'] = "Estonia";
	strings['multilanguage.country.fi'] = "Finland";
	strings['multilanguage.country.fr'] = "France";
	strings['multilanguage.country.de'] = "Germany";
	strings['multilanguage.country.gr'] = "Greece";
	strings['multilanguage.country.hu'] = "Hungary";
	strings['multilanguage.country.ie'] = "Ireland";
	strings['multilanguage.country.it'] = "Italy";
	strings['multilanguage.country.lv'] = "Latvia";
	strings['multilanguage.country.lt'] = "Lithuania";
	strings['multilanguage.country.mt'] = "Malta";
	strings['multilanguage.country.pl'] = "Poland";
	strings['multilanguage.country.pt'] = "Portugal";
	strings['multilanguage.country.ro'] = "Romänien";
	strings['multilanguage.country.sk'] = "Slovakia";
	strings['multilanguage.country.si'] = "Slovenia";
	strings['multilanguage.country.es'] = "Spain";
	strings['multilanguage.country.se'] = "Sweden";
	strings['multilanguage.country.en'] = "England";
	strings['multilanguage.country.mx'] = "Mexico";
	strings['multilanguage.country.us'] = "USA";
	strings['multilanguage.country.lu'] = "Luxembourg";
	strings['multilanguage.country.za'] = "South Africa";
	strings['multilanguage.country.br'] = "Brazil";
	strings['multilanguage.country.ca'] = "Canada";
	strings['multilanguage.country.cl'] = "Chile";
	strings['multilanguage.country.li'] = "Liechtenstein";
	strings['multilanguage.country.nz'] = "New Zealand";
	strings['multilanguage.country.au'] = "Australia";

	// IKS
	strings['iks.title'] = "Risks and Controls";
	strings['iks.desc'] = "Define possible risks and the associated controls for the process element.";
	strings['iks.windowapply'] = "Apply";
	strings['iks.overlayhint'] = "Please click the item to edit risk and controls for that particular process element.";
	strings['iks.toolbarname'] = "Show risks and controls";
	strings['iks.toolbardesc'] = "Show risks and controls on process elements";
	strings['iks.risk'] = "Risk";
	strings['iks.risks'] = "Risks";
	strings['iks.control'] = "Control";
	strings['iks.controls'] = "Controls";
	strings['iks.newentry'] = "Please click here to create a{0}...";
	strings['iks.newentryrisk'] = " new risk entry ";
	strings['iks.newentrycontrol'] = " a new control entry ";
	strings['iks.addcontrols'] = "Add Controls";
	strings['iks.removerisk'] = "Remove this risk";
	strings['iks.removecontrol'] = "Remove this control";
	strings['iks.deletethistpl'] = "Delete this ";
	strings['iks.deletethisrisk'] = "risk and all associated controls?";
	strings['iks.deletethiscontrol'] = "control?";
	strings['iks.yes'] = "Yes";
	strings['iks.no'] = "No";
	strings['iks.globalrisks'] = "Global risks";
	
	// NestableEditorGridPanel
	strings['negp.nestedfield.emptytext'] = "Add content";
	strings['negp.delete'] = "Delete?";
	strings['negp.yes'] = "yes";
	strings['negp.no'] = "no";

	strings['propertyeditor.npb.title'] = "Mandatory attributes for the National Process Library";
	strings['propertyeditor.npb.topics.title'] = "Choose topics";
	strings['propertyeditor.npb.topics.desc'] = "Choose one or more predefined topics or enter a completely new topic.";
	strings['propertyeditor.npb.topics.predefined'] = "predefined Topics";
	strings['propertyeditor.npb.topics.other'] = "other";
	strings['propertyeditor.npb.render_msg'] = " of 9 attributes set";
    strings['propertyeditor.npb.invalid_leika'] = "The entered value is no valid LeiKa key.";
    strings['propertyeditor.npb.no_leika'] = "No LeiKa entry.";
    strings['propertyeditor.npb.searching'] = "Searching...";

	/**
	 * SPANISH TRANSLATION
	 * First translation into Spanish: 2010.05.31
	 * Translator: idroAVILA
	 * @translationchecker fernando.candia 18/08/2010
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_es = "Agregar";
	strings.btnopen_es = "Abrir";
	strings.btnremove_es = "Quitar";
	strings.btnedit_es = "Editar";
	strings.btnreset_es = "Reinicializar";
	strings.moveup_es = "Mover arriba";
	strings.movedown_es = "Mover abajo";
	strings.url_es = "URL";
	strings.label_es = "Etiqueta";
	
	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_es = "'#{0}' crear como #{1}";
	strings.createglossarynew_es = "Crear nuevo";
	
	// GLOSSARY CATEGORIES
	strings.document_es = "Documentos";
	strings.org_unit_es = "Unidades Organizacionales";
	strings.it_system_es = "Sistemas de TI";
	strings.activity_es = "Actividades";
	strings.state_es = "Eventos";
	
	// TIME AND DATE
	strings.year_es = "Año";
	strings.years_es = "Años";
	strings.month_es = "Mes";
	strings.months_es = "Meses";
	strings.day_es = "Día";
	strings.days_es = "Días";
	strings.hour_es = "Hora";
	strings.hours_es = "Horas";
	strings.minute_es = "Minuto";
	strings.minutes_es = "Minutos";
	strings.second_es = "Segundo";
	strings.seconds_es = "Segundos";
	strings.msecond_es = "Milisegundo";
	strings.mseconds_es = "Milisegundos";
	
	// FEEDBACK WINDOW
	strings["views.feedbacktitleenterprise_es"] = "Soporte Signavio";
	strings["views.feedbacktitle_es"] = "Soporte";
	strings["views.feedbackentersubject_es"] = "Por favor ingrese un tema que describa brevemente el problema o la pregunta.";
	strings["views.feedbackenterdescription_es"] = "Por favor describa su problema o pregunta tan detalladamente como sea posible.";
	strings["views.feedbackpmsg_es"] = "Descripción/Mensaje";
	strings["views.feedbackpempty_es"] = "* Por favor describa su petición. Por favor proporcione información tan detallada como sea posible.\n* Para reporte de errores, por favor enliste los pasos de cómo se produjo el error y el mensaje que esperaba.";
	strings["views.feedbackpsubject_es"] = "Tema";
	strings["views.feedbackpbrowser_es"] = "Información acerca de su navegador y ambiente";
	strings["views.feedbackpbrowserdesc_es"] = "Esta información ha sido auto-detectada de su navegador. Puede ser útil en caso de que encuentre un error asociado con el comportamiento del navegador (específicamente).";
	strings["views.feedbackclosetitle_es"] = "Cerrar";
	strings["views.feedbackfailure_es"] = "Falla";
	strings["views.feedbackfailuremsg_es"] = "El mensaje no pudo ser enviado";
	strings["views.feedbacksuccess_es"] = "Éxito";
	strings["views.feedbacksuccessmsg_es"] = "¡Gracias por su retroalimentación!";
	strings["views.feedbacksending_es"] = "Enviando mensaje...";
	strings["views.sendfeedback_es"] = "Enviar Mensaje";
	strings["views.feedbackpattach_es"] = "Adjuntar diagrama actual";
	strings["views.feedbackpattachdesc_es"] = "Esta información puede ser útil para propósitos de depuración. Si su diagrama contiene algunos datos delicados, elimínelos antes de enviar o desmarque su comportamiento.";
	strings["views.feedbackmissingheader_es"] = "Sin Asunto";
	strings["views.feedbackmissingheadermsg_es"] = "Por favor defina un Asunto.";
	strings["views.feedbackmissingbody_es"] = "No hay mensaje";
	strings["views.feedbackmissingbodymsg_es"] = "Por favor escriba un mensaje.";
	strings["views.feedbackerrorlength_es"] = "La descripción es demasiado corta. Por favor teclee al menos 40 letras.";
	strings["views.feedbackerrorlengthtitle_es"] = "El mensaje es demasiado corto";
	strings["views.feedbacksignavio_es"] = "¿Ha tenido algún problema o encontrado algún error al usar Signavio Process Editor? Si es así, por favor utilice el formulario de servicio al cliente para ponerse en contacto con Servicio" +
										"al Cliente de Signavio directamente. Por favor, note que su petición será atendida en un plazo de 1-2 días hábiles." +
										"Responderemos por correo. Toda la información se transfiere sin encriptación.";
	strings["views.feedbackenterprise_es"] = "¿Ha tenido algún problema o encontrado algún error al usar Signavio Process Editor? Si es así, por favor utilice el formulario de servicio al cliente para ponerse en contacto con su departamento de Servicio" +
										  "al cliente o con su administrador. Toda la información será transmitida sin encriptación.";
	
	// PDF EXPORT WINDOW
	strings["views.offertitle_es"] = "PDF (sólo diagrama)";
	strings["views.offertitledesc_es"] = "Usted puede imprimir su diagrama en varias páginas. Por favor seleccione el diseño que desee para su PDF.";
	strings["views.optionwindowtitle_es"] = "Exportar PDF (sólo diagrama)";
	strings["views.buttontitle_es"] = "Generar PDF";
	strings["views.closetitle_es"] = "Cancelar";
	strings["views.fittopage_es"] = "Ajustar a una página";
	strings["views.clipallsides_es"] = "Impresión Continua (2 dimensiones)";
	strings["views.clipbottom_es"] = "Impresión Continua (vertical)";
	strings["views.clipright_es"] = "Impresión Continua(horizontal)";
	strings["views.landscape_es"] = "Paisaje";
	strings["views.portrait_es"] = "Retrato";
	strings["views.defaultname_es"] = "Exportar";
	strings["views.branding_es"] = "Quitar logos de Signavio";
	strings["views.premiumonly_es"] = "Esta función sólo está disponible en la Edición Profesional.";
	strings["views.waiting_es"] = "Se generará la Documentación del Proceso.<br/>Esto puede tomar algún tiempo...";
	strings["views.resetview_es"] = "Original";
	strings["views.windowdescription_es"] = "Por favor seleccione una Vista para la Exportación";	

	strings["panel.businessrule_es"] = "Regla de Negocio";
	strings["panel.static_es"] = "Estático";
	strings["panel.dynamic_es"] = "Dinámico";
	strings["panel.operation_es"] = "Operación";
	strings["panel.add_es"] = "añadir";
	strings["panel.remove_es"] = "eliminar";
	
	strings["panel.no_description_es"] = "Sin descripción";
	strings["panel.no_performer_es"] = "No hay Ejecutante definido.";
	strings["panel.no_users_es"] = "No hay Usuarios disponibles.";
	strings["panel.no_free_userselection_es"] = "Selección de usuarios sin restricción";
	strings["panel.label_free_userselection_es"] = "(Selección de usuarios sin restricción)";
	strings["panel.no_parallel_title_es"] = "Añadir a un grupo";
	strings["panel.no_parallel_description_es"] = "Para el elemento actual el tipo de repetición está fijado como paralelo o secuencial, esto significa que varios usuarios pueden realizar la tarea. Para simplificar esto, ¿desea utilizar todos los miembros del grupo seleccionado en vez del grupo en sí mismo?";
	strings["panel.no_parallel_no_user_es"] = "El grupo actual no contiene miembros.";
	strings["panel.no_defined_role_label_es"] = "Pre-selección";
	strings["panel.no_defined_role_single_user_es"] = "Un solo usuario";
	strings["panel.no_defined_role_role_member_es"] = "Miembros de grupo/rol";
	strings["panel.no_defined_role_group_es"] = "Grupos/Roles";
	strings["panel.label_free_userselection_es"] = "(Selección de usuario libre)";	
	
	strings["wizard.nextbtnlabel_es"] = "Siguiente >";
	strings["wizard.previousbtnlabel_es"] = "< Anterior";

	strings["richtext.title.undo_es"] = "Deshacer (Ctrl+Z)";
    strings["richtext.text.undo_es"] = "Deshace los últimos cambios.";
    strings["richtext.title.redo_es"] = "Rehacer (Shift+Ctrl+Z)";
    strings["richtext.text.redo_es"] = "Rehace los últimos cambios.";   
    strings["richtext.title.bold_es"] = "Negrita (Ctrl+B)";
    strings["richtext.text.bold_es"] = "Poner texto en negrita.";
    strings["richtext.title.italic_es"] = "Itálica (Ctrl+I)";
    strings["richtext.text.italic_es"] = "Poner texto en itálica.";
    strings["richtext.title.underline_es"] = "Subrayar (Ctrl+U)";
    strings["richtext.text.underline_es"] = "Subraya el texto seleccionado.";
    strings["richtext.title.fontselect_es"] = "Fuente";
    strings["richtext.text.fontselect_es"] = "Cambia la fuente del texto seleccionado.";
    strings["richtext.title.fontsizeselect_es"] = "Tamaño de Fuente";
    strings["richtext.text.fontsizeselect_es"] = "Cambia el tamaño de fuente del texto seleccionado.";   
    strings["richtext.title.h1_es"] = "Título";
    strings["richtext.text.h1_es"] = "Insertar un título.";	
    strings["richtext.title.h2_es"] = "Subtítulo";
    strings["richtext.text.h2_es"] = "Inserta un subtítulo.";	
    strings["richtext.title.h3_es"] = "Sección de Título";
    strings["richtext.text.h3_es"] = "Inserta una nueva sección de título.";
    strings["richtext.title.inserthorizontalrule_es"] = "Regla Horizontal";
    strings["richtext.text.inserthorizontalrule_es"] = "Inserta una regla horizontal.";  
    strings["richtext.title.color_es"] = "Color de Fuente";
    strings["richtext.text.color_es"] = "Cambia el color del texto seleccionado.";  
    strings["richtext.title.markupcolor_es"] = "Color del Texto Subrayado";
    strings["richtext.text.markupcolor_es"] = "Cambia el color de fondo del texto seleccionado";   
    strings["richtext.title.justifyleft_es"] = "Alinear Texto a la Izquierda";
    strings["richtext.text.justifyleft_es"] = "Alinea el Texto a la Izquierda.";    
    strings["richtext.title.justifycenter_es"] = "Centrar Texto";
    strings["richtext.text.justifycenter_es"] = "Centrar texto en el editor.";	
    strings["richtext.title.justifyright_es"] = "Alinear texto a la Derecha";
    strings["richtext.text.justifyright_es"] = "Alinea el texto a la derecha.";
    strings["richtext.title.indent_es"] = "Sangría (Tab)";
    strings["richtext.text.indent_es"] = "Indentar Texto.";	
    strings["richtext.title.outdent_es"] = "Anular Sangría (Shift+Tab)";
    strings["richtext.text.outdent_es"] = "Anular la Sangría del Texto.";
    strings["richtext.title.createlink_es"] = "Hipervínculo";
    strings["richtext.text.createlink_es"] = "Convierte el texto seleccionado en un hipervínculo.";   
    strings["richtext.title.unlink_es"] = "Quitar Hipervínculo";
    strings["richtext.text.unlink_es"] = "Remueve el Hipervínculo de la selección.";	
    strings["richtext.title.insertorderedlist_es"] = "Lista Numerada";
    strings["richtext.text.insertorderedlist_es"] = "Comienza una lista numerada.";	
    strings["richtext.title.insertunorderedlist_es"] = "Lista de Viñetas";
    strings["richtext.text.insertunorderedlist_es"] = "Comienza una lista de viñetas.";	
    strings["richtext.title.removeformat_es"] = "Quitar Formato";
    strings["richtext.text.removeformat_es"] = "Quita todo el formato aplicado a la selección.";    
    strings['richtext.colormenu.defaultcolor_es'] = 'Automático';
    strings['richtext.stub.more_es'] = 'más';
    strings['richtext.stub.less_es'] = 'menos';
    strings['richtext.stub.openprint_es'] = 'Abrir vista de impresión';
    
    // COMMED TRANSLATIONS
	strings['commed.expression.otherwise_es'] = 'De otra manera';
	strings['commed.expression.manual_es'] = 'Manual de Acciones de Usuario';
	strings['commed.expression.automaticrule_es'] = 'Regla Automática de JavaScript';
	strings['commed.expression.jsrule_es'] = 'Regla de JavaScript';
	strings['commed.expression.standarderror_es'] = 'Error estándar';
	strings['commed.expression.exception_es'] = 'Exepción';
	strings['commed.expression.exceptions_es'] = 'Exepciones';
	strings['commed.rolemapping.loadingroles_es'] = 'Cargando Reglas.';
	strings['commed.servicecall.and_es'] = 'y';
	strings['commed.servicecall.aredefined_es'] = 'Se definen.';
	strings['commed.servicecall.loadingformulars_es'] = 'Cargando formulario.';
	strings['commed.servicecall.loadingmeasures_es'] = 'Cargar parámetros...';
	strings['commed.servicecall.formulars_es'] = 'Formulario';
	strings['commed.servicecall.performingsearch_es'] = 'Buscar...';
	strings['commed.servicecall.nofound_es'] = 'Parámetro no encontrado.';
	strings['commed.servicecall.nomeasuresselected_es'] = 'Ningún parámetro seleccionado por el momento.';
	strings['commed.servicecall.pleaseselect_es'] = 'Por favor, seleccione un parámetro en el lado derecho para añadir a la selección.';
	strings['commed.servicecall.measure_es'] = 'Parámetro';
	strings['commed.servicecall.nowfv_es'] = 'No hay WFV definido.';
	strings['commed.servicecall.loadinginputs_es'] = 'Cargando entradas.';
	strings['commed.servicecall.noinputs_es'] = 'No entradas.';
	strings['commed.servicecall.loadingoutputs_es'] = 'Cargando salidas.';
	strings['commed.servicecall.nooutputs_es'] = 'No salidas.';
	strings['commed.servicecall.loadingservice_es'] = 'Cargando servicio.';
	strings['commed.servicecall.selectservice_es'] = 'Por favor, seleccione un servicio.';
	strings['commed.servicecall.remove_es'] = 'Remover';
    strings['commed.servicecall.parameteralert_es'] = "Para este atributo tiene que definir un 'subproceso de referencia'-. Por favor, pulse el botón más para vincular un subproceso";
	strings['commed.servicecall.selectboandservice_es'] = 'Por favor seleccione un servicio y un BO.';
	strings['commed.servicecall.noinputsinsub_es'] = 'No hay entradas definidas en el subproceso.';
	strings['commed.servicecall.nooutputsinsub_es'] = 'No hay Salidas definidas en el subproceso.';
	strings['commed.servicecall.noserviceinsub_es'] = 'El subproceso referenciado no tiene servicios definidos.';
    
	strings['glossary.mapper.type.document_es'] = "Documentos";
    strings['glossary.mapper.type.org_unit_es'] = "Unidades Organizacionales";
    strings['glossary.mapper.type.it_system_es'] = "Sistemas de TI";
    strings['glossary.mapper.type.activity_es'] = "Actividades";
    strings['glossary.mapper.type.state_es'] = "Eventos";

    strings['glossary.form.description_es'] = "The following attributes can be defined in different languages. Please use the drop-down field in the top to change the language.<br/>Consider that the title must be defined in at least one language.";

    strings['glossary.edit.title_es'] = "Editar entrada";
    strings['glossary.edit.save_es'] = "Guardar";
    strings['glossary.edit.description_es'] = "Editar la entrada de diccionario actual.";

    strings['glossary.new.title_es'] = "Nueva entrada";
    strings['glossary.new.save_es'] = "Crear";
    strings['glossary.new.create_es'] = "Crear una nueva entrada de diccionario.";

	strings['glossary.multilanguage.non_attributes_es'] = "The following attributes can only be defined in the default language.";
    strings['glossary.multilanguage.copy_link_tt_es'] = "Please notice that all contents will be replace by the new contents.";
    strings['glossary.multilanguage.remove_origin_column_es'] = "Hide left column";
    strings['glossary.multilanguage.copy_link_title_es'] = "Copy all contents";

    strings['glossary.view.title_es'] = "Título";
    strings['glossary.view.attachments_es'] = "Documentos Anexados";
    strings['glossary.view.description_es'] = "Descripción";
	
	/**
	 * FRENCH TRANSLATION
	 * First translation into French: -
	 * Translator: Gerjan Grootenboer
	 * @translationchecker - 
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_fr = "Ajouter";
	strings.btnopen_fr = "Ouvrir";
	strings.btnremove_fr = "Supprimer";
	strings.btnedit_fr = "Éditer";
	strings.btnreset_fr = "Réinitialiser";
	strings.btnclose_fr = "Fermer";
	strings.btnsave_fr = "Enregistrer";
	strings.moveup_fr = "Déplacer vers le haut";
	strings.movedown_fr = "Déplacer vers le bas";
	strings.url_fr = "URL";
	strings.label_fr = "Label";
	strings.year_fr = "Année";
	strings.years_fr = "Années";
	strings.month_fr = "Mois";
	strings.months_fr = "Mois";
	strings.day_fr = "Jour";
	strings.days_fr = "Jours";
	strings.hour_fr = "Heure";
	strings.hours_fr = "Heures";
	strings.minute_fr = "Minute";
	strings.minutes_fr = "Minutes";
	strings.second_fr = "Seconde";
	strings.seconds_fr = "Secondes";
	strings.msecond_fr = "Milliseconde";
	strings.mseconds_fr = "Millisecondes";
	
	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_fr = "'#{0}' créer en tant que #{1}";
	strings.createglossarynew_fr = "Créer un nouveau";
	
	// GLOSSARY CATEGORIES
	strings.documen_fr = "Documents";
	strings.org_unit_fr = "Unités d'organisation";
	strings.it_system_fr = "Systèmes IT";
	strings.activity_fr = "Activités";
	strings.state_fr = "Événements";
	
	// FEEDBACK WINDOW
	strings["views.feedbacktitleenterprise_fr"] = "Support";
	strings["views.feedbacktitle_fr"] = "Support de Signavio";
	strings["views.feedbacktitleenterprise_fr"] = "Envoyer une demande de support";
	strings["views.feedbacktitle_fr"] = "Envoyer une demande de support à Signavio";
	strings["views.feedbackentersubject_fr"] = "Veuillez entrer un sujet qui décrit brièvement le problème ou la question.";
	strings["views.feedbackenterdescription_fr"] = "Veuillez décrire votre problème ou votre question en détail";
	strings["views.feedbackpmsg_fr"] = "Description détaillée de l'erreur";
	strings["views.feedbackpempty_fr"] = "* Veuillez décrire votre demande et fournir des informations aussi détaillées que possible.\n* Pour les rapports de bugs, veuillez lister les étapes effectuées pour que nous puissions reproduire le problème et précisez également le résultat escompté.";
	strings["views.feedbackpsubject_fr"] = "Problème avec le Signavio Process Editor";
	strings["views.feedbackpbrowser_fr"] = "Informations sur votre navigateur et sur l'environnement";
	strings["views.feedbackpbrowserdesc_fr"] = "Cette information a été détectée automatiquement par votre navigateur. Elle peut être utile si vous avez rencontré un bug associé au comportement spécifique du navigateur.";
	strings["views.feedbackclosetitle_fr"] = "Fermer";
	strings["views.feedbackfailure_fr"] = "Échec";
	strings["views.feedbackfailuremsg_fr"] = "Le message n'a pas pu être envoyé!";
	strings["views.feedbacksuccess_fr"] = "Réussite";
	strings["views.feedbacksuccessmsg_fr"] = "Merci pour votre feedback!";
	strings["views.feedbacksending_fr"] = "Envoi du message en cours...";
	strings["views.sendfeedback_fr"] = "Envoyer une demande de soutien";
	strings["views.feedbackpattach_fr"] = "Attacher le diagramme actuel";
	strings["views.feedbackpattachdesc_fr"] = "Cette information peut être utile pour le réparer le bug. Si votre diagramme contient des données sensibles, retirerez-les avant d'envoyer votre demande ou décochez cette option.";
	strings["views.feedbackreceiver_fr"] = "Destinataire";
	strings["views.feedbackreceiversignavio_fr"] = "Support de Signavio ([mail])";
	strings["views.feedbackreceiverenterprise_fr"] = "Votre support ([mail])";
	strings["views.feedbackmissingheader_fr"] = "Pas de sujet";
	strings["views.feedbackmissingheadermsg_fr"] = "Veuillez définir un sujet.";
	strings["views.feedbackmissingbody_fr"] = "Pas de message";
	strings["views.feedbackmissingbodymsg_fr"] = "Veuillez écrire un message.";
	strings["views.feedbackerrorlength_fr"] = "La description est trop courte. Veuillez entrer au moins 40 caractères.";
	strings["views.feedbackerrorlengthtitle_fr"] = "Le message est trop court";
	strings["views.feedbacksignavio_fr"] = "Vous avez un problème avec l'utilisation du Signavio Process Editor ou vous avez trouvé une erreur? Dans ce cas, veuillez utiliser le formulaire de support pour contacter directement le support de Signavio. Le traitement de votre demande peut prendre environ 1-2 jours ouvrables. Nous vous répondrons par e-mail. Toutes les informations transférées sont non-cryptées.";
	strings["views.feedbackenterprise_fr"] = "Vous avez un problème avec l'utilisation du Signavio Process Editor ou vous avez trouvé une erreur? Dans ce cas, veuillez utiliser le formulaire d'aide pour contacter directement le support ou l'administrateur. Toutes les informations transférées ne sont pas cryptées.";	
	
	// PDF EXPORT WINDOW
	strings["views.offertitle_fr"] = "PDF (diagramme simple)";
	strings["views.offertitledesc_fr"] = "Vous pouvez imprimer votre diagramme sur plusieurs pages. Veuillez sélectionner la mise en page souhaitée lors de l'exportation en PDF.";
	strings["views.optionwindowtitle_fr"] = "Exportation en PDF (Diagramme simple)";
	strings["views.buttontitle_fr"] = "Générer le PDF";
	strings["views.closetitle_fr"] = "Annuler";
	strings["views.fittopage_fr"] = "Ajuster à une seule page";
	strings["views.clipallsides_fr"] = "Impression en continu (2 dimensions)";
	strings["views.clipbottom_fr"] = "Impression en continu (vertical)";
	strings["views.clipright_fr"] = "Impression en continu (horizontal)";
	strings["views.landscape_fr"] = "Paysage";
	strings["views.portrait_fr"] = "Portrait";
	strings["views.defaultname_fr"] = "Exporter";
	strings["views.branding_fr"] = "Supprimer les logos de Signavio";
	strings["views.premiumonly_fr"] = "Cette fonctionnalité est uniquement disponible dans la version Professionnel Edition.";
	strings["views.waiting_fr"] = "Le processus de documentation sera créée.<br/>Cela pourrait prendre un peu de temps...";
	strings["views.resetview_fr"] = "Original";
	strings["views.windowdescription_fr"] = "Veuillez sélectionner une vue pour l'exportation:";
	strings["panel.businessrule_fr"] = "Règle d'affaire";
	strings["panel.static_fr"] = "Statique";
	strings["panel.dynamic_fr"] = "Dynamique";
	strings["panel.operation_fr"] = "Opération";
	strings["panel.add_fr"] = "Ajouter";
	strings["panel.remove_fr"] = "Supprimer";
	strings["panel.no_description_fr"] = "Pas de description";
	strings["panel.no_performer_fr"] = "Aucun exécuteur défini.";
	strings["panel.no_users_fr"] = "Aucun utilisateur disponible.";
	strings["panel.no_free_userselection_fr"] = "Sélection de l'utilisateur sans restriction";
	strings["panel.no_parallel_title_fr"] = "Ajouter un groupe";
	strings["panel.no_parallel_description_fr"] = "Pour l'élément courant, le type de boucle est fixé soit en parallèle ou en série, cela signifie que plusieurs utilisateurs peuvent effectuer la tâche. Pour simplifier ceci, voulez-vous utiliser directement tous les membres du groupe sélectionné au lieu du groupe lui-même?";
	strings["panel.no_parallel_no_user_fr"] = "Le groupe actuel n'a pas de membres.";
	strings["panel.no_defined_role_label_fr"] = "Pré-sélection";
	strings["panel.no_defined_role_single_user_fr"] = "Utilisateur unique";
	strings["panel.no_defined_role_role_member_fr"] = "Groupe/rôle des membres";
	strings["panel.no_defined_role_group_fr"] = "Groupes/rôles";
	strings["panel.label_free_userselection_fr"] = "(Sélection par l'utilisateur sans restriction)";
	
	strings["wizard.nextbtnlabel_fr"] = "Suivant >";
	strings["wizard.previousbtnlabel_fr"] = "< Précédant";
    
	strings["richtext.title.undo_fr"] = "Annuler (Ctrl+Z)";
    strings["richtext.text.undo_fr"] = "Annule les dernières modifications.";
    strings["richtext.title.redo_fr"] = "Restaurer (Maj+Ctrl+Z)";
    strings["richtext.text.redo_fr"] = "Restaurer les dernières modifications.";
    strings["richtext.title.bold_fr"] = "Gras (Ctrl+B)";
    strings["richtext.text.bold_fr"] = "Mettre le texte sélectionné en gras.";
    strings["richtext.title.italic_fr"] = "Italique (Ctrl+I)";
    strings["richtext.text.italic_fr"] = "Mettre le texte sélectionné en italique.";
    strings["richtext.title.underline_fr"] = "Souligné (Ctrl+U)";
    strings["richtext.text.underline_fr"] = "Souligner le texte sélectionné.";
    strings["richtext.title.fontselect_fr"] = "Police";
    strings["richtext.text.fontselect_fr"] = "Modifier la police du texte sélectionné.";
    strings["richtext.title.fontsizeselect_fr"] = "Taille de la police";
    strings["richtext.text.fontsizeselect_fr"] = "Changer la police du texte sélectionné.";
    strings["richtext.title.h1_fr"] = "Titre";
    strings["richtext.text.h1_fr"] = "Insérer un titre.";
    strings["richtext.title.h2_fr"] = "Sous titre";
    strings["richtext.text.h2_fr"] = "Insérer un sous-titre.";
    strings["richtext.title.h3_fr"] = "Titre de la section";
    strings["richtext.text.h3_fr"] = "Insérer un titre pour une nouvelle section.";   
    strings["richtext.title.inserthorizontalrule_fr"] = "Règle horizontale";
    strings["richtext.text.inserthorizontalrule_fr"] = "Insérer une règle horizontale.";
    strings["richtext.title.color_fr"] = "Couleur de la police";
    strings["richtext.text.color_fr"] = "Changer la couleur du texte sélectionné.";
    strings["richtext.title.markupcolor_fr"] = "Couleur de surbrillance du texte";
    strings["richtext.text.markupcolor_fr"] = "Changer la couleur de fond du texte sélectionné.";
    strings["richtext.title.justifyleft_fr"] = "Aligner le texte sur la gauche";
    strings["richtext.text.justifyleft_fr"] = "Aligner le texte à gauche.";
    strings["richtext.title.justifycenter_fr"] = "Texte centré";
    strings["richtext.text.justifycenter_fr"] = "Centrer le texte dans l'éditeur";
    strings["richtext.title.justifyright_fr"] = "Aligner le titre à droite";
    strings["richtext.text.justifyright_fr"] = "Aligner le texte à droite.";
    strings["richtext.title.indent_fr"] = "Retrait (Tab)";
    strings["richtext.text.indent_fr"] = "Retrait du texte.";
    strings["richtext.title.outdent_fr"] = "Diminuer le retrait (Shift+Tab)";
    strings["richtext.text.outdent_fr"] = "Diminuer le retrait du texte.";
    strings["richtext.title.createlink_fr"] = "Lien hypertexte";
    strings["richtext.text.createlink_fr"] = "Mettre le texte sélectionné en lien hypertexte.";
    strings["richtext.title.unlink_fr"] = "Supprimer le lien hypertexte";
    strings["richtext.text.unlink_fr"] = "Supprimer le lien hypertexte de la sélection.";
    strings["richtext.title.insertorderedlist_fr"] = "Liste (numérotée)";
    strings["richtext.text.insertorderedlist_fr"] = "Démarrer une liste numérotée.";
    strings["richtext.title.insertunorderedlist_fr"] = "Liste à puces";
    strings["richtext.text.insertunorderedlist_fr"] = "Démarrer une liste à puces.";
    strings["richtext.title.removeformat_fr"] = "Retirer le format";
    strings["richtext.text.removeformat_fr"] = "Supprimer le formatage appliqué à la sélection.";  
    strings['richtext.colormenu.defaultcolor_fr'] = 'Automatique';
    strings['richtext.stub.more_fr'] = 'Plus';
    strings['richtext.stub.less_fr'] = 'Moins';
    strings['richtext.stub.openprint_fr'] = 'Aperçu avant impression';
    
    // COMMED TRANSLATIONS
    strings['commed.expression.otherwise_fr'] = 'Défaut';
    strings['commed.expression.manual_fr'] = 'Action manuelle de l\'utilisateur';
    strings['commed.expression.automaticrule_fr'] = 'Règle automatique pour JavaScript'; 
    strings['commed.expression.jsrule_fr'] = 'Règle JavaScript';
    strings['commed.expression.standarderror_fr'] = 'Erreur standard';
    strings['commed.expression.exception_fr'] = 'Exception';
    strings['commed.expression.exceptions_fr'] = 'Exceptions';
    strings['commed.rolemapping.loadingroles_fr'] = 'Chargement des rôles';
    strings['commed.servicecall.and_fr'] = 'et';
    strings['commed.servicecall.aredefined_fr'] = 'sont définis.';
    strings['commed.servicecall.loadingformulars_fr'] = 'Chargement du formulaire.';
    strings['commed.servicecall.loadingmeasures_fr'] = 'Mesures en cours...';
    strings['commed.servicecall.formulars_fr'] = 'Formulaires';
    strings['commed.servicecall.performingsearch_fr'] = 'Recherche en cours...';
    strings['commed.servicecall.nofound_fr'] = 'Aucune mesure trouvée.';
    strings['commed.servicecall.nomeasuresselected_fr'] = 'Aucune mesure sélectionnée jusqu\'ici.';
    strings['commed.servicecall.pleaseselect_fr'] = 'S\'il vous plaît choisir une mesure sur le côté droit pour l\'ajouter à votre sélection.';
    strings['commed.servicecall.measure_fr'] = 'Mesure';
    strings['commed.servicecall.nowfv_fr'] = 'Pas de WFV défini.';
    strings['commed.servicecall.loadinginputs_fr'] = 'Chargement des entrées.';
    strings['commed.servicecall.noinputs_fr'] = 'Pas d\'entrées.';
    strings['commed.servicecall.loadingoutputs_fr'] = 'Chargement des sorties.';
    strings['commed.servicecall.nooutputs_fr'] = 'Pas de sorties.';
    strings['commed.servicecall.loadingservice_fr'] = 'Chargement du service';
    strings['commed.servicecall.selectservice_fr'] = 'Sélectionnez s\'il vous plait un service.';
    strings['commed.servicecall.remove_fr'] = 'Supprimer';
    strings['commed.servicecall.parameteralert_fr'] = "Pour cette attribut, vous devez définir un «Sous-processus de référence». Veuillez appuyer sur le bouton plus pour lier un sous-processus";
    strings['commed.servicecall.selectboandservice_fr'] = 'Veuillez sélectionner un service et un BO.';
    strings['commed.servicecall.noinputsinsub_fr'] = 'Aucune entrée définie dans le sous-processus';
    strings['commed.servicecall.nooutputsinsub_fr'] = 'Pas de sorties définies dans le sous-processus';
    strings['commed.servicecall.noserviceinsub_fr'] = 'Le sous-processus référencé n\'a pas de services définis';

	
    
    strings['attribute.mapper.loading_fr'] = "Chargement en cours";
    strings['attribute.mapper.stencilsets_fr'] = "types de diagrammes";
    strings['attribute.mapper.deselected_fr'] = "#{count} éléments(s) exclus";
    strings['attribute.mapper.attributes_selected_fr'] = "#{count} différent(s) attribut(s) sélectionné(s)";
    strings['attribute.mapper.attributes_deselected_fr'] = "#{count} attribut(s) exclus";
    strings['attribute.mapper.selected_fr'] = "#{count} élément(s) sélectionné(s)";
    strings['attribute.mapper.no_attributes_fr'] = "Il n'y a pas d'attributs disponibles pour cette langage de modélisation.";
    strings['attribute.mapper.no_selection_fr'] = "Aucun";
    strings['attribute.mapper.exclusion_active_fr'] = "Ensemble de restrictions";
    strings['attribute.mapper.excluion_inactive_fr'] = "Pas d'ensemble de restrictions";
    strings['attribute.mapper.list_fr'] = "Liste";
    
    strings['attribute.mapper.selected_fr'] = "#{count} sélectionné";
    
    strings['attribute.mapper.untitled_group_fr'] = "Goupe sans titre";
    
    strings['attribute.mapper.config.all_attributes_fr'] = "Tous les attributs";
    strings['attribute.mapper.config.own_attributes_fr'] = "Attributs personnalisés";
    strings['attribute.mapper.config.select_attributes_fr'] = "Sélectionner des attributs";
    strings['attribute.mapper.config.all_elements_fr'] = "Tous les éléments";
    strings['attribute.mapper.config.flow_elements_fr'] = "Seulement les éléments du flux";
    strings['attribute.mapper.config.activities_fr'] = "Seulement les activités";
    strings['attribute.mapper.config.select_elements_fr'] = "Sélectionner des éléments";
    
    strings['attribute.mapper.config.name_fr'] = "Nom";
    strings['attribute.mapper.config.description_fr'] = "Description";
    
    strings['attribute.mapper.config.hide_empty_attributes_fr'] = "Cacher les attributs sans valeur";
    strings['attribute.mapper.config.show_attribute_label_fr'] = "Faire apparaître les labels";
    strings['attribute.mapper.config.separate_labels_fr'] = "Séparer les attributs par";
    strings['attribute.mapper.config.separator_comma_fr'] = "Virgule";
    strings['attribute.mapper.config.separator_space_fr'] = "Espace";
    strings['attribute.mapper.config.separator_linebreak_fr'] = "Saut de ligne";
    strings['attribute.mapper.config.list_style_fr'] = "Les listes sont affichées comme";
    strings['attribute.mapper.config.list_style_bullet_fr'] = "Liste avec des puces";
    strings['attribute.mapper.config.list_style_numbered_fr'] = "Liste ordonnée";
    
    strings['attribute.mapper.config.main_properties_fr'] = "Propriétés principales";
    strings['attribute.mapper.config.more_properties_fr'] = "Plus de propriétés";
    strings['attribute.mapper.config.meta_properties_fr'] = "Attributs personnalisés";
    
    strings['glossary.mapper.type.document_fr'] = "Documents";
    strings['glossary.mapper.type.org_unit_fr'] = "Unitées d'organisation";
    strings['glossary.mapper.type.it_system_fr'] = "Systèmes IT";
    strings['glossary.mapper.type.activity_fr'] = "Activités";
    strings['glossary.mapper.type.state_fr'] = "Événements";
    
    strings['glossary.mapper.loading_groups_fr'] = "Chargement des groupes du dictionnaire en cours...";
    strings['glossary.mapper.all_categories_fr'] = "Tout choisir";
    strings['glossary.mapper.categories_chosen_fr'] = "choisis";
    strings['glossary.mapper.select_all_fr'] = "Sélectionner tout";
    strings['glossary.mapper.select_none_fr'] = "Ne rien sélectionner";
    
    strings['glossary.form.description_fr'] = "Les attributs suivants peuvent être définis dans d'autres langues. Veuillez utiliser le menu avec le champs déroulant en haut de la page pour changer la langue.<br/>Veuillez prendre note que le titre doit être défini dans une langue au moins.";

    strings['glossary.edit.title_fr'] = "Éditer l'entrée";
    strings['glossary.edit.save_fr'] = "Sauvegarder";
    strings['glossary.edit.description_fr'] = "Éditer l'entrée actuelle du dictionnaire.";

    strings['glossary.new.title_fr'] = "Nouvelle entrée";
    strings['glossary.new.save_fr'] = "Créer";
    strings['glossary.new.create_fr'] = "Création d'une nouvelle entrée dans le dictionnaire.";

	strings['glossary.multilanguage.non_attributes_fr'] = "Les attributs suivants ne peuvent être défini que dans la langue par défaut.";
    strings['glossary.multilanguage.copy_link_tt_fr'] = "Veuillez prendre note que tout le contenu sera remplacé par le nouveau.";
    strings['glossary.multilanguage.remove_origin_column_fr'] = "Cacher la colonne de gauche";
    strings['glossary.multilanguage.copy_link_title_fr'] = "Copier tout le contenu";

    strings['glossary.view.title_fr'] = "Titre";
    strings['glossary.view.attachments_fr'] = "Liens vers des documents externes";
    strings['glossary.view.description_fr'] = "Description";

    strings['propertyeditor.itsm.assignee.company_fr'] = "Société";
    strings['propertyeditor.itsm.assignee.organization_fr'] = "Organisation";
    strings['propertyeditor.itsm.assignee.group_fr'] = "Groupe";
    
    strings['propertyeditor.itsm.location.region_fr'] = "Région";
    strings['propertyeditor.itsm.location.sitegroup_fr'] = "Groupe du site";
    strings['propertyeditor.itsm.location.site_fr'] = "Site";
    
    strings['propertyeditor.itsm.servicecat.tier_fr'] = "Rang {0}";
    
    strings['propertyeditor.itsm.productcat.name_fr'] = "Nom";
    strings['propertyeditor.itsm.productcat.model_fr'] = "Diagramme";
    
    strings['propertyeditor.itsm.variablemapping.header.variable_fr'] = "Variable";
    strings['propertyeditor.itsm.variablemapping.header.input_fr'] = "Entrant";
    strings['propertyeditor.itsm.variablemapping.header.output_fr'] = "Sortant";
    
    strings['propertyeditor.itsm.variablemapping.error.title_fr'] = "Trop de variables";
    strings['propertyeditor.itsm.variablemapping.error.message_fr'] = "Trop de variables de type '{0}' sont utilisées.<br/> Le maximum est de: {1}.";
    
    strings['propertyeditor.itsm.condition.add_fr'] = "Ajouter une variable...";

    strings['glossary.new.languageswitch_fr'] = "Langue";
    
    strings['language_bg_fr'] = "Bulgare";
    strings['language_cz_fr'] = "Tchèque";
    strings['language_dk_fr'] = "Danois";
    strings['language_nl_fr'] = "Néerlandais";
    strings['language_ee_fr'] = "Estonien";
    strings['language_fi_fr'] = "Finnois";
    strings['language_fr_fr'] = "Français";
    strings['language_de_fr'] = "Allemand";
    strings['language_gr_fr'] = "Grec";
    strings['language_hu_fr'] = "Hongrois";
    strings['language_ie_fr'] = "Irlandais";
    strings['language_it_fr'] = "Italien";
    strings['language_lv_fr'] = "Letton";
    strings['language_lt_fr'] = "Lituanien";
    strings['language_mt_fr'] = "Maltais";
    strings['language_pl_fr'] = "Polonais";
    strings['language_pt_fr'] = "Portugais";
    strings['language_ro_fr'] = "Roumain";
    strings['language_sk_fr'] = "Slovaque";
    strings['language_si_fr'] = "Slovène";
    strings['language_es_fr'] = "Espagnol";
    strings['language_se_fr'] = "Suédois";
    strings['language_mx_fr'] = "Spanish";
    strings['language_en_fr'] = "Anglais";
    strings['language_lu_fr'] = "Luxembourgeois";
    strings['language_za_fr'] = "Afrikaans";
    
    strings['country_at_fr'] = "Autriche";
    strings['country_be_fr'] = "Belgique";
    strings['country_bg_fr'] = "Bulgarie";
    strings['country_ch_fr'] = "Suisse";
    strings['country_cz_fr'] = "République tchèque";
    strings['country_dk_fr'] = "Danemark";
    strings['country_gb_fr'] = "Grande-Bretagne";
    strings['country_nl_fr'] = "Pays-Bas";
    strings['country_ee_fr'] = "Estonie";
    strings['country_fi_fr'] = "Finlande";
    strings['country_fr_fr'] = "France";
    strings['country_de_fr'] = "Allemagne";
    strings['country_gr_fr'] = "Grèce";
    strings['country_hu_fr'] = "Hongrie";
    strings['country_ie_fr'] = "Irlande";
    strings['country_it_fr'] = "Italie";
    strings['country_lv_fr'] = "Lettonie";
    strings['country_lt_fr'] = "Lituanie";
    strings['country_mt_fr'] = "Malte";
    strings['country_pl_fr'] = "Pologne";
    strings['country_pt_fr'] = "Portugal";
    strings['country_ro_fr'] = "Roumanie";
    strings['country_sk_fr'] = "Slovaquie";
    strings['country_si_fr'] = "Slovénie";
    strings['country_es_fr'] = "Espagne";
    strings['country_se_fr'] = "Suède";
    strings['country_en_fr'] = "Angleterre";
    strings['country_mx_fr'] = "Mexique";
    strings['country_us_fr'] = "Etats-Unis";
    strings['country_lu_fr'] = "Luxembourg";
    strings['country_za_fr'] = "Afrique du Sud";
    strings['country_br_fr'] = "Brésil";
    strings['country_ca_fr'] = "Canada";
    strings['country_cl_fr'] = "Chili";
    strings['country_li_fr'] = "Liechtenstein";
    strings['country_nz_fr'] = "Nouvelle Zélande";
    strings['coutnry_au_fr'] = "Australie";

    //TODO
	strings['multilanguage.language.bg_fr'] = "Bulgare";
	strings['multilanguage.language.cz_fr'] = "Tchèque";
	strings['multilanguage.language.dk_fr'] = "Danois";
	strings['multilanguage.language.nl_fr'] = "Néerlandais";
	strings['multilanguage.language.ee_fr'] = "Estonien";
	strings['multilanguage.language.fi_fr'] = "Finnois";
	strings['multilanguage.language.fr_fr'] = "Français";
	strings['multilanguage.language.de_fr'] = "Allemand";
	strings['multilanguage.language.gr_fr'] = "Grec";
	strings['multilanguage.language.hu_fr'] = "Hongrois";
	strings['multilanguage.language.ie_fr'] = "Irlandais";
	strings['multilanguage.language.it_fr'] = "Italien";
	strings['multilanguage.language.lv_fr'] = "Letton";
	strings['multilanguage.language.lt_fr'] = "Lituanien";
	strings['multilanguage.language.mt_fr'] = "Maltais";
	strings['multilanguage.language.pl_fr'] = "Polonais";
	strings['multilanguage.language.pt_fr'] = "Portugais";
	strings['multilanguage.language.ro_fr'] = "Roumain";
	strings['multilanguage.language.sk_fr'] = "Slovaque";
	strings['multilanguage.language.si_fr'] = "Slovène";
	strings['multilanguage.language.es_fr'] = "Espagnol";
	strings['multilanguage.language.se_fr'] = "Suédois";
	strings['multilanguage.language.mx_fr'] = "Espagnol";
	strings['multilanguage.language.en_fr'] = "Anglais";
	strings['multilanguage.language.lu_fr'] = "Luxembourgeois";
	strings['multilanguage.language.za_fr'] = "Afrikaans";

	strings['multilanguage.country.at_fr'] = "Austria";
	strings['multilanguage.country.be_fr'] = "Belgique";
	strings['multilanguage.country.bg_fr'] = "Bulgarie";
	strings['multilanguage.country.ch_fr'] = "Suisse";
	strings['multilanguage.country.cz_fr'] = "République tchèque";
	strings['multilanguage.country.dk_fr'] = "Danemark";
	strings['multilanguage.country.gb_fr'] = "Grande-Bretagne";
	strings['multilanguage.country.nl_fr'] = "Pays-Bas";
	strings['multilanguage.country.ee_fr'] = "Estonie";
	strings['multilanguage.country.fi_fr'] = "Finlande";
	strings['multilanguage.country.fr_fr'] = "France";
	strings['multilanguage.country.de_fr'] = "Allemagne";
	strings['multilanguage.country.gr_fr'] = "Grèce";
	strings['multilanguage.country.hu_fr'] = "Hongrie";
	strings['multilanguage.country.ie_fr'] = "Irlande";
	strings['multilanguage.country.it_fr'] = "Italie";
	strings['multilanguage.country.lv_fr'] = "Lettonie";
	strings['multilanguage.country.lt_fr'] = "Lituanie";
	strings['multilanguage.country.mt_fr'] = "Malte";
	strings['multilanguage.country.pl_fr'] = "Pologne";
	strings['multilanguage.country.pt_fr'] = "Portugal";
	strings['multilanguage.country.ro_fr'] = "Roumanie";
	strings['multilanguage.country.sk_fr'] = "Slovaquie";
	strings['multilanguage.country.si_fr'] = "Slovénie";
	strings['multilanguage.country.es_fr'] = "Espagne";
	strings['multilanguage.country.se_fr'] = "Suède";
	strings['multilanguage.country.en_fr'] = "Angleterre";
	strings['multilanguage.country.mx_fr'] = "Mexique";
	strings['multilanguage.country.us_fr'] = "Etats-Unis";
	strings['multilanguage.country.lu_fr'] = "Luxembourg";
	strings['multilanguage.country.za_fr'] = "Afrique du Sud";
	strings['multilanguage.country.br_fr'] = "Brésil";
	strings['multilanguage.country.ca_fr'] = "Canada";
	strings['multilanguage.country.cl_fr'] = "Chili";
	strings['multilanguage.country.li_fr'] = "Liechtenstein";
	strings['multilanguage.country.nz_fr'] = "Nouvelle Zélande";
	strings['multilanguage.country.au_fr'] = "Australie";

	/**
	 * DUTCH TRANSLATION
	 * First translation into Dutch: -
	 * Translator: Gerjan Grootenboer
	 * @translationchecker - 
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_nl = "Toevoegen";
	strings.btnopen_nl = "Openen";
	strings.btnremove_nl = "Verwijderen";
	strings.btnedit_nl = "Wijzigen";
	strings.btnreset_nl = "Resetten";
	strings.btnclose_nl = "Sluiten";
	strings.btnsave_nl = "Opslaan";
	strings.moveup_nl = "Verplaats omhoog";
	strings.movedown_nl = "Verplaats omlaag";
	strings.url_nl = "URL";
	strings.label_nl = "Label";
	strings.year_nl = "Jaar";
	strings.years_nl = "Jaren";
	strings.month_nl = "Maand";
	strings.months_nl = "Maanden";
	strings.day_nl = "Dag";
	strings.days_nl = "Dagen";
	strings.hour_nl = "Uur";
	strings.hours_nl = "Uren";
	strings.minute_nl = "Minuut";
	strings.minutes_nl = "Minuten";
	strings.second_nl = "Seconde";
	strings.seconds_nl = "Seconden";
	strings.msecond_nl = "Milliseconden";
	strings.mseconds_nl = "Milliseconden";
	
	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_nl = "'#{0}' aanmaken als #{1}";
	strings.createglossarynew_nl = "Nieuwe aanmaken";
	
	// GLOSSARY CATEGORIES
	strings.documen_nl = "Dokumente";
	strings.org_unit_nl = "Organisatie-eenheden";
	strings.it_system_nl = "IT-systemen";
	strings.activity_nl= "Activiteiten";
	strings.state_nl = "Events";
	
	// FEEDBACK WINDOW
	strings["views.feedbacktitleenterprise_nl"] = "Support";
	strings["views.feedbacktitle_nl"] = "Signavio Support";
	strings["views.feedbacktitleenterprise_nl"] = "Supportanfrage senden";
	strings["views.feedbacktitle_nl"] = "Supportanfrage an Signavio senden";
	strings["views.feedbackentersubject_nl"] = "Geef een onderwerp dat het probleem of vraag kort beschrijft.";
	strings["views.feedbackenterdescription_nl"] = "Beschrijf uw probleem of vraag zo gedetailleerd mogelijk.";
	strings["views.feedbackpmsg_nl"] = "Gedetailleerde beschrijving van de fout";
	strings["views.feedbackpempty_nl"] = "* Beschrijf uw vraag en verstrek zoveel mogelijk details.\n* Ingeval van foutmeldingen ook de stappen aangeven hoe het probleem kan worden gereproduceerd en beschrijf de output die u verwacht.";
	strings["views.feedbackpsubject_nl"] = "Probleem met de Signavio Process Editor";
	strings["views.feedbackpbrowser_nl"] = "Informatie over uw browser en omgeving";
	strings["views.feedbackpbrowserdesc_nl"] = "Deze informatie is automatisch gedetecteerd via uw browser. Dit kan nuttig zijn als u een bug heeft gevonden welke verband houdt met browserspecifiek gedrag.";
	strings["views.feedbackclosetitle_nl"] = "Sluiten";
	strings["views.feedbackfailure_nl"] = "Mislukt";
	strings["views.feedbackfailuremsg_nl"] = "Het bericht kon niet worden verzonden!";
	strings["views.feedbacksuccess_nl"] = "Gelukt";
	strings["views.feedbacksuccessmsg_nl"] = "Bedankt voor uw feedback!";
	strings["views.feedbacksending_nl"] = "Bericht versturen...";
	strings["views.sendfeedback_nl"] = "Verstuur supportverzoek";
	strings["views.feedbackpattach_nl"] = "Koppel het huidige diagram";
	strings["views.feedbackpattachdesc_nl"] = "Deze informatie kan nuttig zijn voor debugging doeleinden. Als het diagram vertrouwelijke gegevens bevat, verwijder die dan voorafgaand aan het verzenden of vink dit af.";
	strings["views.feedbackreceiver_nl"] = "Ontvanger";
	strings["views.feedbackreceiversignavio_nl"] = "Signavio support ([mail])";
	strings["views.feedbackreceiverenterprise_nl"] = "Uw support ([mail])";
	strings["views.feedbackmissingheader_nl"] = "Geen onderwerp";
	strings["views.feedbackmissingheadermsg_nl"] = "Geef een onderwerp.";
	strings["views.feedbackmissingbody_nl"] = "Geen bericht";
	strings["views.feedbackmissingbodymsg_nl"] = "Schrijf een bericht.";
	strings["views.feedbackerrorlength_nl"] = "De beschrijving is te kort, type tenminste 40 tekens.";
	strings["views.feedbackerrorlengthtitle_nl"] = "Bericht is te kort";
	strings["views.feedbacksignavio_nl"] = "Hebt u een probleem met het gebruik van de Signavio Process Editor of hebt u een fout gevonden? Gebruik dan het supportformulier om direct contact op te nemen met Signavio Support. Het behandelen van uw aanvraag kan 1-2 werkdagen duren. We zullen reageren per e-mail. Alle informatie wordt ongecodeerd verzonden.";
	strings["views.feedbackenterprise_nl"] = "Hebt u een probleem met het gebruik van de Signavio Process Editor of hebt u een fout gevonden? Gebruik dan het supportformulier om rechtstreeks contact op te nemen met Support of de administrator. Alle informatie wordt ongecodeerd verzonden.";	
	
	// PDF EXPORT WINDOW
	strings["views.offertitle_nl"] = "PDF (enkel diagram)";
	strings["views.offertitledesc_nl"] = "U kunt het diagram afdrukken op meerdere pagina's. Selecteer de layout voor uw PDF-export.";
	strings["views.optionwindowtitle_nl"] = "PDF-Export (enkel diagram)";
	strings["views.buttontitle_nl"] = "Genereer PDF";
	strings["views.closetitle_nl"] = "Annuleren";
	strings["views.fittopage_nl"] = "Alles op één pagina plaatsen";
	strings["views.clipallsides_nl"] = "Doorlopende afdruk (2-dimensionaal)";
	strings["views.clipbottom_nl"] = "Doorlopende afdruk (verticaal)";
	strings["views.clipright_nl"] = "Doorlopende afdruk (horizontaal)";
	strings["views.landscape_nl"] = "Liggend";
	strings["views.portrait_nl"] = "Staand";
	strings["views.defaultname_nl"] = "Exporteren";
	strings["views.branding_nl"] = "Verwijder Signavio logo's";
	strings["views.premiumonly_nl"] = "Deze functie is alleen beschikbaar in de Professional Editie.";
	strings["views.waiting_nl"] = "Procesdocumentatie wordt aangemaakt.<br/>Dit kan enige tijd duren...";
	strings["views.resetview_nl"] = "Origineel";
	strings["views.windowdescription_nl"] = "Selecteer een weergave voor de export:";
	strings["panel.businessrule_nl"] = "Business Rule";
	strings["panel.static_nl"] = "Statisch";
	strings["panel.dynamic_nl"] = "Dynamisch";
	strings["panel.operation_nl"] = "Operatie";
	strings["panel.add_nl"] = "toevoegen";
	strings["panel.remove_nl"] = "Verwijderen";
	strings["panel.no_description_nl"] = "Geen beschrijving";
	strings["panel.no_performer_nl"] = "Geen uitvoerder gedefinieerd.";
	strings["panel.no_users_nl"] = "Geen gebruikers beschikbaar.";
	strings["panel.no_free_userselection_nl"] = "Onbeperkte gebruikersselectie";
	strings["panel.no_parallel_title_nl"] = "Groep toevoegen";
	strings["panel.no_parallel_description_nl"] = "Voor het huidige element is het lustype ingesteld op parallel of sequentieel, het betekent dat verschillende gebruikers de taak kunnen uitvoeren. Om dit te vereenvoudigen: wilt u alle leden van de geselecteerde groep gebruiken in plaats van de groep zelf?";
	strings["panel.no_parallel_no_user_nl"] = "De huidige groep bevat geen leden.";
	strings["panel.no_defined_role_label_nl"] = "Voorselectie";
	strings["panel.no_defined_role_single_user_nl"] = "Single-user";
	strings["panel.no_defined_role_role_member_nl"] = "Leden van de groep/rol";
	strings["panel.no_defined_role_group_nl"] = "Groepen/rollen";
	strings["panel.label_free_userselection_nl"] = "(Onbeperkte gebruikersselectie)";
	
	strings["wizard.nextbtnlabel_nl"] = "Volgende >";
	strings["wizard.previousbtnlabel_nl"] = "< Vorige";
    
	// RICHTEXT
	strings["richtext.title.undo_nl"] = "Ongedaan maken (Ctrl+Z)";
    strings["richtext.text.undo_nl"] = "De laatste veranderingen ongedaan maken.";
    strings["richtext.title.redo_nl"] = "Opnieuw uitvoeren (Shift+Ctrl+Z)";
    strings["richtext.text.redo_nl"] = "De laatste wijzigingen opnieuw uitvoeren.";
    strings["richtext.title.bold_nl"] = "Vet (Ctrl+B)";
    strings["richtext.text.bold_nl"] = "De geselecteerde tekst in vet zetten.";
    strings["richtext.title.italic_nl"] = "Cursief (Ctrl+I)";
    strings["richtext.text.italic_nl"] = "De geselecteerde tekst cursief zetten.";
    strings["richtext.title.underline_nl"] = "Onderstrepen (Ctrl+U)";
    strings["richtext.text.underline_nl"] = "De geselecteerde tekst onderstrepen.";
    strings["richtext.title.fontselect_nl"] = "Lettertype";
    strings["richtext.text.fontselect_nl"] = "Het lettertype van de geselecteerde tekst wijzigen.";
    strings["richtext.title.fontsizeselect_nl"] = "Lettergrootte:";
    strings["richtext.text.fontsizeselect_nl"] = "De tekengrootte van de geselecteerde tekst wijzigen.";
    strings["richtext.title.h1_nl"] = "Koptekst";
    strings["richtext.text.h1_nl"] = "Koptekst invoegen.";
    strings["richtext.title.h2_nl"] = "Subkoptekst";
    strings["richtext.text.h2_nl"] = "Een subkop invoegen.";
    strings["richtext.title.h3_nl"] = "Sectie koptekst";
    strings["richtext.text.h3_nl"] = "Voeg een nieuwe sectie koptekst in.";   
    strings["richtext.title.inserthorizontalrule_nl"] = "Horizontale Rule";
    strings["richtext.text.inserthorizontalrule_nl"] = "Invoegen van een horizontale lijn.";
    strings["richtext.title.color_nl"] = "Letterkleur";
    strings["richtext.text.color_nl"] = "De kleur van de geselecteerde tekst wijzigen.";
    strings["richtext.title.markupcolor_nl"] = "Tekst markeerkleur";
    strings["richtext.text.markupcolor_nl"] = "De achtergrondkleur van de geselecteerde tekst wijzigen.";
    strings["richtext.title.justifyleft_nl"] = "Tekst links uitlijnen";
    strings["richtext.text.justifyleft_nl"] = "Tekst links uitlijnen.";
    strings["richtext.title.justifycenter_nl"] = "Tekst centreren";
    strings["richtext.text.justifycenter_nl"] = "Tekst centreren in de editor.";
    strings["richtext.title.justifyright_nl"] = "Tekst rechts uitlijnen";
    strings["richtext.text.justifyright_nl"] = "Tekst rechts uitlijnen.";
    strings["richtext.title.indent_nl"] = "Inspringen (Tab)";
    strings["richtext.text.indent_nl"] = "Tekst laten inspringen.";
    strings["richtext.title.outdent_nl"] = "Inspringing verkleinen (Shift+Tab)";
    strings["richtext.text.outdent_nl"] = "Uitspringen van tekst.";
    strings["richtext.title.createlink_nl"] = "Hyperlink";
    strings["richtext.text.createlink_nl"] = "Van de geselecteerde tekst een hyperlink maken.";
    strings["richtext.title.unlink_nl"] = "Hyperlink verwijderen";
    strings["richtext.text.unlink_nl"] = "Hiermee verwijdert u de hyperlink van de selectie.";
    strings["richtext.title.insertorderedlist_nl"] = "Lijst (genummerd)";
    strings["richtext.text.insertorderedlist_nl"] = "Begin een genummerde lijst.";
    strings["richtext.title.insertunorderedlist_nl"] = "Lijst met opsommingstekens";
    strings["richtext.text.insertunorderedlist_nl"] = "Start een lijst met opsommingstekens.";
    strings["richtext.title.removeformat_nl"] = "Opmaak verwijderen";
    strings["richtext.text.removeformat_nl"] = "Verwijdert alle toegepaste opmaak in de selectie.";  
    strings['richtext.colormenu.defaultcolor_nl'] = 'Automatisch';
    strings['richtext.stub.more_nl'] = 'meer';
    strings['richtext.stub.less_nl'] = 'minder';
    strings['richtext.stub.openprint_nl'] = 'Open afdrukweergave';
    
    // COMMED TRANSLATIONS
    strings['commed.expression.otherwise_nl'] = 'Default'; 
    strings['commed.expression.manual_nl'] = 'Handmatige gebruikersactie';
    strings['commed.expression.automaticrule_nl'] = 'Geautomatiseerde Rule voor JavaScript'; 
    strings['commed.expression.jsrule_nl'] = 'JavaScript-regel';
    strings['commed.expression.standarderror_nl'] = 'Standaard Fout';
    strings['commed.expression.exception_nl'] = 'Uitzondering';
    strings['commed.expression.exceptions_nl'] = 'Uitzonderingen';
    strings['commed.rolemapping.loadingroles_nl'] = 'Rollen laden';
    strings['commed.servicecall.and_nl'] = 'en';
    strings['commed.servicecall.aredefined_nl'] = 'zijn gedefinieerd.';
    strings['commed.servicecall.loadingformulars_nl'] = 'Formulier laden.';
    strings['commed.servicecall.loadingmeasures_nl'] = 'Metingen laden...';
    strings['commed.servicecall.formulars_nl'] = 'Formulieren';
    strings['commed.servicecall.performingsearch_nl'] = 'Zoeken...';
    strings['commed.servicecall.nofound_nl'] = 'Geen enkele meting gevonden.';
    strings['commed.servicecall.nomeasuresselected_nl'] = 'Nog geen enkele meting geselecteerd.';
    strings['commed.servicecall.pleaseselect_nl'] = 'Selecteer een meting aan de rechterkant om toe te voegen aan uw selectie.';
    strings['commed.servicecall.measure_nl'] = 'Meting';
    strings['commed.servicecall.nowfv_nl'] = 'Geen WFV gedefinieerd.';
    strings['commed.servicecall.loadinginputs_nl'] = 'Laden inputs...';
    strings['commed.servicecall.noinputs_nl'] = 'Geen inputs.';
    strings['commed.servicecall.loadingoutputs_nl'] = 'Laden Outputs.';
    strings['commed.servicecall.nooutputs_nl'] = 'Geen Outputs.';
    strings['commed.servicecall.loadingservice_nl'] = 'Service laden...';
    strings['commed.servicecall.selectservice_nl'] = 'Selecteer een service.';
    strings['commed.servicecall.remove_nl'] = 'Verwijderen';
    strings['commed.servicecall.parameteralert_nl'] = "Voor dit attribuut moet u een 'Subproces-Reference' definiëren. Druk op de plus-button om een subproces te koppelen";
    strings['commed.servicecall.selectboandservice_nl'] = 'Selecteer een Service en een BO.';
    strings['commed.servicecall.noinputsinsub_nl'] = 'Geen inputs in het subproces gedefinieerd';
    strings['commed.servicecall.nooutputsinsub_nl'] = 'Geen Outputs in het subproces gedefinieerd';
    strings['commed.servicecall.noserviceinsub_nl'] = 'Het subproces waarnaar wordt verwezen heeft geen Services gedefinieerd';

    strings['glossary.form.description_nl'] = "The following attributes can be defined in different languages. Please use the drop-down field in the top to change the language.<br/>Consider that the title must be defined in at least one language.";

    strings['glossary.edit.title_nl'] = "Item bewerken";
    strings['glossary.edit.save_nl'] = "Opslaan";
    strings['glossary.edit.description_nl'] = "Huidige dictionary vermelding bewerken.";

    strings['glossary.new.title_nl'] = "Nieuw item";
    strings['glossary.new.save_nl'] = "Aanmaken";
    strings['glossary.new.create_nl'] = "Creëer een nieuw dictionary item.";

    strings['glossary.multilanguage.non_attributes_nl'] = "The following attributes can only be defined in the default language.";
    strings['glossary.multilanguage.copy_link_tt_nl'] = "Please notice that all contents will be replace by the new contents.";
    strings['glossary.multilanguage.remove_origin_column_nl'] = "Hide left column";
    strings['glossary.multilanguage.copy_link_title_nl'] = "Copy all contents";

    strings['glossary.view.title_nl'] = "Titel";
    strings['glossary.view.attachments_nl'] = "Relevant documents";
    strings['glossary.view.description_nl'] = "Beschrijving";
﻿
	/**
	 * ENGLISH TRANSLATION
	 * First translation into English: -
	 * Translator: -
	 * @translationchecker -
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_ru = "Добавить";
	strings.btnopen_ru = "Открыть";
	strings.btnremove_ru = "Удалить";
	strings.btnedit_ru = "Редактировать";
	strings.btnreset_ru = "Сбросить";
	strings.btnclose_ru = "Закрыть";
	strings.btnsave_ru = "Сохранить";
	strings.btnapply_ru = "Применить";
	strings.moveup_ru = "Вверх";
	strings.movedown_ru = "Вниз";
	strings.url_ru = "URL";
	strings.label_ru = "Метка";
	strings.year_ru = "Год";
	strings.years_ru = "Года";
	strings.month_ru = "Месяц";
	strings.months_ru = "Месяца";
	strings.day_ru = "День";
	strings.days_ru = "Дни";
	strings.hour_ru = "Час";
	strings.hours_ru = "Часы";
	strings.minute_ru = "Минута";
	strings.minutes_ru = "Минуты";
	strings.second_ru = "Секунда";
	strings.seconds_ru = "Секунды";
	strings.msecond_ru = "Милисекунда";
	strings.mseconds_ru = "Милисекунды";

	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_ru = "'#{0}' создано как #{1}";
	strings.createglossarynew_ru = "Создать новый";

	// GLOSSARY CATEGORIES
	strings.document_ru = "Документы";
	strings.org_unit_ru = "Организационные части";
	strings.it_system_ru = "IT системы";
	strings.activity_ru = "Действия";
	strings.state_ru = "События";

	strings.noglossary_entry_ru = "Нет полей словаря.";

	//Feedback Window
	strings["views.feedbacktitleenterprise_ru"] = "Служба поддержки Signavio";
	strings["views.feedbacktitle_ru"] = "Служба поддержки";
	strings["views.feedbacktitleenterprise_ru"] = "Служба поддержки";
	strings["views.feedbacktitle_ru"] = "Служба поддержки Signavio";
	strings["views.feedbackentersubject_ru"] = "Пожалуйста, введите тему, которая кратко определяет проблему или вопрос.";
	strings["views.feedbackenterdescription_ru"] = "Пожалуйста, опишите проблему или вопрос, как можно детальнее.";
	strings["views.feedbackpmsg_ru"] = "Детальное описание ошибки";
	strings["views.feedbackpempty_ru"] = "* Пожалуйста, опишите Ваш запрос. Пожалуйста, дайте как можно более детальную информацию.\n* Для отчета об ошибках, пожалуйста, приведите список шагов, которые помогут воспроизвести проблему и опишите результат, который Вы ожидаете.";
	strings["views.feedbackpsubject_ru"] = "Проблема с Signavio Process Editor";
	strings["views.feedbackpbrowser_ru"] = "Информация про Ваш браузер и систему";
	strings["views.feedbackpbrowserdesc_ru"] = "Эта информация была получена автоматически с Вашего браузера. Это может быть полезно, если у Вас была ошибка связанная с поведением браузера.";
	strings["views.feedbackclosetitle_ru"] = "Закрыть";
	strings["views.feedbackfailure_ru"] = "Неудачно";
	strings["views.feedbackfailuremsg_ru"] = "Сообщение не могло быть отправлено!";
	strings["views.feedbacksuccess_ru"] = "Удачно";
	strings["views.feedbacksuccessmsg_ru"] = "Спасибо за Ваш отзыв!";
	strings["views.feedbacksending_ru"] = "Отправка сообщения ...";
	strings["views.sendfeedback_ru"] = "Отправить запрос службе поддержки";
	strings["views.feedbackpattach_ru"] = "Прикрепить текущую диаграмму";
	strings["views.feedbackpattachdesc_ru"] = "Эта информация может быть полезна в целях отладки. Если Ваша диаграмма содержит какую-либо важную информацию, удалите ее перед отправкой, либо отмените запрос.";
	strings["views.feedbackreceiver_ru"] = "Получатель";
	strings["views.feedbackreceiversignavio_ru"] = " служба поддержки Signavio ([mail])";
	strings["views.feedbackreceiverenterprise_ru"] = " Ваша поддержка ([mail])";
	strings["views.feedbackmissingheader_ru"] = "Нет описания проблемы";
	strings["views.feedbackmissingheadermsg_ru"] = "Пожалуйста, введите короткое описание проблемы.";
	strings["views.feedbackmissingbody_ru"] = "Нет детального описания";
	strings["views.feedbackmissingbodymsg_ru"] = "Пожалуйста, опишите в детальном сообщении: Какие у Вас проблемы? Какое ожидаемое поведение?";
	strings["views.feedbackerrorlength_ru"] = "Описание слишком короткое. Пожалуйста, введите как минимум 40 букв.";
	strings["views.feedbackerrorlengthtitle_ru"] = "Сообщение слишком короткое";
	strings["views.feedbacksignavio_ru"] = "You have a problem with using the Signavio Process Editor or you have found an error? In this case please use the support form to contact the Signavio " +
										"support directly. Please notice, that the handling of your request can take about 1-2 business days. " +
										"We will respond by email. All information is transferred unencrypted.";
										   "Falle das Support-Formular um direkten Kontakt mit Signavio aufzunehmen. Bitte beachten Sie, dass eine Bearbeitung Ihrer Anfrage "+
										   "ca. 1-2 Werktage in Anspruch nehmen kann. Sie erhalten unsere Antwort anschließend per Email. Sämtliche Informationen werden unverschlüsselt "+
										   "übertragen.";
										  "Por favor tome en cuenta que el manejo de su solicitud puede tardar de 1-2 días hábiles." + "Le responderemos por correo electrónico. Toda la información se transmite cifrada";
										  "У Вас есть проблемы и использованием Signavio Process Editor или Вы нашли ошибку? В этом случае используйте, пожалуйста, форму поддержки чтобы напрямую связаться с службой поддержки " +
											"Signavio. Пожалуйста, обратите внимание, что обработка Вашего запроса может занять 1-2 рабочих дня. " + "Мы ответим по email. Вся передаваемая информация незашифрована.";
	strings["views.feedbackenterprise_ru"] = "You have a problem with using the Signavio Process Editor or you have found an error? In this case please use the support form to directly contact your " +
										  "support or administrator. All information is transferred unencrypted.";
											 "Falle das Support-Formular um direkten Kontakt mit Ihrem Support/Administrator aufzunehmen. Sämtliche Informationen werden unverschlüsselt "+
											 "übertragen.";
										  "Por favor tome en cuenta que el manejo de su solicitud puede tardar de 1-2 días hábiles." + "Le responderemos por correo electrónico. Toda la información se transmite cifrada";
										  "У Вас есть проблемы с использованием Signavio Process Editor или Вы нашли ошибку? В этом случае, пожалуйста, используйте форму поддержки чтобы напрямую связаться с службой поддержки " +
										  "или администратором. Вся передаваемая информация незашифрована.";
	//PDF Export Window
	strings["views.offertitle_ru"] = "PDF (одна диаграмма)";
	strings["views.offertitledesc_ru"] = "Вы можете напечатать диаграмму на нескольких страницах. Пожалуйста, выберите  расположение, которое Вы хотите для Вашего PDF экспорта.";
	strings["views.optionwindowtitle_ru"] = "PDF Экспорт (одна диаграмма)";
	strings["views.buttontitle_ru"] = "Сгенерировать PDF";
	strings["views.closetitle_ru"] = "Отмена";
	strings["views.fittopage_ru"] = "Подогнать под одну страницу";
	strings["views.clipallsides_ru"] = "Непрерывная печать (2-мерная)";
	strings["views.clipbottom_ru"] = "Непрерывная печать (вертикальная)";
	strings["views.clipright_ru"] = "Непрерывная печать (горизонтальная)";
	strings["views.landscape_ru"] = "Горизотальная";
	strings["views.portrait_ru"] = "Вертикальная";
	strings["views.defaultname_ru"] = "Экспорт";
	strings["views.branding_ru"] = "Убрать значки Signavio";
	strings["views.premiumonly_ru"] = "Эта функция доступна только для Professional edition.";
	strings["views.waiting_ru"] = "Будет создана документация процесса.<br/>Это может занять некоторое время...";
	strings["views.resetview_ru"] = "Оригинал";
	strings["views.windowdescription_ru"] = "Пожалуйста, выберите представление для экспорта:";


	strings["panel.businessrule_ru"] = "Бизнесс правило";
	strings["panel.static_ru"] = "Статическое";
	strings["panel.dynamic_ru"] = "Динамическое";
	strings["panel.operation_ru"] = "Операция";
	strings["panel.add_ru"] = "добавить";
	strings["panel.remove_ru"] = "удалить";

	strings["panel.no_description_ru"] = "Нет описания";
	strings["panel.no_performer_ru"] = "Выполнитель не определен.";
	strings["panel.no_users_ru"] = "Нет доступных пользователей.";
	strings["panel.no_free_userselection_ru"] = "Неограниченный выбор";
	strings["panel.no_parallel_title_ru"] = "Добавить группу";
	strings["panel.no_parallel_description_ru"] = "Для текущего элемента, тип цикла установлен как паралельный или последовательный, это значит что несколько пользователей  могут выполнять это задание. Чтобы упростить это, Вы хотие использовать всех пользователей выбранной группы вместо группы?";
	strings["panel.no_parallel_no_user_ru"] = "Текущая группа не содержит пользователей.";
	strings["panel.no_defined_role_label_ru"] = "Предварительный выбор";
	strings["panel.no_defined_role_single_user_ru"] = "Один пользователь";
	strings["panel.no_defined_role_role_member_ru"] = "Члены группы/роли";
	strings["panel.no_defined_role_group_ru"] = "Группы/поли";
	strings["panel.label_free_userselection_ru"] = "(Неограниченный выбор)";

	strings["wizard.nextbtnlabel_ru"] = "Дальше >";
	strings["wizard.previousbtnlabel_ru"] = "< Назад";

	/** New Language Properties 27.07.2010 */
    strings["richtext.title.undo_ru"] = "Отменить (Ctrl+Z)";
    strings["richtext.text.undo_ru"] = "Отменяет последние изменения.";

    strings["richtext.title.redo_ru"] = "Вернуть (Shift+Ctrl+Z)";
    strings["richtext.text.redo_ru"] = "Возвращает последние изменения.";
    strings["richtext.title.bold_ru"] = "Жирный (Ctrl+B)";
    strings["richtext.text.bold_ru"] = "Сделать выбранный текст жирным.";

    strings["richtext.title.italic_ru"] = "Курсив (Ctrl+I)";
    strings["richtext.text.italic_ru"] = "Сделать выбранный текст курсивом.";

    strings["richtext.title.underline_ru"] = "Подчеркнутый (Ctrl+U)";
    strings["richtext.text.underline_ru"] = "Подчеркнуть выбранный текст.";

    strings["richtext.title.fontselect_ru"] = "Шрифт";
    strings["richtext.text.fontselect_ru"] = "Изменить шрифт выбранного текста.";

    strings["richtext.title.fontsizeselect_ru"] = "Размер шрифта";
    strings["richtext.text.fontsizeselect_ru"] = "Изменить размер выбранного шрифта.";

    strings["richtext.title.h1_ru"] = "Заголовок";
    strings["richtext.text.h1_ru"] = "Вставить заголовок.";

    strings["richtext.title.h2_ru"] = "Подзаголовок";
    strings["richtext.text.h2_ru"] = "Вставить подзаголовок.";

    strings["richtext.title.h3_ru"] = "Заголовок раздела";
    strings["richtext.text.h3_ru"] = "Вставить новый заголовок раздела.";

    strings["richtext.title.inserthorizontalrule_ru"] = "Горизонтальное правило";
    strings["richtext.text.inserthorizontalrule_ru"] = "Вставляет горизонтальное правило.";

    strings["richtext.title.color_ru"] = "Цвет шрифта";
    strings["richtext.text.color_ru"] = "Меняет цвет шрифта для выбранного текста.";

    strings["richtext.title.markupcolor_ru"] = "Цвет выделения текста";
    strings["richtext.text.markupcolor_ru"] = "Изменить цвет фона для выбранного текста.";

    strings["richtext.title.justifyleft_ru"] = "Выровнять текст по левому краю";
    strings["richtext.text.justifyleft_ru"] = "Выровнять текст по левому краю.";

    strings["richtext.title.justifycenter_ru"] = "Выровнять текст по центру";
    strings["richtext.text.justifycenter_ru"] = "Выровнять текст по центру.";

    strings["richtext.title.justifyright_ru"] = "Выровнять текст по правому краю";
    strings["richtext.text.justifyright_ru"] = "Выровнять текст по правому краю.";

    strings["richtext.title.indent_ru"] = "Отступ (Tab)";
    strings["richtext.text.indent_ru"] = "Отступ текста.";

    strings["richtext.title.outdent_ru"] = "Выступ (Shift+Tab)";
    strings["richtext.text.outdent_ru"] = "Выступ текста.";

    strings["richtext.title.createlink_ru"] = "Гиперссылка";
    strings["richtext.text.createlink_ru"] = "Сделать выделенный текст гиперссылкой.";

    strings["richtext.title.unlink_ru"] = "Удалить гиперссылку";
    strings["richtext.text.unlink_ru"] = "Убрать гиперсылку для выбранного текста.";

    strings["richtext.title.insertorderedlist_ru"] = "Список (нумерованный)";
    strings["richtext.text.insertorderedlist_ru"] = "Начать нумерованный список.";

    strings["richtext.title.insertunorderedlist_ru"] = "Маркированный список";
    strings["richtext.text.insertunorderedlist_ru"] = "Начать маркированный список.";

    strings["richtext.title.removeformat_ru"] = "Отменить форматирование";
    strings["richtext.text.removeformat_ru"] = "Отменяет все форматирование для выбранного текста.";

    strings['richtext.colormenu.defaultcolor_ru'] = 'Автоматический';

    strings['richtext.stub.more_ru'] = 'больше';
    strings['richtext.stub.less_ru'] = 'меньше';
    strings['richtext.stub.openprint_ru'] = 'Открыть вид для печати';

    strings['richtext.simpleeditingmodetitle_ru'] = 'Простой режим редактирования';
    strings['richtext.simpleeditingmodedesc_ru'] = 'Переключить к простому режиму редактирования';
    strings['richtext.simpleeditingmodewarning_ru'] = 'Усовершенствованные опции форматирования не доступны в простом режиме редактирования.Если Вы продолжите все существующие опции форматирования могут быть утеряны.';
    strings['richtext.notavailable.title_ru'] = "Усовершенствованные опции форматирования не доступны";
    strings['richtext.notavailable.warning_ru'] = "Усовершенствованный режим редактирования не поддерживается Вашим браузером.<br/>Если Вы продолжите, все существующие опции форматирования могут быть утеряны.";


    strings['richtext.link.address_ru'] = 'Пожалуйста, введите адрес:';
    strings['richtext.link.tooltip_ru'] = 'oткрыть с Ctrl+Click';


    // ComMed Translations
    strings['commed.expression.otherwise_ru'] = 'В другом случае';
    strings['commed.expression.manual_ru'] = 'Действие пользователя';
    strings['commed.expression.automaticrule_ru'] = 'Автоматическое правило для JavaScript';
    strings['commed.expression.jsrule_ru'] = 'JavaScript-Правило';
    strings['commed.expression.standarderror_ru'] = 'Стандартная ошибка';
    strings['commed.expression.exception_ru'] = 'Исключение';
    strings['commed.expression.exceptions_ru'] = 'Исключения';
    strings['commed.rolemapping.loadingroles_ru'] = 'Загрузка ролей';
    strings['commed.servicecall.and_ru'] = 'и';
    strings['commed.servicecall.aredefined_ru'] = 'определены.';
    strings['commed.servicecall.loadingformulars_ru'] = 'Загрузка формул.';
    strings['commed.servicecall.loadingmeasures_ru'] = 'Загрузка метрик...';


    strings['commed.servicecall.formulars_ru'] = 'Формулы';
    strings['commed.servicecall.performingsearch_ru'] = 'Поиск...';
    strings['commed.servicecall.nofound_ru'] = 'Метрик не найдено.';
    strings['commed.servicecall.nomeasuresselected_ru'] = 'Нет выбранных метрик.';
    strings['commed.servicecall.pleaseselect_ru'] = 'Пожалуйста, выберите метрику справа для того чтобы добавить к Вашему выбору.';
    strings['commed.servicecall.measure_ru'] = 'Метрика';
    strings['commed.servicecall.nowfv_ru'] = 'Нет определенных WFV.';
    strings['commed.servicecall.loadinginputs_ru'] = 'Загрузка вводов.';
    strings['commed.servicecall.noinputs_ru'] = 'Нет вводов.';
    strings['commed.servicecall.loadingoutputs_ru'] = 'Загрузка выводов.';
    strings['commed.servicecall.nooutputs_ru'] = 'Нет выводов.';
    strings['commed.servicecall.loadingservice_ru'] = 'Загрузка сервиса';
    strings['commed.servicecall.selectservice_ru'] = 'Пожалуйста, выберите сервис.';
    strings['commed.servicecall.remove_ru'] = 'Удалить';
    strings['commed.servicecall.parameteralert_ru'] = "Для этого аттрибута Вам необходимо определить 'Ссылку подпроцесса'. Пожалуйста, нажмите кнопку-плюс чтобы свзяать подпроцесс ";
    strings['commed.servicecall.selectboandservice_ru'] = 'Пожалуйста, выберите сервис и BO.';
    strings['commed.servicecall.noinputsinsub_ru'] = 'Нет определенных вводов в подпроцессах';
    strings['commed.servicecall.nooutputsinsub_ru'] = 'Нет определенных выводов в подпроцессах';
    strings['commed.servicecall.noserviceinsub_ru'] = 'Ссылаемый подпроцесс не имеет определенных сервисов';




    strings['attribute.mapper.loading_ru'] = "Загрузка";
    strings['attribute.mapper.stencilsets_ru'] = "типы диаграмм";
    strings['attribute.mapper.deselected_ru'] = "#{count} исключено элемента(-ов)";
    strings['attribute.mapper.attributes_selected_ru'] = "#{count} разных аттрибутов выбрано";
    strings['attribute.mapper.attributes_deselected_ru'] = "#{count} аттрибутов исключено";
    strings['attribute.mapper.selected_ru'] = "#{count} аттрибутов выбрано";
    strings['attribute.mapper.no_attributes_ru'] = "Нет доступных аттрибутов для этого языка моделирования.";
    strings['attribute.mapper.no_selection_ru'] = "Нет";
    strings['attribute.mapper.exclusion_active_ru'] = "Набор ограничений";
    strings['attribute.mapper.excluion_inactive_ru'] = "Нет набора ограничений";
    strings['attribute.mapper.list_ru'] = "List";

    strings['attribute.mapper.selected_ru'] = "#{count} выбрано";

    strings['attribute.mapper.untitled_group_ru'] = "Группа без заголовка";

    strings['attribute.mapper.config.all_attributes_ru'] = "Все аттрибуты";
    strings['attribute.mapper.config.own_attributes_ru'] = "Выбранные аттрибуты";
    strings['attribute.mapper.config.select_attributes_ru'] = "Выбрать аттрибуты";
    strings['attribute.mapper.config.all_elements_ru'] = "Все элементы";
    strings['attribute.mapper.config.flow_elements_ru'] = "Только элементы потока";
    strings['attribute.mapper.config.activities_ru'] = "Только действия";
    strings['attribute.mapper.config.select_elements_ru'] = "Выбрать элементы";

    strings['attribute.mapper.config.name_ru'] = "Название";
    strings['attribute.mapper.config.description_ru'] = "Пожалуйста, определите название и набор аттрибутов, которые должны учитываться в конвенциях.";

    strings['attribute.mapper.config.hide_empty_attributes_ru'] = "Спрятать аттрибуты без значения";
    strings['attribute.mapper.config.show_attribute_label_ru'] = "Показать аттрибуты без значения";
    strings['attribute.mapper.config.separate_labels_ru'] = "Разделить аттрибуты по";
    strings['attribute.mapper.config.separator_comma_ru'] = "Запятая";
    strings['attribute.mapper.config.separator_space_ru'] = "Пробел";
    strings['attribute.mapper.config.separator_linebreak_ru'] = "Разрыв строки";
    strings['attribute.mapper.config.list_style_ru'] = "Списки показаны как";
    strings['attribute.mapper.config.list_style_bullet_ru'] = "Маркированный список";
    strings['attribute.mapper.config.list_style_numbered_ru'] = "Нумерованный список";

    strings['attribute.mapper.config.main_properties_ru'] = "Основные свойства";
    strings['attribute.mapper.config.more_properties_ru'] = "Больше свойств";
    strings['attribute.mapper.config.meta_properties_ru'] = "Определенные свойства";

    strings['glossary.mapper.type.document_ru'] = "Документы";
    strings['glossary.mapper.type.org_unit_ru'] = "Организационные части";
    strings['glossary.mapper.type.it_system_ru'] = "IT системы";
    strings['glossary.mapper.type.activity_ru'] = "Дейтсвия";
    strings['glossary.mapper.type.state_ru'] = "События";

    strings['glossary.mapper.loading_groups_ru'] = "Загрузка групп словаря...";
    strings['glossary.mapper.all_categories_ru'] = "Все выбраны";
    strings['glossary.mapper.categories_chosen_ru'] = "выбрано";
    strings['glossary.mapper.select_all_ru'] = "Выбрать все";
    strings['glossary.mapper.select_none_ru'] = "Ничего не выбирать";

    strings['glossary.form.description_ru'] = "Следующие аттрибуты могут быть определены на разных языках. Пожалуйста, используйте выпадающий список сверху чтобы изменить язык.<br/>Учтите что заголовок должен быть определен хотя бы на одном языке.";

    strings['glossary.edit.title_ru'] = "Редактировать поле";
    strings['glossary.edit.save_ru'] = "Сохранить";
    strings['glossary.edit.description_ru'] = "Редактировать текущее поле словаря.";

    strings['glossary.new.title_ru'] = "Новое поле";
    strings['glossary.new.save_ru'] = "Создать";
    strings['glossary.new.create_ru'] = "Создать новое поле словаря.";

    strings['glossary.multilanguage.non_attributes_ru'] = "Следующие аттрибуты могут быть определены только на языке по умолчанию.";
    strings['glossary.multilanguage.copy_link_tt_ru'] = "Пожалуйста, обратите внимание, что все содержимое будет заменено новым содержимым.";
    strings['glossary.multilanguage.remove_origin_column_ru'] = "Спрятать левый столбец";
    strings['glossary.multilanguage.copy_link_title_ru'] = "Скопировать все содержимое";

    strings['glossary.view.title_ru'] = "Заголовок";
    strings['glossary.view.attachments_ru'] = "Соответствующие документы";
    strings['glossary.view.description_ru'] = "Описание";

    strings['propertyeditor.itsm.assignee.company_ru'] = "Компания";
    strings['propertyeditor.itsm.assignee.organization_ru'] = "Организация";
    strings['propertyeditor.itsm.assignee.group_ru'] = "Группа";

    strings['propertyeditor.itsm.location.region_ru'] = "Регион";
    strings['propertyeditor.itsm.location.sitegroup_ru'] = "Группа сайтов";
    strings['propertyeditor.itsm.location.site_ru'] = "сайт";

    strings['propertyeditor.itsm.servicecat.tier_ru'] = "Ярус {0}";

    strings['propertyeditor.itsm.productcat.name_ru'] = "Название";
    strings['propertyeditor.itsm.productcat.model_ru'] = "Модель";

    strings['propertyeditor.itsm.variablemapping.header.variable_ru'] = "Переменная";
    strings['propertyeditor.itsm.variablemapping.header.input_ru'] = "Ввод";
    strings['propertyeditor.itsm.variablemapping.header.output_ru'] = "Вывод";

    strings['propertyeditor.itsm.variablemapping.error.title_ru'] = "Слишком много переменных";
    strings['propertyeditor.itsm.variablemapping.error.message_ru'] = "Использовано слишком много переменных типа '{0}'.<br/>  Максимум: {1}.";

    strings['propertyeditor.itsm.condition.add_ru'] = "Добавить переменную...";

    strings['glossary.new.languageswitch_ru'] = "Язык";

    strings['language_bg_ru'] = "Болгарский";
    strings['language_cz_ru'] = "Чешский";
    strings['language_da_ru'] = "Датский";
    strings['language_nl_ru'] = "Голландский";
    strings['language_et_ru'] = "Эстонский";
    strings['language_fi_ru'] = "Финский";
    strings['language_fr_ru'] = "Французкий";
    strings['language_de_ru'] = "Немецкий";
    strings['language_el_ru'] = "Греческий";
    strings['language_hu_ru'] = "Венгерский";
    strings['language_ie_ru'] = "Ирландский";
    strings['language_it_ru'] = "Итальянский";
    strings['language_lv_ru'] = "Латышский";
    strings['language_lt_ru'] = "Литовский";
    strings['language_mt_ru'] = "Мальтийский";
    strings['language_pl_ru'] = "Польский";
    strings['language_pt_ru'] = "Португальский";
    strings['language_ro_ru'] = "Румынский";
    strings['language_sk_ru'] = "Словацкий";
    strings['language_sl_ru'] = "Словенский";
    strings['language_es_ru'] = "Испанский";
    strings['language_sv_ru'] = "Шведский";
    strings['language_mx_ru'] = "Испанский";
    strings['language_en_ru'] = "Английский";
    strings['language_lb_ru'] = "Люксембургский";
    strings['language_af_ru'] = "Африканский";

    strings['country_at_ru'] = "Австрия";
    strings['country_be_ru'] = "Бельгия";
    strings['country_bg_ru'] = "Болгария";
    strings['country_ch_ru'] = "Швейцария";
    strings['country_cz_ru'] = "Чехия";
    strings['country_dk_ru'] = "Дания";
    strings['country_gb_ru'] = "Великобритания";
    strings['country_nl_ru'] = "Нидерланды";
    strings['country_ee_ru'] = "Эстония";
    strings['country_fi_ru'] = "Финляндия";
    strings['country_fr_ru'] = "Франция";
    strings['country_de_ru'] = "Германия";
    strings['country_gr_ru'] = "Греция";
    strings['country_hu_ru'] = "Венгрия";
    strings['country_ie_ru'] = "Ирландия";
    strings['country_it_ru'] = "Италия";
    strings['country_lv_ru'] = "Латвия";
    strings['country_lt_ru'] = "Литва";
    strings['country_mt_ru'] = "Мальта";
    strings['country_pl_ru'] = "Польша";
    strings['country_pt_ru'] = "Португалия";
    strings['country_ro_ru'] = "Румыния";
    strings['country_sk_ru'] = "Словакия";
    strings['country_si_ru'] = "Словения";
    strings['country_es_ru'] = "Испания";
    strings['country_se_ru'] = "Швеция";
    strings['country_en_ru'] = "Англия";
    strings['country_mx_ru'] = "Мексика";
    strings['country_us_ru'] = "США";
    strings['country_lu_ru'] = "Люксембург";
    strings['country_za_ru'] = "Южная Африка";
    strings['country_br_ru'] = "Бразилия";
    strings['country_ca_ru'] = "Канада";
    strings['country_cl_ru'] = "Чили";
    strings['country_li_ru'] = "Лихтнштейн";
    strings['country_nz_ru'] = "Новая Зеландия";
    strings['coutnry_au_ru'] = "Австралия";

    //TODO
	strings['multilanguage.language.bg_ru'] = "Болгарский";
	strings['multilanguage.language.cz_ru'] = "Чешский";
	strings['multilanguage.language.dk_ru'] = "Датский";
	strings['multilanguage.language.nl_ru'] = "Голландский";
	strings['multilanguage.language.ee_ru'] = "Эстонский";
	strings['multilanguage.language.fi_ru'] = "Финский";
	strings['multilanguage.language.fr_ru'] = "Французкий";
	strings['multilanguage.language.de_ru'] = "Немецкий";
	strings['multilanguage.language.gr_ru'] = "Греческий";
	strings['multilanguage.language.hu_ru'] = "Венгерский";
	strings['multilanguage.language.ie_ru'] = "Ирландский";
	strings['multilanguage.language.it_ru'] = "Итальянский";
	strings['multilanguage.language.lv_ru'] = "Латышский";
	strings['multilanguage.language.lt_ru'] = "Литовский";
	strings['multilanguage.language.mt_ru'] = "Мальтийский";
	strings['multilanguage.language.pl_ru'] = "Польский";
	strings['multilanguage.language.pt_ru'] = "Португальский";
	strings['multilanguage.language.ro_ru'] = "Румынский";
	strings['multilanguage.language.sk_ru'] = "Словацкий";
	strings['multilanguage.language.si_ru'] = "Словенский";
	strings['multilanguage.language.es_ru'] = "Испанский";
	strings['multilanguage.language.se_ru'] = "Шведский";
	strings['multilanguage.language.mx_ru'] = "Испанский";
	strings['multilanguage.language.en_ru'] = "Английский";
	strings['multilanguage.language.lu_ru'] = "Люксембургский";
	strings['multilanguage.language.za_ru'] = "Африканский";

	strings['multilanguage.country.at_ru'] = "Австрия";
	strings['multilanguage.country.be_ru'] = "Бельгия";
	strings['multilanguage.country.bg_ru'] = "Болгария";
	strings['multilanguage.country.ch_ru'] = "Швейцария";
	strings['multilanguage.country.cz_ru'] = "Чехия";
	strings['multilanguage.country.dk_ru'] = "Дания";
	strings['multilanguage.country.gb_ru'] = "Великобритания";
	strings['multilanguage.country.nl_ru'] = "Нидерланды";
	strings['multilanguage.country.ee_ru'] = "Эстония";
	strings['multilanguage.country.fi_ru'] = "Финляндия";
	strings['multilanguage.country.fr_ru'] = "Франция";
	strings['multilanguage.country.de_ru'] = "Германия";
	strings['multilanguage.country.gr_ru'] = "Греция";
	strings['multilanguage.country.hu_ru'] = "Венгрия";
	strings['multilanguage.country.ie_ru'] = "Ирландия";
	strings['multilanguage.country.it_ru'] = "Италия";
	strings['multilanguage.country.lv_ru'] = "Латвия";
	strings['multilanguage.country.lt_ru'] = "Литва";
	strings['multilanguage.country.mt_ru'] = "Мальта";
	strings['multilanguage.country.pl_ru'] = "Польша";
	strings['multilanguage.country.pt_ru'] = "Португалия";
	strings['multilanguage.country.ro_ru'] = "Румыния";
	strings['multilanguage.country.sk_ru'] = "Словакия";
	strings['multilanguage.country.si_ru'] = "Словения";
	strings['multilanguage.country.es_ru'] = "Испания";
	strings['multilanguage.country.se_ru'] = "Швеция";
	strings['multilanguage.country.en_ru'] = "Англия";
	strings['multilanguage.country.mx_ru'] = "Мексика";
	strings['multilanguage.country.us_ru'] = "США";
	strings['multilanguage.country.lu_ru'] = "Люксембург";
	strings['multilanguage.country.za_ru'] = "Южная Африка";
	strings['multilanguage.country.br_ru'] = "Бразилия";
	strings['multilanguage.country.ca_ru'] = "Канада";
	strings['multilanguage.country.cl_ru'] = "Чили";
	strings['multilanguage.country.li_ru'] = "Лихтенштейн";
	strings['multilanguage.country.nz_ru'] = "Новая Зеландия";
	strings['multilanguage.country.au_ru'] = "Австралия";

	// IKS
	strings['iks.title_ru'] = "Риски и контроль";
	strings['iks.desc_ru'] = "Определите возможные риски и связанный контроль для элементов процесса.";
	strings['iks.windowapply_ru'] = "Применить";
	strings['iks.overlayhint_ru'] = "Пожалуйста, нажмите чтобы редактировать риск и контроли для этого элемента процесса.";
	strings['iks.toolbarname_ru'] = "Показать риски и контроль";
	strings['iks.toolbardesc_ru'] = "Показать риски и контроль для элементов процесса";
	strings['iks.risk_ru'] = "Риск";
	strings['iks.risks_ru'] = "Риски";
	strings['iks.control_ru'] = "Контроль";
	strings['iks.controls_ru'] = "Контроль";
	strings['iks.newentry_ru'] = "Пожалуйста, нажмите здесь чтобы создать {0}...";
	strings['iks.newentryrisk_ru'] = " новый риск ";
	strings['iks.newentrycontrol_ru'] = " новый контроль ";
	strings['iks.addcontrols_ru'] = "Добавить контроль";
	strings['iks.removerisk_ru'] = "Удалить этот риск";
	strings['iks.removecontrol_ru'] = "Удалить этот контроль";
	strings['iks.deletethistpl_ru'] = "Удалить этот ";
	strings['iks.deletethisrisk_ru'] = "риск и все связанные контроли?";
	strings['iks.deletethiscontrol_ru'] = "контроль?";
	strings['iks.yes_ru'] = "Да";
	strings['iks.no_ru'] = "Нет";
	strings['iks.globalrisks_ru'] = "Глобальные риски";

	
	
	Ext.ux.getLang = function(){
		return Ext.ux && Ext.ux.i18n && Ext.ux.i18n.Language ? Ext.ux.i18n.Language.split("_").first().toLowerCase() : "en";
	};
	
	/**
	 * Returns the internationalized string of
	 * its property.
	 * 
	 * @param {String} prop
	 * @return {String}
	 * 
	 */
	Ext.ux.getI18N = function(prop) {
		prop = (prop || "").toLowerCase();
		var lang = Ext.ux.getLang();
		return Ext.ux.i18n[prop + "_" + lang] || Ext.ux.i18n[prop] ||  strings[prop+"_"+lang] || strings[prop] || "";
	};
}();
/**
 *  utils.js
 *  (c) 2009 Signavio GmbH
 *
 *  @author Willi Tscheschner
 *
 *  Utils is a shared javascript file which provides common
 *  functionalities for all applications in the Signavio Process Editor
 *
 */

// define namespace
if(!window.Signavio){ window.Signavio = {}; }


(function(){

	window.ns = function(ns) {
		var packages = (ns || "").split(".");

		var createNS = function(current, packages) {
			var pack = packages.shift();

			if(!pack) {
				return;
			}

			if(pack === "Signavio") {
				return createNS(Signavio, packages);
			}

			if(!current[pack]) {
				current[pack] = {};
			}

			return createNS(current[pack], packages);
		};

		createNS(Signavio, packages);
	};

	ns("Utils");

	var _round = Math.round;

	Math.round = function(number, precision) {
		precision = Math.abs(parseInt(precision, 10)) || 0;
		var coefficient = Math.pow(10, precision);

		return _round(number * coefficient) / coefficient;
	};

	Element.addMethods({
		setWidth: function(element, width) {
			return Element.setStyle(element, {
				width: Ext.isNumber(width) ? width + "px" : width
			});
		},
		setHeight: function(element, height) {
			return Element.setStyle(element, {
				height: Ext.isNumber(height) ? height + "px" : height
			});
		}
	});

    if(!Array.prototype.randomElement) {
        Array.prototype.randomElement = function() {
            return this[Math.floor(Math.random() * this.length)];
        };
    }

    if(!document.viewport) {
		(function() {
			var IS_OLD_OPERA = Prototype.Browser.Opera &&
				(window.parseFloat(window.opera.version()) < 9.5);
			var ROOT = null;

			function getRootElement() {
				if (ROOT) {
					return ROOT;
				}

				ROOT = IS_OLD_OPERA ? document.body : document.documentElement;

				return ROOT;
			}

			document.viewport = {
				getWidth: function() {
					return getRootElement().clientWidth;
				},
				getHeight: function() {
					return getRootElement().clientHeight;
				}
			};
		}());
    }

	if(!Ext.isDefined) {
		Ext.isDefined = function(value) {
			return typeof value !== "undefined";
		};
	}

	if(!Ext.isNumber) {
		Ext.isNumber = function(value) {
			return typeof value === "number" && isFinite(value);
		};
	}

	var checkType = function(record, type) {
		if(!record) {
			return false;
		}

		return record.get("rel") === type;
	};

	Signavio.Utils.isModel = function(record) {
		return checkType(record, Signavio.Const.REL.MODEL);
	};

	Signavio.Utils.isDirectory = function(record) {
		return checkType(record, Signavio.Const.REL.DIRECTORY);
	};

	Signavio.Utils.isFile = function(record) {
		return checkType(record, Signavio.Const.REL.FILE);
	};

	Signavio.Utils.isTrashFolder = function(record, facade) {
		return facade.getTrashRecord() && record.get("href") === facade.getTrashRecord().get("href");
	};

	Signavio.Utils.isInternalFolder = function(record) {
		return record.get("rep").type === "internal";
	};

	Signavio.Utils.createForm = function(win, action, inputs) {
		var parent;

		if(win.contentDocument) {
			parent = win.contentDocument.body;
		} else {
			parent = win.document.body;
		}

		var securityParameter = $H(Ext.Ajax.getSecurityParameter()).map(function(hash){
			return ["input", {
				type: "hidden",
				value: hash.value,
				name: hash.key
			}];
		});

		return Signavio.Core.graft(null, Ext.isIE ? document.body : parent,
			["form", { action: action, method: "POST" }].concat(securityParameter, inputs)
		);
	};

	Signavio.Utils.getSecurityParameterField = function() {
		return $H(Ext.Ajax.getSecurityParameter()).map(function(entry) {
			return new Ext.form.TextField({
				name: entry.key,
				value: entry.value,
				inputType: "hidden"
			});
		})[0];
	};

	Signavio.Utils.getImagePath = function() {
	    if(window.Signavio && Signavio.Config) {
	        return Signavio.Config.IMAGE_PATH;
	    }

	    if(window.ORYX && ORYX.CONFIG) {
	        return ORYX.CONFIG.IMAGE_PATH;
	    }

	    return "";
	};

    /**
     * Creates and returns custom check functions for stencils.
     * Through closures, arrays do not have to be created every
     * time the function is called, but only once.
     */
	Signavio.Utils.getIdentityCheckFunction = function(ns) {
		return function(elements) {
            if(!(elements instanceof Array)) {
                elements = [elements];
            }

            elements = elements.map(function(element) {
                if(!element.startsWith(ns)) {
                    return ns + element;
                }

                return element;
            });

            return function(element) {
                return element && elements.include(element.getStencil().id());
            };
        };
	};

	var SEPARATOR = {
		DECIMAL: {
			en: ".",
			de: ","
		},
		GROUP: {
			en: ",",
			de: "."
		}
	};

	Signavio.Utils.getDecimalSeparator = function(locale, fallback) {
		locale = (locale || "").split("_").first();

		return SEPARATOR.DECIMAL[locale] || fallback || ".";
	};

	var toGroups = function(number, size) {
		if(!number) {
			return [];
		}

		var groupSize = number.length % size || size;
		var group = number.slice(0, groupSize);

		return [group].concat(toGroups(number.slice(groupSize), size));
	};

	if(!Number.prototype.toLocaleGroup) {
		Number.prototype.toLocaleGroup = function(locale) {
			var negative = "";

			if(this < 0) {
				negative = "-";
			}

			if(this < 1 && this > -1) {
				return negative + "0";
			}

			var string = this.toFixed(0).toString();

			if(this <= -1) {
				// remove the dash
				string = string.slice(1);
			}

			var separator = SEPARATOR.GROUP[locale] || " ";
			var groupSize = 3;

			var result = toGroups(string, groupSize);

			return negative + result.join(separator);
		};
	}

	if(!Number.prototype.toLocale) {
		Number.prototype.toLocale = function(locale) {
			locale = (locale || "").split("_").first();

			var string = this.toString();
			var characteristic = this.toLocaleGroup(locale);
			var mantissa = string.split(".")[1] || "";

			var decimal = SEPARATOR.DECIMAL[locale] || ".";

			if(mantissa) {
				return characteristic + decimal + mantissa;
			}

			return characteristic;
		};
	}

    Signavio.Utils.Request = {
        execute: function(url, options){
            var successcallback = options.success || Ext.emptyFn;
            var failedcallback = options.error || Ext.emptyFn;

            new Ajax.Request(url, {
                method      : options.method || 'get',
                parameters  : options.params,
                requestHeaders : {
                	'Accept': "application/json"
                },
                asynchronous: options.async === true,
                onSuccess: function(transport){
                    var json;
                    try {
                        json = transport.responseText.evalJSON();
                    } catch(e){
                        json = transport.responseText;
                    }

                    successcallback(json, transport);
                },
                onFailure: failedcallback,
                on409: options.on409,
                on403: options.on403
            });
        }
    };

    var MS_TO_SECOND = function(value) {
        return value / 1000;
    };

    var SECOND_TO_MS = function(value) {
        return value * 1000;
    };

    var MS_TO_MINUTE = function(value) {
        return MS_TO_SECOND(value) / 60;
    };

    var MINUTE_TO_MS = function(value) {
        return SECOND_TO_MS(value) * 60;
    };

    var MS_TO_HOUR = function(value) {
        return MS_TO_MINUTE(value) / 60;
    };

    var HOUR_TO_MS = function(value) {
        return MINUTE_TO_MS(value) * 60;
    };

    var MS_TO_DAY = function(value) {
        return MS_TO_HOUR(value) / 24;
    };

    var DAY_TO_MS = function(value) {
        return HOUR_TO_MS(value) * 24;
    };

    Signavio.Utils.MillisecondsToDays = function(ms) {
        var days = Math.floor(MS_TO_DAY(ms));

        var overflowDays = ms % DAY_TO_MS(1);

        var time = Signavio.Utils.MillisecondsToTime(overflowDays);

        return {
            days: days,
            hours: time.hours,
            minutes: time.minutes,
            seconds: time.seconds
        };
    };

    Signavio.Utils.DaysToMilliseconds = function(time) {
        if(time.split) {
            time = time.split(":");
        } else {
            time = time ? [time] : [];
        }

        var days = time[0] ? parseInt(time[0], 10) : 0;

        return DAY_TO_MS(days) + Signavio.Utils.TimeToMilliseconds(time.slice(1).join(":"));
    };

    Signavio.Utils.MillisecondsToTime = function(ms) {
    	var hours = Math.floor(MS_TO_HOUR(ms));

    	var overflowHours = ms % HOUR_TO_MS(1);
        var minutes = Math.floor(MS_TO_MINUTE(overflowHours));

        var overflowMinutes = ms % MINUTE_TO_MS(1);
        var seconds = Math.floor(MS_TO_SECOND(overflowMinutes));

        return {
            hours: hours < 10 ? "0" + hours : hours,
            minutes: minutes < 10 ? "0" + minutes : minutes,
            seconds: seconds < 10 ? "0" + seconds : seconds
        };
    };

    /**
     * Converts a time string to ms.
     * @param {String} time
     * @param {Boolean} notNegative if true the returned value cannot be smaller than 0
     */
    Signavio.Utils.TimeToMilliseconds = function(time, notNegative) {
    	time = time ? time.split(":") : [];

    	var hours = time[0] ? parseInt(time[0], 10) : 0;
    	var minutes = time[1] ? parseInt(time[1], 10) : 0;
    	var seconds = time[2] ? parseInt(time[2], 10): 0;
    	
        if (notNegative) {
    		return Math.max(HOUR_TO_MS(hours) + MINUTE_TO_MS(minutes) + SECOND_TO_MS(seconds), 0);
    	}
    	
        return HOUR_TO_MS(hours) + MINUTE_TO_MS(minutes) + SECOND_TO_MS(seconds);
    };

	Signavio.Utils.getLanguageDescriptor = function(rel) {
	    var language = rel.split("_").first();
	    var country = rel.split("_").last();

	    var imageSource = Signavio.Utils.getImagePath() + "/flags/" + country + ".png";

	    return "<img src='" + imageSource + "' /> "
	            + Ext.ux.getI18N('language_' + language)
	            + " (" + Ext.ux.getI18N('country_' + country) + ")";
	};

	Signavio.Utils.getLangaugeSelector = function(languages, options) {
	    return new Ext.ux.form.LanguageSelector(languages, options);
	};

    Signavio.Utils.getApplicationLanguage = function() {
        if(window.ORYX && ORYX.I18N.Language) {
            return ORYX.I18N.Language;
        }

        if(window.Signavio && Signavio.I18N.Language) {
            return Signavio.I18N.Language;
        }

        return "";
    };

	/**
	 * Splits the text by " " and \n and adds those
	 * strings to the resulting set of the tokenization
	 * @param {String} text The text which should be tokenized
	 */
	Signavio.Utils.tokenize = function(text) {
	    var token = text.split(" ");

	    token = token.map(function(t, i){
	        return i === 0 ? t : [" ", t];
	    }).flatten();

	    token = token.map(function(t){
	        var tn= t.split("\n");
	        return tn.map(function(tt, i){
	            return i === 0 ? tt : ["\n", tt];
	        }).flatten();
	    }).flatten();

	    return token.findAll(function(t){
	        return t;
	    });
	};

    Signavio.Utils.defer = function(fn, scope, timeout) {
        return window.setTimeout(function() {
            fn.apply(scope || this);
        }, timeout || 1);
    };

    Signavio.Utils.debounce = function(fn, scope, timeout) {
        var timer;

        return function() {
            if(timer) {
                window.clearTimeout(timer);
            }

            var args = arguments;

            timer = Signavio.Utils.defer(function() {
                fn.apply(scope || this, args);
            }, scope, timeout);
        };
    };

    Signavio.Utils.block = function(fn, scope) {
        var blocked = false;

        var release = function() {
            blocked = false;
        };

        return function() {
            if(blocked) {
                return;
            }

            blocked = true;

            var args = $A(arguments);

            fn.apply(scope || this, [release].concat(args));
        };
    };


    /**
     * Returns a callback that if called runs the given defaultFn as long 
     * as the timeout didn't happen. If a timeoutFn is given it will be
     * called in case the timeout happens and the defaultFn wasn't already executed.
     * Instead of a single function, defaultFn can contain an array of functions. Either
     * one of the given functions is executed before the timeout occurs or the timeout
     * function is executed. Be aware, that only one of the functions can be executed.
     *
     * @param {Function | Array} defaultFn - the function (array of functions) that shall be callable as long as the timeout didn't happen
     * @param {Function} timeoutFn - (optional) the function that will be called when the timeout happens
     * @param {Integer} timeout
     * @param {Object} scope
     */
    Signavio.Utils.timeOut = function(defaultFn, timeoutFn, timeout, scope) {
        var executed = false;
        var timer = Signavio.Utils.defer(function() {
            if (!executed) {
                executed = true;
                if (typeof timeoutFn === 'function') {
                    timeoutFn.apply(scope || this);
                }
            }
        }, scope, timeout);
        if (defaultFn instanceof Array) {
            return defaultFn.map(function(fn) {
                return function() {
                    if (!executed) {
                        executed = true;
                        window.clearTimeout(timer);
                        fn.apply(scope || this, arguments);
                    }
                };
            });
        } else {
            return function() {
                if (!executed) {
                    executed = true;
                    window.clearTimeout(timer);
                    defaultFn.apply(scope || this, arguments);
                }
            };
        }
    };

	/**
	 * Strips all none letter and digits
	 * out of the string
	 *
	 * @param {String} phrase
	 * @return {String}
	 */
	Signavio.Utils.strip = function(phrase){
		return phrase.toLowerCase()
					.replace(/[^a-zäöüß0-9]/g, '')
					.replace(/ü/g, 'u')
					.replace(/ä/g, 'a')
					.replace(/ö/g, 'o');
	};

	/**
	 * Returns true if a is in b included or other way around.
	 *
	 * @param {String} a
	 * @param {String} b
	 * @return {boolean}
	 */
	Signavio.Utils.isEqualTerms = function(a, b){

		// Check if initial values are equal
		if (a && b && (a.include(b) || b.include(a))){
			return true;
		}

		// Strip
		a = this.strip(a);
		b = this.strip(b);

		// Check if included
		return a && b && (a.include(b) || b.include(a));
	};

	/**
	 * Replace all common stings from string1 with those
	 * which are in the string2
	 *
	 * @param {String} string1
	 * @param {String} string2
	 * @param {int} cursor (Optional)
	 */
	Signavio.Utils.replaceCommonSubString = function(string1, string2, cursor) {

		// If string1 and string2 includes each other after stripingv
		var s1 = this.strip(string1);
		var s2 = this.strip(string2);
		if(s1 === s2 || s2.include(s1)){
			return string2;
		}

		// Get cursor pos
		var pos = cursor === undefined ? string1.length : cursor;
		// Tokenize
		var textT = this.tokenize(string1);
		var token = string2.split(/\s+/g); // Replace all special chars and split by " "

		// Get index of the token where the cursor is
		var selectedIndex = textT.indexOf(textT.find(function(t){
		    pos -= t === "\n" ? 0 : (t === " " ? 1 : t.length+1);
		    return pos <= 0;
		}));

		selectedIndex = Math.max(selectedIndex , 0);
		var rounds = textT.length;
		var found = false;

		// Go from the selected index to 0 and then up from the length of the textT to the selected index, but only one round
		for (var i=selectedIndex; i != selectedIndex+1 && rounds >= 0;  i == 0 ? i = textT.length -1 : --i, --rounds ){


			// If current text phrase is empty, go furhter
			if (textT[i] == " " || textT[i] == "\n") {
			    continue;
			}

			// Find the token from the suggestion
			var tok = token.find(function(t){
			    return this.isEqualTerms(t, textT[i]);
			}.bind(this));

			// If there is a suggested phrases
			if (tok) {
				found = true;
				// Partition all words to word which occur before and after this word
				var front = token.slice(0, token.indexOf(tok)).reverse();
				var back = token.slice(token.indexOf(tok)+1);
				// Replace current phrase with the word
				textT[i] = tok;

                var lastKnownIndex = i;

                // Go through every word which occurs before
				for (var j=i; j>=0; --j){
                    if (textT[j] == " " || textT[j] == "\n") {
                        continue;
                    }

                    tok = front.find(function(t){
                        return this.isEqualTerms(t, textT[j]);
                    }.bind(this));

					if (tok) {
						var index = front.indexOf(tok);
						textT[lastKnownIndex] = front.slice(0,index).reverse().join(" ") +(index >0?" ":"")+ textT[lastKnownIndex];

						lastKnownIndex = j;
						textT[j] = tok;
						front= front.slice(index+1);
					}
				}

                if (front.length >0){
				    textT[lastKnownIndex] = front.reverse().join(" ") + " " + textT[lastKnownIndex];
                }

				var lastKnownIndex = i;

                // Go through every word which occurs after
				for (var j=i; j<textT.length; j++){
                    if (textT[j] == " " || textT[j] == "\n") {
                        continue;
                    }

					tok = back.find(function(t){
					    return this.isEqualTerms(t, textT[j]);
					}.bind(this));

					if (tok) {
						var index = back.indexOf(tok);
						textT[lastKnownIndex] += (index>0?" ":"")+back.slice(0, index).join(" ");

						lastKnownIndex = j;
						textT[j] = tok;
						back = back.slice(index+1);
					}
				}

                if (back.length >0){
				    textT[lastKnownIndex] += " "+back.join(" ");
                }
				break;
			}

			if (selectedIndex === 0 && textT.length === 1){
			    break;
			}
		}

		var nString1 = textT.join("");

        if (nString1 == string1 && !found) {
            nString1 += (nString1.endsWith(" ") ? "" : " ") + string2;
        }
        return nString1;
	};


	/**
	 * Returns a string which is
	 * HTML unescaped.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	Signavio.Utils.unescapeHTML = function(str){

		str = str || "";

		var d = document.createElement("div");

		// IE8 does collapse all sequences of whitespaces into one single whitespace.
		// This changes the number of chars in the string, which messes up indices,
		// for instance in richtextHelper.js decode(). This workaround is from the comments in:
		// http://www.quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
		
		if (Ext.isIE8 || Ext.isIE7 || Ext.isIE6) {
			var whitespacePreservingElement = document.createElement("pre");
			d.appendChild(whitespacePreservingElement);
			whitespacePreservingElement.outerHTML = "<pre>" + str + "</pre>";
		} else {
			try {
			    d.innerHTML = str;
			} catch (e){
			    d.textContent = str;
			}
		}

		var nstr =  d.textContent || d.innerText || "";

		// Unescape the unecaped string till no changes are there
		return nstr && str && nstr !== str ? Signavio.Utils.unescapeHTML(nstr) : nstr;
	};

	/**
	 * Returns a string which is
	 * HTML escaped.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	Signavio.Utils.escapeHTML = function(str){

		str = String(str || "").replace(/</g, '&lt;');

		var d = document.createElement("div");
		try {
		    d.innerHTML = str;
		} catch (e){
			if (!!str.match(/&[aAoOuU]uml;/g)||!!str.match(/&szlig;/g)){
				$H({
				    "ä" : "&auml;",
				    "Ä" : "&Auml;",
				    "ö" : "&ouml;",
				    "Ö" : "&Ouml;",
				    "ü" : "&uuml;",
				    "Ü" : "&Uuml;",
					"ß" : "&szlig;"
				}).each(function(map){
				    str = str.gsub(map.value, map.key);
				});
			}
			try {
				d.innerHTML = str;
			} catch (ee) {
	 		   d.textContent = str;
			}
		}
		return d.innerHTML;
	};

	/**
	 * Evaluates a given string if it matches a local url (e.g. C:/... or //...)
	 * @returns with file prefix
	 */
	Signavio.Utils.evaluateLocalURL = function(value) {
		// Replace '/' to '\'
		value = (value||"").replace(/\\/g, "/");

		// FIND: C:...
		if (value.match(/^[A-Z]:[\/\\]/i)){
			value = "file:///" + value.replace(/^[A-Z]:/i, function(r){ return r.toUpperCase(); });

		// FIND: //...
		} else if (value.match(/^\/\/[^\/]/)){
			value = "file://///" + value.slice(2);
		}
		return value;
	};

	/**
	 * Return the value in the record
	 * for a given query.
	 * @param {Object} record Record
	 * @param {Object} query Query to extract the value (e.g. "rep.title")
	 */
	Signavio.Utils.extractValue = function(record, query){
		if( !record || !query ){
		    return null;
		}

		// Split data field
		var o = query.split(".");

		// Get value
		var val = record instanceof Ext.data.Record ? record.get(o[0]) : record[o[0]];
		var i	= 0;

		// Iterate over value since there is no
		// value of the end is reached
		while( val && ++i < o.length ){
			val = val[o[i]];
		}

		return typeof val == "string" ? val.unescapeHTML() : val;
	};

	/**
	 * Beautifies the given file size to Byte/KB/MB
	 * @params {Integer} size The size of the file in Bytes
	 * @returns {String}
	 */
	Signavio.Utils.BeautifySize = function(size) {
		if (size === undefined) return "";

		if ("number" !== typeof size) {
			size = Number(size);
			// If 0 or NaN
			if (!size) return "0 KB";
		}
		if (size < 1024) {
			return size + " Byte";
		} else if (size < Math.pow(1024,2)) {
			return Math.round(size * 10 / 1024) / 10 + " KB";
		} else {
			return Math.round(size * 10 / Math.pow(1024,2)) / 10 + " MB";
		}
	};

	/**
	 * Parses a Date from the date parameter and returns a pretty printable String.
	 *
	 * @param  {Date|String} dateMillis The date to pring
	 * @return {String}      Pretty printable date string
	 */
	Signavio.Utils.printDate = function(dateMillis) {
		var printDate = '', millis = dateMillis, date;

		if(typeof dateMillis === 'string') {
			dateMillis = parseInt(dateMillis, 10);
		}

		if(!isNaN(dateMillis)) {
			date = new Date(dateMillis);
			printDate = date.format(Signavio.Const.DATE_FORMAT);
		}

		return printDate;
	};

	/**
	 * Closure for business object sorting functions
	 */
	(function() {

		var sort = function(a, b, bottomUp) {
			if (!a || !b){
				return 0;
			}

			/**
			 * Fix for using the sorting function with things
			 */
			var get = function(x) {
				return this[x];
			};

			a.get = a.get || get;
			b.get = b.get || get;

			try {
				// Get the type
				var relA = a.get("rel").toLowerCase();
				var relB = b.get("rel").toLowerCase();

				// Mapping
				relA = ["ext", "att"].include(relA) ? "file" : relA;
				relB = ["ext", "att"].include(relB) ? "file" : relB;

				// If there are the same type
				if (relA == relB) {

					if (relA == "dir" && a.get("rep").type == "public"){ return -1; }
					if (relB == "dir" && b.get("rep").type == "public"){ return 1;  }

					var tA = (a.get("rep").name||a.get("rep").title||a.get("rep").username||-a.get("rep").rev||a.get("rep").label||a.get("rep").url||"");
					var tB = (b.get("rep").name||b.get("rep").title||b.get("rep").username||-b.get("rep").rev||b.get("rep").label||b.get("rep").url||"");

					// Return the sorting of the name values
					if ("string" == typeof tA && "string" == typeof tB){
						return Signavio.Utils.AlphaNumericComparator(tA, tB);
					}

					return (tA < tB ? -1 : (tA > tB ? 1 : 0));

				// Otherwise return the sorting of the type
				}

				// if bottomUp: mod > file > dir
				if (!!bottomUp){
					relA = relA == "mod" ? "a" : relA == "file" ? "b" : "c"+relA;
					relB = relB == "mod" ? "a" : relB == "file" ? "b" : "c"+relB;
				}
				// If not bottomUp: dir > mod > file
				else {
					relA = relA == "dir" ? "a" : relA == "mod" ? "b" : "c"+relA;
					relB = relB == "dir" ? "a" : relB == "mod" ? "b" : "c"+relB;
				}

				return (relA < relB ? -1 : (relA > relB ? 1 : 0));

			// ON Exception, do nothing
			} catch(e){
				return 0;
			}
		};

		/**
		 * Comparator between two strings
		 * It goes throught the string and creates groups of digits and groups of other strings.
		 * It than goes to this groups and compares the first discrepancy. For groups of digits
		 * a parseInt function get called previously.
		 * @param {string} a
		 * @param {string} b
		 * @return {number} -1,0,1
		 */
		Signavio.Utils.AlphaNumericComparator = function(a, b){

			a = String(a).toLowerCase().gsub("ä", "ae").gsub("ö", "oe").gsub("ü", "ue").replace(/([ ][ ]*)/g, " ").trim();
			b = String(b).toLowerCase().gsub("ä", "ae").gsub("ö", "oe").gsub("ü", "ue").replace(/([ ][ ]*)/g, " ").trim();

			// Get groups of digits and none digits
			var as = a.match(/([0-9]+|[^0-9]+)/g),
				bs = b.match(/([0-9]+|[^0-9]+)/g), ca, cb;

			// Compare each group with each other
			while((ca = as.shift()) && (cb = bs.shift())){
				// Parse int if the group only contains digits
				if (ca.match(/^([0-9]+)$/)) ca = Number(ca);
				if (cb.match(/^([0-9]+)$/)) cb = Number(cb);

				// If the values are diffent
				if (ca !== cb){

					// If the type of the values are different...
					if (typeof ca !== typeof cb){
						// ...sort numbers higher than strings
						return "number" == typeof ca ? -1 : 1;
					}

					// ...otherway, compare each values with each other
					return (ca < cb ? -1 : (ca > cb ? 1 : 0));
				}
			}

			// If one group has less different values than the other, sort them higher.
			return "undefined" == typeof ca && "undefined" == typeof cb ?
						  0
						:("undefined" == typeof ca ?
							  -1
							:("undefined" == typeof cb ?
									  1
									: 0));
		};


		/**
		 * Sorting function to sort folders, models and files in the correct way
		 * @param {Object} a
		 * @param {Object} b
		 * @return {int} Returns
		 */
		Signavio.Utils.BusinessObjectSortingFunction = function(a, b) {

			return sort(a,b, false);

		};

		/**
		 * Sorting function to sort folders, models and files bottom up
		 * @param {Object} a
		 * @param {Object} b
		 * @return {int} Returns
		 */
		Signavio.Utils.BottomUpBusinessObjectSortingFunction = function(a, b) {

			return sort(a,b, true);
		};
	}());

	(function() {
		/**
		 * Sets of characters with common width
		 */
		var _characterSets=[
    		"%W",
    		"@",
    		"m",
    		"wDGMOQÖ#+=<>~^",
    		"ABCHKNRSUVXZÜÄ&",
    		"bdghnopquxöüETY1234567890ß_§${}*´`µ€",
    		"aeksvyzäFLP?°²³",
    		"c-",
    		"rtJ\"/()[]:;!|\\",
    		"fjI., ",
    		"'",
    		"il"
    		];
		/**
		 * The width of the characters in the _characterSets
		 */
    	var _characterSetValues=[15,14,13,11,10,9,8,7,6,5,4,3];

    	/**
    	 * Calculates the width of a given character in font size 14
    	 * @param character
    	 * @returns
    	 */
    	var _estimateCharacterWidth = function(character) {

    		for(var i = 0; i < _characterSets.length; i++) {
     			if(_characterSets[i].indexOf(character) >= 0) {
    				return _characterSetValues[i];
    			}
     		}
    		return 9;
     	};

    	/**
    	 * Returns the estimated text width of the given string for the given font size (default to size 14).
    	 * @param {String} text
    	 * @param {Number} fontSize
    	 * @param {Boolean} round True to return an integer
    	 */
    	Signavio.Utils.estimateTextWidth = function(text, fontSize, round) {
    		if (!text) { return 0; }

    		var sum = 0.0;
    		for(var i = 0; i < text.length; ++i) {
    			sum += _estimateCharacterWidth(text.charAt(i));
    		}

    		sum = sum*((fontSize || 14) / 14.0);
    		return round ? Math.round(sum) : sum;
    	};

    	/**
    	 * Truncates the given text to the desired width and appends '...'.
    	 * @param {String} text
    	 * @param {Number} width
    	 * @param {Number} fontSize The font size of the given next, default is 14.
    	 */
    	Signavio.Utils.truncateTextToWidth = function(text, width, fontSize) {
    		if (!text || "number" !== typeof length) { return ""; }

    		var sum = 0.0;
    		var result = "";
    		var wasTruncated = $A(text).any(function(char, i) {
    			if (sum > width) { 
    				return true; 
    			}

    			// sum up the character widths
    			sum += _estimateCharacterWidth(text[i]) * ((fontSize || 14) / 14.0);
    			result += char;
    		});

    		return (wasTruncated ? result + "..." : result);
    	};

	}());


	/**
	 * Returns the width of HTML Element specified via selector
	 * @param {String} selector The HTML selector string (#string for id, .string for class, etc)
	 * @param {margins} Set true to include the margins
	 * @returns {Number}
	 */
	Signavio.Utils.getElementWidth = function(selector, margins) {
		var $el = Ext.DomQuery.select(selector||"")[0];
		if (!$el) { return 0; }
		// Use the sum function to prevent NaN
		return [$el.width||$el.clientWidth].concat(margins ? [$el.offsetLeft, $el.offsetRight] : []).sum();
	},


	/**
	 * Returns an icon for a given record or extension/file type name/namespace.
	 * @param {Object|String} arg Either an Object with rel, href, rep; a String or a record
	 * @param {Boolean} onlyIconName If true, only the name of the icon is returned, e.g. for use of css classes
	 * @param {String} format can be 12x12, 16x16 or 52x62
	 * @param {Boolean} sw Set true to get black/white images if available
	 */
	Signavio.Utils.getIcon = function(arg, onlyIconName, format, sw) {
		// If nothing is provided, link the s.gif
		if (!arg) {
			return onlyIconName && "undefined" || "/libs/ext-2.0.2/resources/images/default/s.gif";
		}

		// If the given argument is a data store record, parse the data
		if (arg.data && arg.data.rep) {
			arg = arg.data;
		}

		// Check if the given argument represents a record of a file or if it's a string
		if (["file", "mod"].include(arg.rel) || "string" == typeof (arg.extension || arg.namespace) || "string" == typeof arg) {

			// Get the extension name
			var extension = arg.rep && (arg.rep.extension || arg.rep.namespace) ||
							(arg.extension || arg.namespace) ||
							arg;

			var prefix	= "",
				suffix	= "",
				ending	= ".png",
				icon	= "";


			// The output format
			format = format || "16x16";

			// Get the path to the parent directory
			var image_path = Signavio && Signavio.Config && Signavio.Config.IMAGE_PATH || ORYX && ORYX.CONFIG && ORYX.CONFIG.IMAGE_PATH;
			if (!image_path) { return; }

			var imgBasePath = image_path;

			/** Format **/
			switch (format) {
			case "12x12":
				imgBasePath += "/signavio/12x12/";
				break;
			case "52x62":
				imgBasePath += "/signavio/52x62/";
				break;
			default:
				imgBasePath += "/famfamfam/page_white_";
			}

			// The path to the diagram icon directory
			var diagramImgBasePath = "/images/diagrams/";

			/** Files **/
			switch (extension) {
			// Pictures
			case "jpg":
			case "png":
			case "bmp":
			case "gif":
				icon = "picture";
				if (sw) icon += "_sw";
				break;
			// PDFs
			case "pdf":
				icon = "pdf";
				if (sw) icon += "_sw";
				break;
			// Archives
			case "zip":
			case "rar":
			case "war":
			case "sgx":
				icon = "zip";
				if (sw) icon += "_sw";
				break;
			// Word
			case "doc":
			case "docx":
				icon = "word";
				if (sw) icon += "_sw";
				break;
			// Excel
			case "xls":
			case "xlsx":
				icon = "excel";
				if (sw) icon += "_sw";
				break;
			// Powerpoint
			case "ppt":
			case "pptx":
				icon = "powerpoint";
				if (sw) icon += "_sw";
				break;

								/** Diagrams **/
			case "http://www.signavio.com/stencilsets/processmap#":
			case "processmap":
				imgBasePath = diagramImgBasePath;
				icon = "processmap";
				suffix = "-16x16-2";
				break;
			case "bpmn":
			case "http://b3mn.org/stencilset/bpmn2.0#":
			case "http://b3mn.org/stencilset/bpmn1.1#":
			case "http://b3mn.org/stencilset/bpmn2.0conversation#":
			case "http://b3mn.org/stencilset/bpmn2.0choreography#":
			case "http://b3mn.org/stencilset/jbpm4#":
				imgBasePath = diagramImgBasePath;
				icon = "bpmn";
				suffix = "-16x16-2";
				break;
			case "http://b3mn.org/stencilset/epc#":
			case "epc":
				imgBasePath = diagramImgBasePath;
				icon = "epc";
				suffix = "-16x16-2";
				break;
			case "http://www.signavio.com/stencilsets/organigram#":
//			case "http://b3mn.org/stencilset/UML2.2Class#":
				imgBasePath = diagramImgBasePath;
				icon = "organigram";
				suffix = "-16x16-2";
				break;

			case "dir":
				if (format == "16x16") {
					imgBasePath = image_path + "/nuvola/16x16/filesystems/";
					icon = "folder_grey";
					break;
				}
			default:
				if (extension.startsWith("http://")){ // <-- Stencilset
					imgBasePath = imgBasePath.slice(0, imgBasePath.length-1);

					if (onlyIconName) {
						icon = "empty";
					}

				} else {
					icon = "file";
					if (sw) icon += "_sw";
				}
			};

			return onlyIconName && icon || (imgBasePath + icon + suffix + ending);
		}

		/* Check if it's a model */
		/* Check if it's a directory */
		/* ... */
	};



	/**
	 * Converts all links from the text into HTML links.
	 * Link patterns are: http://www.google.de or www.google.de or //internal
	 * @param {String} text
	 * @return {String}
	 */
	Signavio.Utils.convertLinks = function(text){

		// Create a node out of the text
		var create = function(text){
			var node = document.createElement("body");
			node.innerHTML = text;
			return node;
		};

		// Iterate over all child nodes and
		// call the fn for each text node
		var forEach = function(fn, node){
			if (node && node.nodeType == 1){
				$A(node.childNodes).each(forEach.bind(this, fn));
			} else if (node && node.nodeType == 3){
				fn(node);
			}
		}

		// Replace the text content with the given reg exp
		var replace = function(text){
			var content = text.nodeValue, replaced = content;

			// Matches http://www.google.de/something?more#does
			if (content == replaced){
				replaced = content.replace(/([a-z]+:\/{2,5}([^\s\n<"]+))/ig, '<a href="$1" rel="external" target="_blank">$2</a>');
			}
			// Matches www.google.de/something?more#does or google.de/something?more#does
			if (content == replaced){
				replaced = content.replace(/(^|[\s\n<"])([a-z0-9\.]+\.[a-z]{2,3}(\/[^\s\n<"]+|))([\s\n<"]|$)/ig, '$1<a href="http://$2" rel="external" target="_blank">$2</a>$4');
			}

			// Matches C:\...
			if (content == replaced){
				replaced = content.replace(/([a-z]:[\/\\][^\/\\][^\s\n<"]+)/ig, function(match){
					var url = match.replace(/\\/g, "/");
					return '<a href="file:///'+url+'" rel="external" target="_blank">'+match+'</a>';
				});
			}

			// Matches //..
			if (content == replaced){
				replaced = content.replace(/([^\/])(\/\/[^\/][^\s\n<"]+)/ig, '$1<a href="file:///$2" rel="external" target="_blank">$2</a>');
			}

			// Replace (if changed)
			if (content !== replaced){
				var node = create(replaced),
					parent = text.parentNode,
					children = $A(node.childNodes);
				children.each(function(child){
					parent.insertBefore(child, text);
				});
				parent.removeChild(text);
				children.each(function(child){
					if (child.nodeType == 3){
						replace(child);
					}
				});
			}
		}.bind(this);


		var root = create(text);
		forEach(function(node){ replace(node); }, root);
		return root.innerHTML;
	};
	
	Signavio.Utils.registerNumberFormatterFunctions = function(formatter) {
		Number.prototype.toCurrency = function() {
			return formatter.formatCurrency(this);
		};

		Number.prototype.toFormatted = function() {
			return formatter.format(this);
		};

		var decimalFn = Signavio.Utils.getDecimalSeparator;
		Signavio.Utils.getDecimalSeparator = function() {
			if (arguments.length === 0) {
				return formatter.getDecimalSeparator();
			}
			
            return decimalFn.apply(Signavio.Utils, arguments);
	};

		Signavio.Utils.getGroupSeparator = function() {
			return formatter.getGroupSeparator();
		};
	};
	
	Signavio.Utils.NumberFormatter = function(config, currency) {
		var conf = (config && typeof config === "object") ? config : {};
		this._numberFormat = conf.numberFormat || "#,##0.###";
		this._currencyFormat = conf.currencyFormat || "#,##0.00 %C";
		this._decimalSeparator = conf.decimal || ",";
		this._groupSeparator = conf.group || ".";
		
		var cur = (currency && typeof currency === "object") ? currency : {};
		this._currencyCode = cur.id || "EUR";
		this._currencySign = cur.sign || "&euro;";
	};
	
	Signavio.Utils.NumberFormatter = Ext.extend(Signavio.Utils.NumberFormatter, {
		
		getDecimalSeparator : function() {
			return this._decimalSeparator;
		},
		
		getGroupSeparator : function() {
			return this._groupSeparator;
		},
		
		formatCurrency : function(number) {
			var formatted = this._formatFn(this._currencyFormat, number, this._decimalSeparator, this._groupSeparator);
			return formatted.gsub("%C", this._currencySign);
		}, 
		
		format : function(number) {
			return this._formatFn(this._numberFormat, number, this._decimalSeparator, this._groupSeparator);
		},
		
		/**
		 * This is the internal formatting function. It uses a format string, which defines, how 
		 * the number will be formatted. The format string can contain the following symbols:
		 * . - decimal separator
		 * , - group separator
		 * # - digit
		 * 0 - digit that will be filled with a zero if not existing
		 * ; - pattern separator to divide the positive and the negative pattern
		 * Moreover, the pattern can contain any other string content. 
		 * The definition of a negative pattern is optional. If no negative pattern is defined,
		 * a leading '-' will be used to indicate negative values. Both patterns are defined in one 
		 * string, first the positive pattern and afterwards the negative one, separated by a ';'.
		 * Example: "#,##0.###;-#,##0.###"
		 * 
		 * @param {String} mask - the format string
		 * @param {Number} value - the value to be formatted
		 * @param {String} decimal - the decimal separator
		 * @param {String} group - the group separator
		 */
		_formatFn : function(mask, value, decimal, group) {
			if (!mask || isNaN(+value)) {
		        return value; //return as it is.
		    }
			// process only abs(), and turn on flag.
		    var isNegative = value < 0 ? value = -value : 0; 
		    var hasNegativeMask = false;
		    // check if there is a special mask for negative values
		    mask = mask.split(';');
		    if (mask.length > 1 && isNegative) {
		    	mask = mask[1];
		    	hasNegativeMask = true;
		    } else {
		    	mask = mask[0];
		    }
		    // remember what is wrapped around the number
		    var completeMask = mask.replace(/[#,.0]+/g, '%N');
		    // and remove it
		    mask = mask.replace(/[^#,.0]+/g, '');
		    
		    // split the decimal for the format string if any.
		    var mask = mask.split('.')
		    // Fix the decimal first, toFixed will auto fill trailing zero.
		    // toFixed(null) will create integer
		    value = value.toFixed( mask[1] && mask[1].length);
		    // convert number to string to trim off *all* trailing decimal zero(es)
		    value = +(value) + ''; 

		    // fill back any trailing zero according to format
		    var iTailZero = mask[1] && mask[1].lastIndexOf('0'); //look for last zero in format
		    var part = value.split('.');
		    // integer will get !part[1]
		    if (!part[1] || part[1] && part[1].length <= iTailZero) {
		    	// convert to number and then fix size of tail again
		        value = (+value).toFixed( iTailZero + 1);
		    }
		    // look for group separator
		    var groups = mask[0].split(',');
		    // join back without separator for counting the pos of any leading 0.
		    mask[0] = groups.join(''); 

		    // check how many leading zeroes there shall be
		    var iFrontZero = mask[0] && mask[0].indexOf('0');
		    if (iFrontZero > -1 ) {
		        while (part[0].length < (mask[0].length - iFrontZero)) {
		        	// add missing zero to the front
		            part[0] = '0' + part[0];
		        }
		    } else if (+part[0] == 0) {
		        part[0] = '';
		    }
		    
		    value = value.split('.');
		    value[0] = part[0];
		    
		    // process the first group separator from decimal (.) only, the rest ignore.
		    // get the length of the last slice of split result.
		    var iSep = ( groups[1] && groups[groups.length - 1].length);
		    if (iSep) {
		    	// found a group separator
		        var integer = value[0];
		        var str = '';
		        var offset = integer.length % iSep;
		        for (var i = 0, l = integer.length; i < l; i++) { 
		        	// ie6 only support charAt for sz.
		            str += integer.charAt(i); 
		            // check if a group separator needs to be added
		            // calculate -iSep so that the separator isn't added to the end
		            if (!((i - offset + 1) % iSep) && i < l - iSep) {
		                str += group;
		            }
		        }
		        value[0] = str;
		    }
		    // just add the fraction if it is demanded
		    value[1] = (mask[1] && value[1]) ? decimal + value[1] : "";
		    // check negation
		    if (isNegative && !hasNegativeMask) {
		    	// a normal negative value, just add the leading '-'
		    	value = '-' + value[0] + value[1];
		    } else {
		    	// the value is positive or has a special mask for negative values
		    	value = value[0] + value[1]; 
		    }
		    // fill the formatted value back in the complete mask
		    return completeMask.gsub('%N', value);
		}
	});
	
	/**
	 * Generates a UUID based on (pseudo) random numbers as defined in RFC 4122.
	 * 
	 * @param {Boolean} useHyphens - indicates whether the generated UUID should contain hyphens
	 * @param {Boolean} omitPrefix - indicates whether the generated UUID should omit the pref "sid-"
	 */
	Signavio.Utils.generateUUID = function(useHyphens, omitPrefix) {
		// http://www.ietf.org/rfc/rfc4122.txt
	    var s = [];
	    var hexDigits = "0123456789abcdef";
	    for (var i = 0; i < 36; i++) {
	        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
	    }
	    s[14] = "4";  // bits 12-15 of the time_hi_and_version field to 0010
	    s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01
	    s[8] = s[13] = s[18] = s[23] = !!useHyphens ? "-" : "";
	    var uuid = s.join("");
	    	
	    return !!omitPrefix ? uuid : "sid-" + uuid;
	};
	
	/**
	 * Calculates the perceived brightness of a color.
	 * 
	 * @param color
	 * @returns a value between 0 (black) and 255 (white) indicating the brightness
	 */
	Signavio.Utils.getPerceivedBrightness = function(color) {
		var hexColor = color.gsub("#", "");
		var r, g, b;
		if (hexColor.length === 3) {
			r = parseInt(hexColor[0].concat(hexColor[0]), 16);
			g = parseInt(hexColor[1].concat(hexColor[1]), 16);
			b = parseInt(hexColor[2].concat(hexColor[2]), 16);
		} else if (hexColor.length === 6) {
			r = parseInt(hexColor.substring(0, 2), 16);
			g = parseInt(hexColor.substring(2, 4), 16);
			b = parseInt(hexColor.substring(4, 6), 16);
		} else {
			// default value, just assume it's black
			return 0;
		}
		// this is a weighted formula following the example here:
		// http://www.nbdtech.com/Blog/archive/2008/04/27/Calculating-the-Perceived-Brightness-of-a-Color.aspx			
		return Math.round(Math.sqrt((r * r * 0.241) + (g * g * 0.691) + (b * b * 0.068)));
	};
}());
/**
 * Copyright (c) 2012
 * Lukas Brand
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

/**
 * Define namespaces
 */
if (!window.Ext) { window.Ext = {}; }
if (!Ext.ux) { Ext.ux = {}; }

(function() {
	Ext.ux.Window = function(options) {
		
		options = options||{};
		
		var title = options.frameTitle;
		
		/************ OPTIONS FOR THE WINDOW *****************/
		options.height		= options.height 		|| "auto";
		options.width		= options.width 		|| "auto";
		options.title		= options.title			|| "";
		options.description	= options.description	|| "";
		options.bodyStyle	= options.bodyStyle		|| "padding:10px;background:white;";
		options.layout		= options.layout		|| "anchor";
		options.cls			= "x-ux-window " + ("string" === typeof options.cls ? options.cls : "");

		if(options.useFrame) {
			options.cls += " y-wizard";
		}

		options.minButtonWidth = options.minButtonWidth || 75;
		
		options.cancelButton= options.cancelButton	|| {}; 
		options.noLinkButton= options.noLinkButton	|| false;
		options.hideCancelButton = options.hideCancelButton || false;
		options.cancelText = options.cancelText  || Ext.MessageBox.buttonText.cancel;
		
		var cancelButtonCfg = {
			text 	: options.cancelText,
			cls 	: "x-button-plain",
			handler : function(){								
				// Close the Window
				if (options.closeAction === "hide") {
					this.hide();
				} else {	
					this.close();
				}
			}.bind(this)
		};
		
		var cancelButton;
		// If the noLinkButton flag is not set, display the cancel button as a link
		if (!options.noLinkButton) {
			cancelButton = new Signavio.ux.dialog.Link(cancelButtonCfg);
		} else {
			cancelButton = new Ext.Button(cancelButtonCfg);
		}

		// If a cancel button is provided, it gets enhanced to be a link button
		if (options.cancelButton) {
			cancelButtonCfg = Ext.apply(cancelButtonCfg, options.cancelButton);
		}
		
		// Prepend the cancel button
		if (!options.hideCancelButton) {
			options.buttons = [].concat(cancelButton).concat(options.buttons||[]);
		}

		//	THE ITEMS FOR THE WINDOW ITSELF
		options.items 		= [].concat(
		//	ADD THE WINDOW DESCRIPTION
			(options.description ?
					new Ext.form.Label({
						style	: "background:white;display:block;" + options.useFrame ? "margin-top:0;" : "",
						html	: options.description
					}) : [])
		)
		// ADD THE CONTENT FRAME
		.concat(
			(!options.useFrame ? (options.items||[new Ext.form.Label()]) :
				new Ext.ux.view.OptionsContainer({
					title		: title,
					autoHeight	: true,
					desc		: options.frameDescription,
					style		: "margin: 10px 0 0 0",
					bodyStyle	: "padding: 0",
					items		: options.items
				}))
		);
		
		var listeners = Object.clone(options.listeners);
		
		options.listeners = Ext.apply({}, {
			show	: function() {
				this.syncSize();
				if (listeners && "function" == typeof listeners.show){
					listeners.show.apply(this, arguments);
				}
			},
			specialkey : function(e) {
				if (e.getKey() === e.ESC) {
					if (options.onEsc instanceof Function) {
						options.onEsc();
					} else {
						this.handler.apply(this, arguments);
						e.stopEvent();	
					}
				}
			}
		}, listeners);
		
		Ext.ux.Window.superclass.constructor.call(this, options);
	};
	
	Ext.extend(Ext.ux.Window, Ext.Window, {
		
	});
}());
/**
* Copyright by Fabian Dill, 2010
* Licensed under the MIT License (http://www.opensource.org/licenses/mit-license.php).
* 
* This script was written by Fabian Dill and published
* at http://informationandvisualization.de
* 
* If you use it, it would be nice if you link to our page
* and/or drop us a line where you use it (for our interest only).
* to fabian.dill(at)googlemail.com
*/
var lowerWhisker;
var q1;
var median;
var q3;
var upperWhisker;
var mildOutliers;
var extremeOutliers;
var min;
var max;

function sortNumber(a, b) {
	return a - b;
}

// map the values onto a scale of fixed height
function mapValue(v, height) {
	return Math.round(height - (((v - min) / (max - min)) * height));
}

function calculateValues(data) {
	data.sort(sortNumber);
	var n = data.length;
	// lower quartile
	var q1Pos = (n * 0.25);
	if (q1Pos % 1 != 0) {
	    q1Pos = Math.floor(q1Pos);
	    q1 = data[q1Pos];
	} else {
	    q1Pos = Math.floor(q1Pos);
	    q1 = (data[q1Pos] + data[q1Pos-1]) / 2;
	}
	// median
	var medianPos = (n * 0.5);
	if (medianPos % 1 != 0) {
	    medianPos = Math.floor(medianPos);
	    median = data[medianPos];
	} else {
	    medianPos = Math.floor(medianPos);
	    median = (data[medianPos] + data[medianPos-1]) / 2;
	}
	// upper quartile
	var q3Pos = (n * 0.75);
	if (q3Pos % 1 != 0) {
	    q3Pos = Math.floor(q3Pos);
	    q3 = data[q3Pos];
	} else {
	    q3Pos = Math.floor(q3Pos);
	    q3 = (data[q3Pos] + data[q3Pos-1]) / 2;
	}	
	min = data[0];
	max = data[n - 1];
	
	var iqr = q3 - q1;
	mildOutliers = new Array();
	extremeOutliers = new Array();
	lowerWhisker = min;
	upperWhisker = max;
	if (min < (q1 - 1.5 * iqr)) {
		for (var i = 0; i < q1Pos; i++) {
			// we have to detect outliers
			if (data[i] < (q1 - 3 * iqr)) {
				extremeOutliers.push(data[i]);
			} else if (data[i] < (q1 - 1.5 * iqr)) {
				mildOutliers.push(data[i]);
			} else if (data[i] >= (q1 - 1.5 * iqr)) {
				lowerWhisker = data [i];
				break;
			}
		}
	}
	if (max > (q3 + (1.5 * iqr))) {
		for (i = q3Pos; i < data.length; i++) {
			// we have to detect outliers
			if (data[i] > (q3 + 3 * iqr)) {
				extremeOutliers.push(data[i]);
			} else if (data[i] > (q3 + 1.5 * iqr)) {
				mildOutliers.push(data[i]);
			} else if (data[i] <= (q3 + 1.5 * iqr)) {
				upperWhisker = data[i];
			}
		}
	}
}

function roundVal(val){
	var dec = 2;
	var result = Math.round(val*Math.pow(10,dec))/Math.pow(10,dec);
	return result;
}

function createBoxPlot(dataArray, height, divID) {
	calculateValues(dataArray);
	var overallID = divID + "overall";

	var mlowerWhisker = mapValue(lowerWhisker, height);
	var mq1 = mapValue(q1, height);
	var mmedian = mapValue(median, height);
	var mq3 = mapValue(q3, height);
	var mupperWhisker = mapValue(upperWhisker, height);
	var mmildOutliers = new Array(mildOutliers.length);
	for (i = 0; i < mildOutliers.length; i++) {
		mmildOutliers[i] = mapValue(mildOutliers[i], height);
	}
	var mextremeOutliers = extremeOutliers;
	for (i = 0; i < extremeOutliers.length; i++) {
		mextremeOutliers[i] = mapValue(extremeOutliers[i], height);
	}
  
  var overallDiv = document.createElement("div");
	overallDiv.style.height = height + "px";
	overallDiv.style.width = "56px";
	overallDiv.style.border = "none";
	overallDiv.style.borderRight = "1px dotted";
	overallDiv.id = overallID;
	document.getElementById(divID).appendChild(overallDiv);

	var upperDiv = document.createElement("div");
	upperDiv.id = "upperBox" + divID;
	upperDiv.className = "boxplot-element";
	upperDiv.style.top = mq3 + "px";
	upperDiv.style.height = (mmedian - mq3) + "px";
	document.getElementById(overallID).appendChild(upperDiv);

	var lowerDiv = document.createElement("div");
	lowerDiv.id = "lowerBox" + divID;
	lowerDiv.className = "boxplot-element";
	lowerDiv.style.top = mmedian + "px";
	lowerDiv.style.height = mq1 - mmedian + "px";
	document.getElementById(overallID).appendChild(lowerDiv);

	var lowerWhiskerDiv = document.createElement("div");
	lowerWhiskerDiv.id = "lowerWhisker" + divID;
	lowerWhiskerDiv.className = "boxplot-element";
	lowerWhiskerDiv.style.top = mlowerWhisker + "px";
	document.getElementById(overallID).appendChild(lowerWhiskerDiv);
	
	var upperWhiskerDiv = document.createElement("div");
	upperWhiskerDiv.id = "upperWhisker" + divID;
	upperWhiskerDiv.className = "boxplot-element";
	upperWhiskerDiv.style.top = mupperWhisker + "px";
	document.getElementById(overallID).appendChild(upperWhiskerDiv);

	for(i = 0; i < mildOutliers.length; i++) {
		var newDiv = document.createElement("div");
		newDiv.className = "boxplot-element";
		newDiv.style.width="4px";
		newDiv.style.height="4px";
		newDiv.style.top = mmildOutliers[i] + "px";
		newDiv.style.left= "50px";
		document.getElementById(overallID).appendChild(newDiv);
	}
	for(i = 0; i < extremeOutliers.length; i++) {
		var newDiv = document.createElement("div");
		newDiv.className = "boxplot-element";
		newDiv.style.background = "#666";
		newDiv.style.width="4px";
		newDiv.style.height="4px";
		newDiv.style.top = mextremeOutliers[i] + "px";
		newDiv.style.left= "50px";
		document.getElementById(overallID).appendChild(newDiv);
	}
	// labels
	var lowerLabel = document.createElement("div");
	lowerLabel.className = "boxplot-label";
	lowerLabel.innerHTML = "" + roundVal(lowerWhisker);
	lowerLabel.style.top = mlowerWhisker + "px";
	lowerLabel.style.left = "0px";
	document.getElementById(overallID).appendChild(lowerLabel);
	
	var q1Label = document.createElement("div");
	q1Label.className = "boxplot-label";
	q1Label.innerHTML = "" + roundVal(q1);
	q1Label.style.top = (mq1 - 9) + "px";
	q1Label.style.left = "80px";
	document.getElementById(overallID).appendChild(q1Label);
	
	var medianLabel = document.createElement("div");
	medianLabel.className = "boxplot-label";
	medianLabel.innerHTML = "" + roundVal(median);
	medianLabel.style.top = (mmedian - 9) + "px";
	medianLabel.style.left = "0px";
	document.getElementById(overallID).appendChild(medianLabel);
	
	var q3Label = document.createElement("div");
	q3Label.className = "boxplot-label";
	q3Label.innerHTML = "" + roundVal(q3);
	q3Label.style.top = (mq3 - 9) + "px";
	q3Label.style.left = "80px";
	document.getElementById(overallID).appendChild(q3Label);
	
	var upperLabel = document.createElement("div");
	upperLabel.className = "boxplot-label";
	upperLabel.innerHTML = "" + roundVal(upperWhisker);
	upperLabel.style.top = (mupperWhisker - 9) + "px";
	upperLabel.style.left = "0px";
	document.getElementById(overallID).appendChild(upperLabel);
	
	for (i = 0; i < mmildOutliers.length; i++) {
		var label = document.createElement("div");
		label.className = "boxplot-label";
		label.innerHTML = "" + roundVal(mildOutliers[i]);
		label.style.top = (mmildOutliers[i] - 9) + "px";
		if (i%2 == 0) {
			label.style.left = "10px";
		} else {
			label.style.left = "70px";
		}
		document.getElementById(overallID).appendChild(label);
	}	
}
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.kpi){ Ext.ux.kpi = {}; }

new function() {
	
	Ext.ux.kpi.KpiPanel = Ext.extend(Ext.Panel,  {
		
		constructor: function(config, facade, panelConfig){
			this.facade = facade;
			
			//KPI configuration
			this.init();
			
			
			Ext.apply(this.conf, config, {});
			
			Ext.ux.kpi.KpiPanel.superclass.constructor.apply(this, [panelConfig||{}]);
		},
		
		/**
		 * Initial KPI configuration
		 */
		init: function() {
			this.conf = {
				name: "KPI-Name",
				unit: "",
				minVal: 0,
				maxVal: 0,
				range: 0,
				value: 0,
				badStart: 0,
				badWidth: 30,
				thresStart: 30,
				thresWidth: 30,
				goodStart: 60,
				goodWidth: 40,
				kpiMinVal: 30,
				kpiGoodVal: 50,
				kpiTargetVal: 70,
				kpiMinValPos: undefined,
				kpiGoodValPos: undefined
			};
			
			/*
			 * Forcing recreation of Element on refresh
			 */
			this.forceRecreation = false;
			
			//Container
			this.kpiTextCt = undefined;
			this.kpiCt = undefined;
			
			//Div-Boxes
			this.kpiComp = undefined; //Top-Parent container
			this.kpiBadBox = undefined;
			this.kpiThresBox = undefined;
			this.kpiGoodBox = undefined;
			this.kpiMiddleLane = undefined;
			this.kpiValueLane = undefined;
			this.kpiTargetMarker = undefined;
			this.kpiBorder = undefined;
			
			//Caption Boxes
			this.kpiName = undefined;
			this.kpiTargetValue = undefined;
			this.kpiGoodValue = undefined;
			this.kpiMinValue = undefined;
			this.kpiValue = undefined;
			
			//Values
			//Caption
			this.kpiNameText = "iniKpiName";
			this.kpiValueText = "iniKpiValue";
			this.kpiMinValueText = "iniMinValue";
			this.kpiGoodValueText = "iniGoodValue";
			this.kpiTargetValueText = "iniTargetValueText";
			
			//Box params
			this.kpiBadBoxStart = 0;
			this.kpiBadBoxWidth = 30;
			this.kpiThresBoxStart = 30;
			this.kpiThresBoxWidth = 30;
			this.kpiGoodBoxStart = 60;
			this.kpiGoodBoxWidth = 40;
			this.kpiTargetMarkerPos = 80;
			this.kpiValueLaneWidth = 50;
			
			this.kpiGoodValPos = undefined;
			this.kpiMinValPos = undefined;
			
		},
		
		_initializeElements: function()	{
			if(this.forceRecreation || !this.kpiCt) {
				this.kpiCt = new Ext.Element(document.createElement('div'));
				this.kpiCt.addClass('x-analytics-kpi-ct');
			}
			
			if(this.forceRecreation || !this.kpiTextCt) {
				this.kpiTextCt = new Ext.Element(document.createElement('div'));
				this.kpiTextCt.addClass('x-analytics-kpi-textct');
			}
			
			if(this.forceRecreation || !this.kpiComp) {
				this.kpiComp = new Ext.Element(document.createElement('div'));
				this.kpiComp.addClass('x-analytics-kpi-comp');
			}
			
			if(this.forceRecreation || !this.kpiBadBox) {
				this.kpiBadBox = new Ext.Element(document.createElement('div'));
				this.kpiBadBox.addClass('x-analytics-kpi-badbox');
			}
			
			if(this.forceRecreation || !this.kpiThresBox) {
				this.kpiThresBox = new Ext.Element(document.createElement('div'));
				this.kpiThresBox.addClass('x-analytics-kpi-thresbox');
			}
			
			if(this.forceRecreation || !this.kpiGoodBox) {
				this.kpiGoodBox = new Ext.Element(document.createElement('div'));
				this.kpiGoodBox.addClass('x-analytics-kpi-goodbox');
			}
			
			if(this.forceRecreation || !this.kpiMiddleLane) {
				this.kpiMiddleLane = new Ext.Element(document.createElement('div'));
				this.kpiMiddleLane.addClass('x-analytics-kpi-middlelane');
			}
			
			if(this.forceRecreation || !this.kpiValueLane) {
				this.kpiValueLane = new Ext.Element(document.createElement('div'));
				this.kpiValueLane.addClass('x-analytics-kpi-valuelane');
			}
			
			if(this.forceRecreation || !this.kpiTargetMarker) {
				this.kpiTargetMarker = new Ext.Element(document.createElement('div'));
				this.kpiTargetMarker.addClass('x-analytics-kpi-targetmarker');
			}
			
//			if(this.forceRecreation || !this.kpiBorder) {
//				this.kpiBorder = new Ext.Element(document.createElement('div'));
//				this.kpiBorder.addClass('x-analytics-kpi-border');
//			}
			
			
			//Caption-Fields
			if(this.forceRecreation || !this.kpiName) {
				this.kpiName = new Ext.Element(document.createElement('span'));
				this.kpiName.addClass('x-analytics-kpi-name');
			}
			
			if(this.forceRecreation || !this.kpiTargetValue) {
				this.kpiTargetValue = new Ext.Element(document.createElement('span'));
				this.kpiTargetValue.addClass('x-analytics-kpi-targetvalue');
			}
			
			if(this.forceRecreation || !this.kpiGoodValue) {
				this.kpiGoodValue = new Ext.Element(document.createElement('span'));
				this.kpiGoodValue.addClass('x-analytics-kpi-goodvalue');
			}
			
			if(this.forceRecreation || !this.kpiMinValue) {
				this.kpiMinValue = new Ext.Element(document.createElement('span'));
				this.kpiMinValue.addClass('x-analytics-kpi-minvalue');
			}
			
			if(this.forceRecreation || !this.kpiValue) {
				this.kpiValue = new Ext.Element(document.createElement('span'));
				this.kpiValue.addClass('x-analytics-kpi-value');
			}
		},	
		
		_setupHierarchy: function() {
			if(this.kpiComp.parent()) {
				return;
			}
			
			//Value progress bar
			this.kpiMiddleLane.appendChild(this.kpiValueLane);
			
			// Top parent childs
			this.kpiComp.appendChild(this.kpiBadBox);
			this.kpiComp.appendChild(this.kpiThresBox);
			this.kpiComp.appendChild(this.kpiGoodBox);
			this.kpiComp.appendChild(this.kpiMiddleLane);
//			this.kpiComp.appendChild(this.kpiBorder);
			this.kpiComp.appendChild(this.kpiTargetMarker);
			
			// Text elements
			this.kpiTextCt.appendChild(this.kpiName);
			this.kpiTextCt.appendChild(this.kpiMinValue);
			this.kpiTextCt.appendChild(this.kpiGoodValue);
			this.kpiTextCt.appendChild(this.kpiTargetValue);
			this.kpiTextCt.appendChild(this.kpiValue);
			
			this.kpiCt.appendChild(this.kpiTextCt);
			this.kpiCt.appendChild(this.kpiComp);
			
			this.body.appendChild(this.kpiCt);
		},
		
		_setText: function(el, text) {
			el.dom.innerText = text;
			el.dom.textContent = text;
		},
		
		/**
		 * Updates the KPI visualisation
		 */
		updateVis: function() {
			//VARs
			var textRelOffset = 65 / 20; // width text box and kpi box
			
			// Update Captions
			this._setText(this.kpiName, this.kpiNameText);
			this._setText(this.kpiTargetValue, this.kpiTargetValueText);
			this._setText(this.kpiGoodValue, this.kpiGoodValueText);
			this._setText(this.kpiMinValue, this.kpiMinValueText);
			this._setText(this.kpiValue, this.kpiValueText);
			
			//Adjust Element positions
			this.kpiBadBox.applyStyles({left:this.kpiBadBoxStart + "%", width:this.kpiBadBoxWidth + "%"});
			this.kpiThresBox.applyStyles({left:this.kpiThresBoxStart + "%", width:this.kpiThresBoxWidth + "%"});
			this.kpiGoodBox.applyStyles({left:this.kpiGoodBoxStart + "%", width:this.kpiGoodBoxWidth + "%"});
			
			this.kpiTargetMarker.applyStyles({left: this.kpiTargetMarkerPos + "%"});
			this.kpiValueLane.applyStyles({width: this.kpiValueLaneWidth + "%"});
			
			// Text Element Positions
			this.kpiMinValue.applyStyles({left: this.kpiMinValPos * textRelOffset + "%"});
			this.kpiGoodValue.applyStyles({left: this.kpiGoodValPos * textRelOffset + "%"});
			this.kpiTargetValue.applyStyles({left: (this.kpiTargetMarkerPos - 2) * textRelOffset + "%"});
		},
		
		updateKpiValue: function(value) {
			
			if( typeof value !== "undefined" ) {
				this.conf.value = value;
			}
			
			this.conf.range = this.conf.maxVal - this.conf.minVal;
			
			//Set Boxes
			//TODO: Calculation of box configuration
			this.kpiBadBoxStart = this.conf.badStart;
			this.kpiBadBoxWidth = this.conf.badWidth;
			this.kpiThresBoxStart = this.conf.thresStart;
			this.kpiThresBoxWidth = this.conf.thresWidth;
			this.kpiGoodBoxStart = this.conf.goodStart;
			this.kpiGoodBoxWidth = this.conf.goodWidth;
			
			this.kpiTargetMarkerPos = (this.conf.kpiTargetVal - this.conf.minVal) / this.conf.range * 100;
			this.kpiValueLaneWidth = (this.conf.value - this.conf.minVal) / this.conf.range * 100;
			
			this.kpiMinValPos = (this.conf.kpiMinValPos||this.kpiThresBoxStart||0) - 5;
			this.kpiGoodValPos = (this.conf.kpiGoodValPos||this.kpiGoodBoxStart||0) - 5; 
			
			this.kpiNameText = "" + this.conf.name;
			this.kpiValueText = "" + this.conf.value + " " + this.conf.unit;
			this.kpiMinValueText = "" + this.conf.kpiMinVal + " " + this.conf.unit;
			this.kpiGoodValueText = "" + this.conf.kpiGoodVal + " " + this.conf.unit;
			this.kpiTargetValueText = "" + this.conf.kpiTargetVal + " " + this.conf.unit;
			
			this.updateVis();
		},
		
		render: function(ct, pos) {
			Ext.ux.kpi.KpiPanel.superclass.render.apply(this, arguments);
			
			this.updateKpiValue();
		},
		
		/**
		 * Rendering the KPI elements.
		 * 
		 * @param container
		 * @param pos
		 */
		onRender: function(container, pos) {
			Ext.ux.kpi.KpiPanel.superclass.onRender.apply(this, arguments);
			
			this._initializeElements();
			this._setupHierarchy();
			
			this.updateKpiValue();
		}
	});
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


new function(){
	
	/**
	 * Truncate the size of an Array and 
	 * add a truncate object to it 
	 * @class Array
	 * @method truncate
	 * @param {int} size The result size of the array (+ the truncate object)
	 * @param {Object} trunc The last element which will be added (defaults to "...")
	 * @return {Array}
	 */
	if (!Array.prototype.truncate) {
		Array.prototype.truncate = function(size, trunc){
		    if (this.length > size){
		       return [].concat(this.findAll(function(foo, i){ return i < size; }), (trunc || "..."));
		    }
		    return this;
		};	
	}
	
	/**
	 * Sums up all array elements of type 'number' and returns the sum as Integer.
	 * Uses iterative implementation due to a memory issue caused by an overload stack when summing up
	 * more than 1000 array elements using recursion.
	 * @class Array
	 * @method sum
	 * @returns {Integer} The sum 
	 */
	if (!Array.prototype.sum) {
		Array.prototype.sum = function(){
		    var sum = 0;
		    for(var i=0; i < this.length; ++i) {
		        if (typeof this[i] === 'number' && (!!this[i] || this[i] == 0)) {
		            sum += this[i];
		        }
		    };
		    return parseInt(sum);
		};
	}

	/**
	 * Multiplies all array elements of type 'number' and returns the Array.
	 * @class Array
	 * @method multiply
	 * @param {Number} factor The factor by which should be multiplied
	 */
	if (!Array.prototype.multiply) {
		Array.prototype.multiply = function(factor) {
			if (typeof factor === "number" && (!!factor || factor == 0)) {
				for (var i = 0; i < this.length; ++i) {
					if (typeof this[i] === "number" && (!!this[i] || this[i] == 0)) {
						this[i] *= factor;
					}
				}
			}
			return this;
		};
	}
	
}();
if(!window.Signavio) { var Signavio = {}; }
if(!Signavio.Config) { Signavio.Config = {}; }

(function() {

    Signavio.Config.BACKEND_PATH = '/p';
    Signavio.Config.STENCILSET_URI = Signavio.Config.BACKEND_PATH + "/editor_stencilset";
    Signavio.Config.IMAGE_PATH = '/images';

    Signavio.Config.KEY_CODE_X = 88;
    Signavio.Config.KEY_CODE_C = 67;
    Signavio.Config.KEY_CODE_V = 86;
    Signavio.Config.KEY_CODE_DELETE = 46;
    Signavio.Config.KEY_CODE_META = 224;
    Signavio.Config.KEY_CODE_BACKSPACE = 8;
    Signavio.Config.KEY_CODE_LEFT = 37;
    Signavio.Config.KEY_CODE_RIGHT = 39;
    Signavio.Config.KEY_CODE_UP = 38;
    Signavio.Config.KEY_CODE_DOWN = 40;

    Signavio.Config.META_KEY_META_CTRL = "metactrl";
    Signavio.Config.META_KEY_ALT = "alt";
    Signavio.Config.META_KEY_SHIFT = "shift";

    Signavio.Config.KEY_ACTION_DOWN = "down";
    Signavio.Config.KEY_ACTION_UP = "up";

    Signavio.Config.EVENT_MOUSEDOWN = "mousedown";
    Signavio.Config.EVENT_MOUSEUP = "mouseup";
    Signavio.Config.EVENT_MOUSEOVER = "mouseover";
    Signavio.Config.EVENT_MOUSEOUT = "mouseout";
    Signavio.Config.EVENT_MOUSEMOVE = "mousemove";
    Signavio.Config.EVENT_DBLCLICK = "dblclick";
    Signavio.Config.EVENT_KEYDOWN = "keydown";
    Signavio.Config.EVENT_KEYUP = "keyup";

    Signavio.Config.TYPE_STRING = "string";
    Signavio.Config.TYPE_BOOLEAN = "boolean";
    Signavio.Config.TYPE_INTEGER = "integer";
    Signavio.Config.TYPE_FLOAT = "float";
    Signavio.Config.TYPE_COLOR = "color";
    Signavio.Config.TYPE_DATE = "date";
    Signavio.Config.TYPE_CHOICE = "choice";
    Signavio.Config.TYPE_URL = "url";
    Signavio.Config.TYPE_DIAGRAM_LINK = "diagramlink";
    Signavio.Config.TYPE_COMPLEX = "complex";
    Signavio.Config.TYPE_TEXT = "text";
    Signavio.Config.TYPE_EPC_FREQ = "epcfrequency";
    Signavio.Config.TYPE_GLOSSARY_LINK = "glossarylink";
    Signavio.Config.TYPE_RADIOBUTTON = "radiobutton";
    Signavio.Config.TYPE_IKS = "metadataiks";

    Signavio.Config.COMPONENT_SPACING = 10;

    // Define propety ids and types in lower case
    Signavio.Config.HIDDEN_PROPERTIES = [];
    Signavio.Config.HIDDEN_PROPERTY_TYPES = [Signavio.Config.TYPE_IKS];

    Signavio.Const = Signavio.Const || {};
    Signavio.Const.EVENT = Signavio.Const.EVENT || {};

    Signavio.Const.REL = Signavio.Const.REL || {};
    /**
     * Define the rel tag posible values
     * @final
     */
    Signavio.Const.REL.DIRECTORY    = 'dir';
    Signavio.Const.REL.MODEL        = 'mod';
    Signavio.Const.REL.INFO         = 'info';
    Signavio.Const.REL.USER         = 'user';
    Signavio.Const.REL.ORDER        = 'order';
    Signavio.Const.REL.PURL         = 'purl';
    Signavio.Const.REL.NOTIFY       = 'notify';
    Signavio.Const.REL.PRIVILEGE    = 'priv';
    Signavio.Const.REL.GROUP        = 'group';
    Signavio.Const.REL.CHILD_GROUP  = 'cgroup';
    Signavio.Const.REL.GLOSSARY     = 'glos';
    Signavio.Const.REL.INVITATION   = 'invitation';
    Signavio.Const.REL.VIEWS        = 'views';
    Signavio.Const.REL.FILE         = 'file';
    Signavio.Const.REL.REVISION     = 'revision';

    Signavio.Const.EVENT.OPEN_FILE_UPLOAD = "open.file.upload";
    Signavio.Const.EVENT.NEW_FILE_UPLOAD = "new.file.upload";
    Signavio.Const.EVENT.CANCEL_FILE_UPLOAD = "cancel.file.upload";

    Signavio.Config.Events = Signavio.Config.Events || {};

    Signavio.Config.registerEvents = function(key, events) {
        if(!key) {
            return;
        }

        events = events || {};

        if(!Signavio.Config.Events[key]) {
            Signavio.Config.Events[key] = {};
        }
        
        if(Hash.prototype.toObject) {
            Signavio.Config.Events[key] = $H(Signavio.Config.Events[key]).merge(events).toObject();
        } else {
            Signavio.Config.Events[key] = $H(Signavio.Config.Events[key]).merge(events);
        }
    };
    
    Signavio.Config.GROWING_TEXT_AREA = {
    		HORIZONTAL_PADDING 	: 15,
    		VERTICAL_PADDING	: 10,
    		GROW_APPEND 		: '&#160;',
    		GROW_MAX 			: 1000,
    		DEFAULT_TEXTAREA_WIDTH : 90,
    		GROW_MIN			: 10,
    		GROW_MIN_HORIZONTAL	: 90
    };

}());
ns("ux.dialog");

(function() {

	Signavio.ux.dialog.Link = function(attrs) {
		attrs = attrs || {};

		attrs.text = attrs.text || "";
		attrs.template = new Ext.Template(
			"<a href='#' class='x-signavio-link " + (attrs.cls || "") + "'>{0}</a>"
		);

		delete attrs.cls;

		Signavio.ux.dialog.Link.superclass.constructor.apply(this, arguments);
	};

	Ext.extend(Signavio.ux.dialog.Link, Ext.Button, {

		onRender: function() {
			var that = this;

			this.el = Ext.get(this.template.append(this.container.dom, [this.text]));
			this.el.on("click", function(event) {
				that.handler.apply(this, arguments);

				event.stopEvent();

				return false;
			});
		}
	});

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
 
ns("ux.dialog");

(function() {

	var ENTRY_CLS = "x-entry";
	var ENTRY_SELECTOR = "." + ENTRY_CLS;

	Signavio.ux.dialog.List = function(attrs) {
		this.entries = attrs.entries || [];
		this.size = attrs.size;

		this.setup(attrs);
		
		if(attrs.emptyText) {
			this.emptyText = new Ext.form.Label({
				text: attrs.emptyText,
				cls: "x-empty-text " + (attrs.labelCls ? attrs.labelCls : "")
			});

			delete attrs.emptyText;
		}

		Signavio.ux.dialog.List.superclass.constructor.apply(this, arguments);

		var that = this;

		this._add = function() {
			Ext.Panel.prototype.add.apply(that, arguments);
		};

		this._remove = function() {
			Ext.Panel.prototype.remove.apply(that, arguments);
		};

		this.addEvents({
			"rerender": true
		});
	};

	Ext.extend(Signavio.ux.dialog.List, Ext.Panel, {

		setup: function(attrs) {
			attrs.equals = attrs.equals || function() {
				return false;
			};
			attrs.border = attrs.border || false;
			attrs.collapsible = attrs.collapsible || false;
			attrs.cls = attrs.cls || "x-list";
		},

		clear: function() {
			if(!this.items) {
				return;
			}

			var list = this;

			this.items.each(function(item) {
				list._remove(item);
			});
		},

		count: function() {
			return this.entries.length;
		},

		getValues: function() {
			return this.entries.map(function(entry) {
				entry.value.title = entry.text;

				return entry.value;
			});
		},

		find: function(clb) {
			return this.entries.find(clb);
		},

		update: function(current, updated, clb) {
			if(!current) {
				return;
			}

			clb = clb || Ext.emptyFn;

			var index = this.entries.indexOf(current);

			var before = this.entries.slice(0, index);
			var after = this.entries.slice(index + 1);

			updated.actions = current.actions;

			this.entries = before.concat([updated]).concat(after);
			this.rerender();

			clb(this, updated, current);
		},

		getElement: function(entry) {
			var index = this.entries.indexOf(entry);

			if(index === -1 || !this.rendered) {
				return;
			}

			return this.el.select(ENTRY_SELECTOR).item(index);
		},

		rerender: function() {
			this.clear();

			var list = this;

			this.entries.each(function(entry) {
				list._add(new Ext.form.Label({
					cls: ENTRY_CLS + " " + (entry.cls || ""),
					text: entry.text
				}));

				if(!entry.actions) {
					return;
				}

				entry.actions.each(function(action) {
					list._add(new Signavio.ux.dialog.Link({
						text: action.text,
						cls: action.cls,
						handler: function() {
							action.handler(list, entry);
						}
					}));
				});

				list._add(new Signavio.ux.dialog.ListSeparator());
			});

			if(this.entries.length === 0 && this.emptyText) {
				this._add(this.emptyText);
			}

			this.doLayout();

			this.fireEvent("rerender", this);
		},

		full: function() {
			if(!Ext.isDefined(this.size)) {
				return false;
			}

			return this.count() === this.size;
		},

		allowed: function(entry) {
			var that = this;

			return !this.entries.find(function(sample) {
				return that.equals(sample, entry);
			});
		},

		add: function(entry, clb) {
			if(Ext.isDefined(this.size) && this.entries.length >= this.size) {
				return;
			}

			if(!this.allowed(entry)) {
				return;
			}

			clb = clb || Ext.emptyFn;

			this.entries.push(entry);

			this.rerender();

			clb(this, entry);
		},

		remove: function(entry) {
			this.entries = this.entries.without(entry);

			this.rerender();
		},

		render: function() {
			Signavio.ux.dialog.List.superclass.render.apply(this, arguments);

			Signavio.Utils.defer(function() {
				this.rerender();
			}, this);
		}

	});

	Signavio.ux.dialog.ListSeparator = function(attrs) {
		attrs = attrs || {};

		attrs.cls = attrs.cls || "x-list-separator";

		Signavio.ux.dialog.ListSeparator.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.dialog.ListSeparator, Ext.form.Label);

}());
/**
 * Copyright (c) 2013
 * Willi Tscheschner, Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

ns("ux.dialog.tree");

(function() {

	Signavio.ux.dialog.tree.DefaultRoot = function(facade, attrs) {
		this.facade = facade;

		attrs = this.setup(attrs);

		var that = this;

		attrs.filterFn = function() {
			return that.filterFn.apply(that, arguments);
		};

		attrs.isChildLeaf = attrs.isChildLeaf || Signavio.Utils.isModel;

		Signavio.ux.dialog.tree.DefaultRoot.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.dialog.tree.DefaultRoot, Ext.tree.TreeNode, {

		setup: function(attrs) {
			return Ext.apply({}, attrs || {}, {
				text: "",
				draggable: false,
				leaf: false,
				cls: "folder",
				dataField: "rep.name",
				expanded: Ext.isDefined(attrs.expanded) ? attrs.expanded : true,
				recordRel: [
					Signavio.Const.REL.DIRECTORY,
					Signavio.Const.REL.MODEL
				],
				identifier: Signavio.Config.DIRECTORY_PATH
			});
		},

		getRootFolder: function() {
			Signavio.Utils.Request.execute("/p" + this.facade.getModelMetaData().parent, {
				success: function(response) {
					if(!response || response.length === 0) {
						return;
					}


				}
			});
		},

		selectionInInternal: function() {
			var root;

			if(!this.facade.getCurrentRootFolder) {
				root = this.getRootFolder();
			} else {
				root = this.facade.getCurrentRootFolder();
			}

			return  Ext.isDefined(root) && Signavio.Utils.isInternalFolder(root);
		},

		filterFn: function(record) {
			if (Signavio.Utils.isModel(record) || Signavio.Utils.isFile(record)) {
				return true;
			}

			if (Signavio.Utils.isDirectory(record)) {
				return !Signavio.Utils.isTrashFolder(record, this.facade) &&
					((this.selectionInInternal() && Signavio.Utils.isInternalFolder(record)) ||
						(!this.selectionInInternal() && !Signavio.Utils.isInternalFolder(record)));
			}

			return false;
		}
	});

	/**
	 * Treeloader implements the specific behavior of loading data via an Ext.data.Store
	 * An Node within the Tree Panel needs to have following attributes 
	 * {dataField:String, recordRel:String, identifier:String}
	 * @class
	 */
	Signavio.ux.dialog.tree.Loader = function(){
		this.cachedStores = [];
		this.cachedCallbacks = {};
		
		Signavio.ux.dialog.tree.Loader.superclass.constructor.apply(this, arguments);

		this.addEvents({
			"node.checkchange": true
		});
	};

	Ext.extend(Signavio.ux.dialog.tree.Loader, Ext.tree.TreeLoader, {
		
		findRecord: function(identifier) {
			
			var record;
			
			(this.cachedStores || []).any(function(store){
				record = store.data.items.find(function(r){
					return r.get("href") === identifier;
				});

				return !!record;
			});

			return record;
		},
		
		/**
		 * Enable requesting
		 */
		dataUrl: true,

		/**
		 * Overrides the request handler for the treepanel
		 * @param {Object} node
		 * @param {Object} callback
		 */
		requestData: function(node, callback){
			callback = callback || Ext.emptyFn;
			var that = this;

			var clb = function(tree, node) {
				that.fireEvent("update", tree, node);

				callback(tree, node);
			};

			if(!node.ownerTree) {
				node.ownerTree = this.panel;
			}

			if(node.attributes.identifier && this.fireEvent("beforeload", this, node, callback)){
				node.collapse();
				
				var requestUrl = this.getRequestUrl(node.attributes.identifier);
				// Make suitable for editor
				// load store via request
				var store = Signavio.Core.StoreManager.getRelatedStore(requestUrl, this.storekey, [], {
					params: this.baseParams || {}
				});
				
				this.initStoreEvents( store, node, clb);
			} else {
				clb(this, node);
			}
		},
		
		getRequestUrl: function(identifier) {
			return identifier;
		},

		setGetRequestUrlCallback: function(f) {
			this.getRequestUrl = f;
		},
		
		releaseEvent: function(key, store) {
			if(!this.cachedCallbacks || !this.cachedCallbacks[key]) {
				return;
			}

			store.un("load", this.cachedCallbacks[key].update);
			store.un("update", this.cachedCallbacks[key].update);
			store.un("add", this.cachedCallbacks[key].add);
			store.un("remove", this.cachedCallbacks[key].remove);
		},

		addEvent: function(key, store) {
			if(!this.cachedCallbacks || !this.cachedCallbacks[key]) {
				return;
			}

			store.on("load", this.cachedCallbacks[key].update);
			store.on("update", this.cachedCallbacks[key].update);
			store.on("add", this.cachedCallbacks[key].add);
			store.on("remove", this.cachedCallbacks[key].remove);
		},

		initStoreEvents: function(store, node, callback){
			var hashkey = node.id + (node.attributes.identifier || store.getIdentifier());
			
			this.releaseEvent(hashkey, store);
			
			var that = this;

			this.cachedCallbacks[hashkey] = {
				update: function() {
					that.doResponse(store, node, callback);
				},
				add: function(store, records) {
					if(!node.ownerTree) {
						node.ownerTree = that.panel;
					}

					that.onAdd(node, store, records);
				},
				remove: function(store, record) {
					that.onRemove(node, store, record);
				}
			};

			this.addEvent(hashkey, store);

			if( !this.cachedStores.include(store) ){
				this.cachedStores.push(store);
			}
			
			// If already loaded
			if (store.lastOptions && !store.isLoading && node.rendered){
				this.cachedCallbacks[hashkey].update();
			}
		},
		
		releaseAllEvents: function(){
			var that = this;

			(this.cachedStores||[]).each(function(store){
				var id = store.lastOptions.id;
				var key	= $H(that.cachedCallbacks).keys().find(function(key) {
					return key.endsWith(id);
				});

				that.releaseEvent(key, store);
			});
		},
		
		onAdd: function(node, store, records){
			var rel = [node.attributes.recordRel].flatten();
			
			if(records.any(function(r) {
				return !rel.include(r.get("rel"));
			})){
				return;
			}

			node.attributes.leaf = false;
			node.expand(false, true);
			
			var generateNodes = [];
			
			// For every record in the store, append a new child
			this.generateNodeData(store, records, node).each(function(data){
				var r = records.find(function(re){
					return re.get("href") === data.identifier;
				});
				
				var sortedRecords = ([]).concat(store.data.items);

				if(r && !store.data.contains(r)) {
					sortedRecords = sortedRecords.concat([r]);
				}

				sortedRecords = sortedRecords.findAll(function(t) {
					return t.get("rel") === "dir";
				}).sort(store.lastOptions.sort || Signavio.Utils.BottomUpBusinessObjectSortingFunction);
			
				var cn = this.createNode(data);
				generateNodes.push(cn);
				
				if (r && sortedRecords.indexOf(r)+1 < sortedRecords.length){
					node.insertBefore(cn, node.item(sortedRecords.indexOf(r)));
				} else {
					node.appendChild(cn);
				}
				
			}.bind(this));
			//node.endUpdate();
			
			// Anim the adding
			generateNodes.each(function(node){
				if (node.ui.elNode) {
					Ext.get(node.ui.elNode).slideIn("t", {
						duration:0.2
					});
				}
			});
			
			if (this.showTooltip) {
				generateNodes.each(function(cn){
					(cn.getUI().wrap.dom||cn.getUI().wrap).setAttribute("title", cn.text);
				});
			}
		},
		
		onRemove: function(node, store, record){
			var rel = [node.attributes.recordRel].flatten();
			
			if( !rel.include(record.get("rel")) ){
				return;
			}
			
			// Remove the node which is linked with the record
			var deleteNode = node.findChild("identifier", record.get("href"));
			if (deleteNode && deleteNode.getOwnerTree()) {
				deleteNode.remove();
			}
		},
		
		/**
		 * Generate the data for the nodes depending on the records
		 * @param {Object} records
		 */
		generateNodeData: function(store, records, node){
			if (this.sortingFn) {
				records = records.sort(this.panel.sortingFn || this.sortingFn);
			} else if ( !(store.lastOptions.sort)  ){
				records = records.sort(Signavio.Utils.BottomUpBusinessObjectSortingFunction);
			}

			if(this.filterFn) {
				var that = this;
				
				records = records.select(function(record) {
					return that.filterFn(record, node);
				});
			}
				
			return this.processNode(store, records, node);
		},

		processNode: function(store, records, node) {
			// Set loaded store to the node
			node.attributes.store = store;

			var that = this;

			// For every record in the store, append a new child
			return records.map(function(record){
				return that.processItem(store, record, node);
			}).compact();
		},

		processItem: function(store, record, node) {
			var attr = node.attributes;
			var fn = node.attributes.filterFn;
				
			if( fn instanceof Function && !fn(record) ){
				return;
			}
			
			var data = this.createData(store, record, node);
			
			if (this.showTooltip || attr.getToolTip) {
				data.qtip = (attr.getToolTip ? attr.getToolTip(record) : "") || (this.showTooltip && data.text) || "";
			}
			
			if(this.panel && this.panel.disabledIds && this.panel.disabledIds.include(data.identifier) ){
				return null;
			}
			
			return data;
		},

		hasChange: function(node, items) {
			var children = node.childNodes;

			return children.length > 0 &&
				children.length === items.length &&
				children.all(function(n) {
					var attrs = n.attributes;

					return items.any(function(i) {
						return attrs.identifier === i.identifier &&
							attrs.text === i.text &&
							attrs.color === i.color &&
							attrs.order === i.order;
					});
				});
		},

		getChildClass: function(attrs, record) {
			if(attrs.childCls) {
				return attrs.childCls;
			}

			if(attrs.hasChildCls) {
				return attrs.hasChildCls(record);
			}

			if(Signavio.Utils.isModel(record)) {
				return "model model-" + Signavio.Utils.getIcon(record, true);
			}

			if(Signavio.Utils.isFile(record)) {
				return "file file-" + Signavio.Utils.getIcon(record, true);
			}

			return "folder";
		},

		createData: function(store, record, node) {
			var attr = node.attributes;
			var text = store.parseValue(record, node.attributes.dataField);

			return {
				text: Signavio.I18N.Repository.Folder[record.get("rep").type] || (attr.parseText ? attr.parseText(text, record) : false) || text || attr.value,
				// cls			: attr.childCls || (attr.hasChildCls ? attr.hasChildCls(record) : ""),
				cls: this.getChildClass(attr, record),
				leaf: attr.childLeaf || (attr.isChildLeaf ? attr.isChildLeaf(record) : false),
				rel: record.get("rel"),
				childLeaf: attr.childLeaf,
				isChildLeaf: attr.isChildLeaf,
				filterFn: attr.filterFn,
				checked: Ext.isDefined(attr.checked) ? node.ui.isChecked() : undefined,
				hasChildCls: attr.hasChildCls,
				parseText: attr.parseText,
				childCls: attr.childCls,
				dataField: attr.dataField,
				recordRel: attr.recordRel,
				singleClickExpand: attr.singleClickExpand || false,
				getIdentifier: attr.getIdentifier,
				getToolTip: attr.getToolTip,
				identifier: attr.getIdentifier instanceof Function ? attr.getIdentifier(record) : record.get("href")
			};
		},

		/**
		 * Callback when loading the new data from the store
		 * @param {Object} store Store where the new data comes from
		 * @param {Object} node Node where the data should append
		 * @param {Object} callback Callback when ready loading
		 * @param {Object} records New records of the store
		 */
		doResponse: function(store, node, callback){

			// if( (typeof c === "string" && c !== Ext.data.Record.COMMIT) || !node.getOwnerTree() ){
			if(!node.getOwnerTree()){
				return;
			}

			// Get the new items
			var items = this.generateNodeData( store, store.getRecords(node.attributes.recordRel), node );
			// Check if there are changes
			if(this.hasChange(node, items)) {
				return;
			}
			
			// Hide all childs
			node.collapse();
			
			// Remove all children
			var index = node.childNodes.length-1;
			for(; index>=0; index = index - 1){
				node.childNodes[index].remove();
			}
			
			var that = this;

			node.beginUpdate();
			// For every record in the store, append a new child
			items.each(function(data){
				var cn = that.createNode(data);

				cn.on("checkchange", function(node, value) {
					that.fireEvent("node.checkchange", node, value);
				});
				
				node.appendChild(cn);
			});

			node.endUpdate();

			Signavio.Utils.defer(function() {
				if(!node.ownerTree) {
					node.ownerTree = that.panel;
				}

				node.expand();
			}, this, 100);
			
			this.fireEvent("update", this, items);
			this.fireEvent("load", this, node);
				
			if(callback){
				callback(this, node);
			}
		}
	});

	/**
	 * TreePanel implements a specific Tree Panel.
	 * @class
	 * @param {Object} attributes
	 */
	Signavio.ux.dialog.tree.Panel = function(attrs){
		attrs = attrs || {};
		// Create a new loader instance
		attrs.loader = new Signavio.ux.dialog.tree.Loader({
			panel: this,
			sortingFn: attrs.sortingFn
		});

		var that = this;

		attrs.cls = "tree-panel";

		// Call super class
		Signavio.ux.dialog.tree.Panel.superclass.constructor.call(this, attrs);
		
		this.loader.on("node.checkchange", function(node, value) {
			that.onNodeCheckChange(node, value);
		});
		this.loader.on("update", this.onUpdate.bind(this));
		this.loader.on('beforeload', function() {
			that.el.mask();
		});
		this.loader.on('load', function() {
			that.el.unmask();
		});
		
		if( attrs.root instanceof Ext.tree.TreeNode ){
		
			this.on("render", function(){
				this.getLoader().requestData(this.root, this.onRootLoaded.bind(this));
			}.bind(this));
		
		} else if( attrs.data ){
			
			// Create root node
			var root = new Ext.tree.TreeNode({
				text: '',
				draggable: false,
				expanded: true
			});
			
			this.setRootNode( root );
			
			// Append data to the root node
			this.appendChildNodes(root, attrs.data);
		}
	};

	Ext.extend(Signavio.ux.dialog.tree.Panel, Ext.tree.TreePanel, {
		
		/**
		 * Initial default values
		 */
		animate		: true,
		enableDD	: false,
		rootVisible : false,
		useArrows	: true,
		autoScroll	: true,
		//maskDisabled: false,
				
		onRootLoaded: Ext.emptyFn,
		onUpdate	: Ext.emptyFn,

		onNodeCheckChange: Ext.emptyFn,
				
		appendChildNodes: function( node, data ){
			return data.map(function(d) {
				if (d.useTreeNode) {
					return node.appendChild( new Ext.tree.TreeNode(d) );
				}

				return node.appendChild(this.getLoader().createNode(d));
			}.bind(this));
		},
		
		removeChildNodes: function( node ){
			var index = node.childNodes.length-1;
			for(; index>=0; index = index - 1){
				node.childNodes[index].remove();
			}
		},
		
		/**
		 * Return the selected record
		 * @return {Record} Return the selected record or undefined if no element is selected
		 */
		getSelectedRecord:function(){
			var selNode = this.getSelectionModel().getSelectedNode();
			
			if(!selNode){
				return;
			}
			
			return this.loader.findRecord( selNode.attributes.identifier );
		},
		
		onRender: function(){
			Signavio.ux.dialog.tree.Panel.superclass.onRender.apply(this, arguments);
			
			if(!this.unselectable){
				return;
			}

			var that = this;

			this.el.on("click", function(b,e){
				if (e !== that.body.dom){
					return;
				}
				
				that.selectPath("");
			});
		},

		onDestroy: function(){
			if(!this.rendered){
				return;
			}
			
			this.getLoader().releaseAllEvents();
		}
	});

	/**
	 * TreePanel implements a specific Tree Panel which has a setValue method which uses to generate new children.
	 * @class
	 * @param {Object} attributes
	 */
	Signavio.ux.dialog.tree.CheckPanel = function(attrs){
		attrs = attrs || {};
		
		this.data = attrs.data;
		delete attrs.data;

		this.dataLabel = attrs.dataLabel;
		
		Signavio.ux.dialog.tree.CheckPanel.superclass.constructor.call(this, attrs);

		if (attrs.dataStore instanceof Ext.data.Store) {
			this.data = [];
			attrs.dataStore.on("load", function(store){
				this.data = store.data.items.map(function(r){return r.data;});
				this.loadData();
			}.bind(this));
		}
		
		if (this.data instanceof Array) {
			// Create root node
			var root = new Ext.tree.TreeNode({
				text: '',
				draggable: false,
				expanded: true
			});
			
			this.setRootNode(root);
		}
	};

	Ext.extend(Signavio.ux.dialog.tree.CheckPanel, Signavio.ux.dialog.tree.Panel, {
		
		/**
		 * Initial default values
		 */
		animate		: true,
		autoScroll	: true,
		enableDD	: false,
		rootVisible : false,
		useArrows	: true,
		cls			: "x-tree-check-panel",
		loader		: new Ext.tree.TreeLoader(),
		value		: null,
		height		: 100,
		width		: 129,
		isFormField : true,
		checkRecursive : false,
		originalValue : null,
		
		defaultItem : {
			leaf: true,
			checked: false,
			useTreeNode: true,
			iconCls: "x-hidden"
		},
		
		afterRender : function(){
			Signavio.ux.dialog.tree.CheckPanel.superclass.afterRender.call(this);
			
			this.loadData();
		},
		
		loadData: function(){
			var that = this;

			// Render/add recursive new childs
			var fn = function(children, parent) {

				// Define child nodes.
				children = children.map(function(child){
					var attrs = {};
					 
					if(typeof child === "string") {
						attrs.text = child;
						attrs.identifier = child;
					} else if(that.dataLabel) {
						attrs.text = child[that.dataLabel];
						attrs.identifier = child[that.dataLabel];
					} else {
						attrs = child;
					}
				
					return Ext.apply(Object.clone(that.defaultItem), attrs, {
						value: child
					});
					
				});
				// Append data to the root node
				var nodes = that.appendChildNodes(parent, children);
				
				// Create recursive all children
				nodes.each(function(node){
					if(node.attributes.children){
						fn(node.attributes.children, node);
					}

					node.render();
				});
			};
			
			if(this.data && this.root){
				fn(this.data, this.root);
			}
		},
		
		/**
		 * @member Signavio.Extensions.TreeDataPanel
		 * @param {Object} val
		 */
		setValue: function(values){
			this.value = values;

			if(!(values instanceof Array)) {
				return;
			}

			var that = this;

			this.root.cascade(function(node){
				that.toggleCheck(node, false);
				node.enable();
			});
			
			values.each(function(value) {
				var identifier = that.dataLabel ? value[that.dataLabel] : value;
				var node = that.findChildNode(that.root, "identifier", identifier, that.checkRecursive, value);

				that.toggleCheck(node, true);
			});
		},
		
		/**
		 * Returns a child node from the given node with the given attribtue
		 * @param {Ext.tree.Node} node
		 * @param {Object} attr
		 * @param {Object} val
		 * @param {Boolean} recusive
		 */
		findChildNode: function(node, attr, val, recursive){
			var found = node.findChild(attr, val),
				that = this;
			
			if (!found && recursive) {
				node.childNodes.any(function(child){
					found = that.findChildNode(child, attr, val, recursive);
					return !!found;
				});
			}

			return found;
		},
		
		/**
		 * Returns the data for a given node
		 * @param {Ext.tree.Node} node
		 * @returns {Object}
		 */
		getData: function(node){
			return this.data.find(function(n){
				return n[this.dataLabel] === (node.attributes.identifier || node.attributes.text);
			}.bind(this));
		},
		
		/**
		 * Return all identifiers/text from all selected nodes 
		 */
		getValue: function(){
			var value = [];
			var that = this;

			this.root.cascade(function(node){
				if (!node.ui.isChecked()) {
					return;
				}

				if (that.dataLabel){
					var data = that.getData(node);
					
					if (data) {
						value.push(data);
					}
				} else {
					value.push(node.identifier || node.text);
				}
			});

			return value;
		},
		
		/**
		 * Toggle the checkbox of the node
		 * @param {Object} node Node with the cb
		 * @param {Object} value 
		 */
		toggleCheck: function(node, value){
			if(!node) {
				return;
			}

			node.beginUpdate();
			node.ui.toggleCheck(value);
			node.endUpdate();
		}
	});

	/**
	 * ModelDirectoryCheckTreePanel implements a specific Tree Panel.
	 * 
	 */
	Signavio.ux.dialog.tree.ModelCheckPanel = function(attrs, elements){
		
		this.initialSelection = elements;
		
		attrs = attrs || {};
		
		if (!attrs.sortingFn) {
			attrs.sortingFn = Signavio.Utils.BottomUpBusinessObjectSortingFunction;
		}
		
		attrs.anchor = Ext.isDefined(attrs.anchor) ? attrs.anchor : '100% -15';
		attrs.style= attrs.style || "padding:0px;padding-top:10px;";
		
		Signavio.ux.dialog.tree.ModelCheckPanel.superclass.constructor.call(this, attrs);

		var that = this;

		var handleClick = function(node) {
			if (!Ext.isDefined(node.attributes.checked)) {
				return true;
			}
			
			that.handleCheckChange(node, !node.attributes.checked);
				
			return false;
		};

		this.on("dblclick", handleClick);
		this.on("click", handleClick);

		this.addListener('checkchange', function(node, checked) {
			that.handleCheckChange(node, checked);
		});
	};

	Ext.extend(Signavio.ux.dialog.tree.ModelCheckPanel, Signavio.ux.dialog.tree.Panel, {
		
		bodyStyle	: "padding:2px 0px !important;",
		cls			: "x-tableview-plugin x-div-textbackground",
		forceUpdate : true, // Force immediate update
		recordRel	: [ Signavio.Const.REL.DIRECTORY, Signavio.Const.REL.MODEL ],
		
		toggleAllChildren: function(parent, value) {
			var that = this;

			parent.childNodes.each(function(child) {
				child.ui.toggleCheck(value);
				child.attributes.checked = value;

				that.fireEvent("node.checkchange", child, value);
				
				that.toggleAllChildren(child, value);
			});
		},

		updateParentSelection: function(parent, value){
			if (!parent){
				return;
			}
			
			if (!value) {
				parent.ui.toggleCheck(value);
				parent.attributes.checked = value;
			} else {
				var allChecked = parent.childNodes.all(function(node){
					return node.ui.isChecked();
				});

				if (allChecked) {
					parent.ui.toggleCheck(true);
					parent.attributes.checked = true;
				}
			}

			this.fireEvent("node.checkchange", parent, value);

			this.updateParentSelection(parent.parentNode, value);
		},

		handleCheckChange: function(node, checked) {
			node.ui.toggleCheck(checked);
			node.attributes.checked = checked;

			this.toggleAllChildren(node, checked);
			this.updateParentSelection(node.parentNode, checked);
		},

		/**
		 * Get called when the root (the root directories) are loaded
		 * 
		 */
		onRootLoaded: function(){
			Signavio.Utils.defer(function() {
				this.expandToAndCheckPreSelection(this.initialSelection || []);
			}, this);
		},
		
		/**
		 * Called when the panel gets destroyed.
		 * Release all event.
		 * 
		 */
		onDestroy : function(){
			Signavio.ux.dialog.tree.ModelCheckPanel.superclass.onDestroy.call(this);

			this.getLoader().releaseAllEvents();
		},
		
		/**
		 * Expands the tree for the given element array
		 * @param {Array} elementArray
		 * @param {Boolean} anim
		 * @param {Function} finished
		 */
		expandToAndCheckPreSelection : function(elements, animate, finished){
			if (!(elements instanceof Array) && elements.length === 0) {
				if (finished instanceof Function) {
					finished();
				}

				return;
			}
			
			var parents = [];
			var that = this;
			
			// Define nodes which should be selected
			var nodes = elements.map(function(r){
				return r instanceof Ext.data.Record ? r.get("href") : undefined;
			}).compact();
			
			// Get all parents which should be expanded
			elements.each(function(record) {
				var store;
				
				if(record instanceof Ext.data.Store) {
					store = record;
				} else {
					store = Signavio.Core.StoreManager.getStore(record.get("href"));
				}

				var parentRec = [];

				if(store) {
					parentRec = store.getRecords("parents") || [];
				}

				parentRec = parentRec.first();
				
				if (!parentRec) {
					return;
				}

				var rel = [];

				if(store === record) {
					rel = {
						href: store.getIdentifier()
					};
				}

				[].concat(rel, parentRec.get("rep"))
					.reverse()
					.each(function(parent, i){
						if (!parents[i]) {
							parents[i] = [];
						}

						if (!parents[i].include(parent.href)) {
							parents[i].push(parent.href); // Add uniq parent id
						}
					});
			});
			
			// Expand all child nodes which are included in the list of parent
			var expandAndCheckRecursively = function (parent, index) {
				index = index || 0;

				var expanding = false;
				
				parent.childNodes.each(function(node){
					if((parents[index] || []).include(node.attributes.identifier)){
						expanding = true;
						
						node.expand(false, animate, function() {
							expandAndCheckRecursively(node, index + 1);
						});
						// Select last folder
						if (index === parents.length-1 && !Ext.isDefined(node.attributes.checked)){
							that.getSelectionModel().select(node);
						}
					}

					if (!nodes.include(node.attributes.identifier)) {
						return;
					}

					// Check all nodes
					if (Ext.isDefined(node.attributes.checked)) {
						node.ui.toggleCheck(true);
						node.attributes.checked = true;
					} else {
						that.getSelectionModel().select(node);
					}
				});
				
				if (!expanding && finished){
					finished();
				}
			};
			
			expandAndCheckRecursively(this.root);
		},
		
		findChildNode : function(parent, id) {
			var children = parent.childNodes;
			
			for (var i = 0, length = children.length; i < length; i = i + 1) {
				var child = children[i];

				if (child.attributes.identifier === id) {
					return child;
				}
			}
		},
		
		uncheckAllExcept: function(models, parent) {
			parent = parent || this.root;

			parent.childNodes.each(function(node) {
				switch(node.attributes.rel) {
				case Signavio.Const.REL.MODEL:
					if(!models.include(node.attributes.identifier)) {
						node.attributes.checked = false;
						node.ui.toggleCheck(false);
					} else if(!node.attributes.checked) {
						node.attributes.checked = true;
						node.ui.toggleCheck(true);
					}
					
					break;
				case Signavio.Const.REL.DIRECTORY:
					this.uncheckAllExcept(models, node);
				}
			});
		}
		
	});
	
	Signavio.ux.dialog.tree.FolderPanel = function(facade, attrs) {
		attrs = attrs || {};

		attrs.root = new Signavio.ux.dialog.tree.DefaultRoot(facade, {
			recordRel: [Signavio.Const.REL.DIRECTORY]
		});

		Signavio.ux.dialog.tree.FolderPanel.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.dialog.tree.FolderPanel, Signavio.ux.dialog.tree.Panel);

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
 
ns("ux.dialog");

(function() {
	var ORIENTATION = {
		LANDSCAPE: "landscape",
		PORTRAIT: "portrait",
		POLICY: {
			AUTO: "auto",
			ALWAYS: "always",
			NEVER: "never"
		},
		CW: "cw",
		CCW: "ccw"
	};

	var EVENT;

	var FORMAT = {
		A4: "DIN_A4",
		A3: "DIN_A3",
		US_LETTER: "US_LETTER"
	};

	var CONTROL_WIDTH = 185;

	var DATA_EXTRACTOR = function(result) {
		if(!this.items) {
			return;
		}

		this.items.each(function(item) {
			if(!item.fetchValue) {
				return;
			}

			return item.fetchValue(result);
		});
	};

	var DATA_INJECTOR = function(data) {
		if(!this.items) {
			return;
		}

		this.items.each(function(item) {
			if(!item.loadValue) {
				return;
			}

			return item.loadValue(data);
		});
	};

	Signavio.ux.dialog.Print = function(facade, attrs) {
		attrs = attrs || {};

		EVENT = Signavio.Const.EVENT;

		this.facade = facade;

		this.form = this.createGeneralForm(attrs);
		this.preview = this.createPreview(attrs);

		this.setup(attrs);
		attrs.items = attrs.items || [this.form, this.preview];

		Signavio.ux.dialog.Print.superclass.constructor.call(this, attrs);

		this.setupEvents();
	};

	Ext.extend(Signavio.ux.dialog.Print, Ext.ux.Window, {

		getPDF: function(clb) {
			clb = clb || Ext.emptyFn;

			this.body.mask(Ext.ux.getI18N("dialog.print.mask.create.pdf"), "disabled");

			var result = {
				diagramName: this.diagram.get("rep").name
			};

			this.form.fetchValue(result);
			this.preview.fetchValue(result);

			var that = this;

			if(result.models.length === 0 && result.directories.length === 0) {
				Ext.Msg.alert(this.title, Ext.ux.getI18N("dialog.print.error.no.models"));

				this.body.unmask();

				return;
			}

			this.requestPDF(result, function() {
				that.body.unmask();

				clb();

				if(!that.saveAsDefault || !that.saveAsDefault.getValue()) {
					return;
				}

				that.saveDefault(result);
			});
		},

		setupEvents: function() {
			var that = this;

			this.facade.registerOnEvent("orientation.change", function(e, orientation) {
				that.preview.updateOrientation(orientation);
			});

			this.facade.registerOnEvent(EVENT.CANCEL_FILE_UPLOAD, function() {
				delete that.uploading;
			});

			this.on("resize", function(dialog) {
				that.preview.updateOrientation();

				that.form.setHeight(dialog.getInnerHeight());
			});

			this.on("show", function() {
				Signavio.Utils.defer(function() {
					that.preview.updateOrientation();
					that.saveAsDefault = that.createSaveDefaultButton();

					that.body.mask(Ext.ux.getI18N("dialog.print.mask.load.defaults"), "disabled");

					that.loadDefaults(that.form, that.preview);
				});
			});
		},

		setup: function(attrs) {
			var that = this;

			var maxHeight = 0.9 * (document.height||window.innerHeight||0);

			attrs.title = attrs.title || Ext.ux.getI18N("dialog.print.title");
			attrs.layout = attrs.layout || "column";
			attrs.cls = "pdf-export";
			attrs.modal = true;
			attrs.width = 1100;
			attrs.minWidth = 1100;
			attrs.height = Math.max(Math.min(850, maxHeight), 300);
			attrs.bodyStyle = "background:white;";
			attrs.buttons = attrs.buttons || [
				{
					text: Ext.ux.getI18N("dialog.print.button.create"),
					handler: function() {
						that.getPDF(function() {
							that.close();
						});
					}
				}
			];
		},

		requestPDF: function(data, clb) {
			// sanitizing
			data.modelIds = data.models;
			delete data.models;
			
			data.directoryIds = data.directories;
			delete data.directories;

			var frame = Ext.getBody().createChild({
				tag: "iframe",
				cls: "x-hidden"
			});

			var input = ["input", {
				type: "hidden",
				value: JSON.stringify(data),
				name: "printConfig"
			}];

			var form = Signavio.Utils.createForm(frame.dom, "/p/pdfprint", [input]);
			form.submit();

			Ext.Msg.show({
				title: this.title,
				msg: Ext.ux.getI18N("dialog.print.label.download"),
				buttons: Ext.Msg.OK
			});

			clb();
		},

		getDefault: function() {
			var value = this.facade.getConfig("department", "print");

			if(value) {
				return value.evalJSON(true);
			}

			return null;
		},

		loadDefaults: function(form, preview) {
			var defaults = this.getDefault();

			if(!defaults) {
				this.body.unmask();

				return;
			}

			form.loadValue(defaults);
			preview.loadValue(defaults);

			this.body.unmask();
		},

		saveDefault: function(value) {
			this.facade.setConfig("department", "print", value, "EXPLORER", "STRING");
		},

		createSaveDefaultButton: function() {
			if(!this.facade.isCurrentUserAdmin()) {
				return;
			}

			return new Ext.form.Checkbox({
				name: "savedefault",
				checked: false,
				boxLabel: Ext.ux.getI18N("dialog.print.save.defaults.label"),
				ctCls: "save-default",
				renderTo: this.footer,
				fetchValue: function(result) {
					result.saveAsDefault = this.getValue();
				}
			});
		},

		createOrientationControls: function(items, attrs) {
			var that = this;

			var landscape = new Ext.form.Radio({
				name: "orientation",
				fieldLabel: Ext.ux.getI18N("dialog.print.orientation.landscape"),
				checked: attrs.horizontal,
				fetchValue: function(result) {
					result.imageSettings.isLandscape = this.getValue();
				},
				loadValue: function(data) {
					this.setValue(data.imageSettings.isLandscape);
				},
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.facade.raiseEvent("orientation.change", ORIENTATION.LANDSCAPE);
					}
				}
			});

			items.push(landscape);

			var portrait = new Ext.form.Radio({
				name: "orientation",
				fieldLabel: Ext.ux.getI18N("dialog.print.orientation.portrait"),
				checked: !attrs.horizontal,
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.facade.raiseEvent("orientation.change", ORIENTATION.PORTRAIT);
					}
				},
				loadValue: function(data) {
					this.setValue(!data.imageSettings.isLandscape);
				}
			});
			
			items.push(portrait);

			var policy = new Ext.ux.form.ComboBox({
				fieldLabel: Ext.ux.getI18N("dialog.print.orientation.policy.label"),
				mode: "local",
				readOnly: true,
				width: CONTROL_WIDTH,
				value: ORIENTATION.POLICY.AUTO,
				store: new Ext.data.SimpleStore({
					fields: ["value", "title"],
					reader: new Ext.data.ArrayReader({}, ["value", ["title"]]),
					data: [
						[ORIENTATION.POLICY.AUTO, Ext.ux.getI18N("dialog.print.orientation.policy.auto")],
						[ORIENTATION.POLICY.ALWAYS, Ext.ux.getI18N("dialog.print.orientation.policy.always")],
						[ORIENTATION.POLICY.NEVER, Ext.ux.getI18N("dialog.print.orientation.policy.never")]
					]
				}),
				fetchValue: function(result) {
					result.imageSettings.policy = this.getValue();
				},
				loadValue: function(data) {
					this.setValue(data.imageSettings.policy);

					orientation.setDisabled(data.imageSettings.policy !== ORIENTATION.POLICY.ALWAYS);
				}
			});

			policy.on("select", function(field, record) {
				orientation.setDisabled(record.get("value") !== ORIENTATION.POLICY.ALWAYS);
			});

			items.push(policy);

			var orientation = new Ext.ux.form.ComboBox({
				fieldLabel: Ext.ux.getI18N("dialog.print.orientation.label"),
				disabled: true,
				readOnly: true,
				width: CONTROL_WIDTH,
				value: ORIENTATION.CW,
				mode: "local",
				store: new Ext.data.SimpleStore({
					fields: ["value", "title"],
					reader: new Ext.data.ArrayReader({}, ["value", "title"]),
					data: [
						[ORIENTATION.CW, Ext.ux.getI18N("dialog.print.orientation.cw")],
						[ORIENTATION.CCW, Ext.ux.getI18N("dialog.print.orientation.ccw")]
					]
				}),
				fetchValue: function(result) {
					result.imageSettings.orientation = this.getValue();
				},
				loadValue: function(data) {
					if(!data.imageSettings.orientation) {
						return;
					}

					this.setValue(data.imageSettings.orientation);
				}
			});

			items.push(orientation);
		},

		createDistributionCombo: function() {
			var fields = ["value", "title"];

			var combo = new Ext.ux.form.ComboBox({
				fieldLabel: Ext.ux.getI18N("dialog.print.paper.type.label"),
				mode: "local",
				width: CONTROL_WIDTH,
				disabled: false,
				readOnly: true,
				value: FORMAT.A4,
				fetchValue: function(result) {
					result.pageFormat = this.getValue();
				},
				loadValue: function(data) {
					this.setValue(data.pageFormat);
				},
				store: new Ext.data.SimpleStore({
					fields: fields,
					data: [
						[FORMAT.A4, Ext.ux.getI18N("dialog.print.paper.type.a4")],
						[FORMAT.A3, Ext.ux.getI18N("dialog.print.paper.type.a3")],
						[FORMAT.US_LETTER, Ext.ux.getI18N("dialog.print.paper.type.us_letter")]
					],
					reader: new Ext.data.ArrayReader({}, fields)
				})
			});

			return combo;
		},

		createDistributionControls: function(items) {
			items.push(new Ext.form.Radio({
				name: "distribution",
				fieldLabel: Ext.ux.getI18N("dialog.print.distribution.single"),
				checked: true,
				fetchValue: function(result) {
					result.imageSettings.useMultiplePages = !this.getValue();
				},
				loadValue: function(data) {
					this.setValue(!data.imageSettings.useMultiplePages);
				}
			}));

			items.push(new Ext.form.Radio({
				name: "distribution",
				fieldLabel: Ext.ux.getI18N("dialog.print.distribution.multi"),
				loadValue: function(data) {
					this.setValue(data.imageSettings.useMultiplePages);
				}
			}));
		},

		createGeneralControls: function(items) {
			var languages = this.facade.getLanguages();

			if(languages.length > 0) {
				items.push(new Ext.ux.form.LanguageSwitchCombo({
					languages: languages,
					fetchValue: function(result) {
						result.language = this.getValue();
					},
					loadValue: function(data) {
						this.setValue(data.language);
						this.setFlag();
					}
				}));
			}

			var that = this;

			items.push(new Ext.form.Checkbox({
				name: "bw",
				fieldLabel: Ext.ux.getI18N("dialog.print.black.and.white"),
				listeners: {
					check: function(comp, value) {
						that.facade.raiseEvent("image.grayscale", value);
					}
				},
				fetchValue: function(result) {
					result.imageSettings.drawBlackAndWhite = this.getValue();
				},
				loadValue: function(data) {
					this.setValue(data.imageSettings.drawBlackAndWhite);
				}
			}));

			items.push(new Ext.form.Checkbox({
				fieldLabel: Ext.ux.getI18N("dialog.print.show.headers"),
				name: "show-header",
				fetchValue: function(result) {
					result.disableAllHeaders = !this.getValue();
				},
				loadValue: function(data) {
					this.setValue(!data.disableAllHeaders);
				},
				listeners: {
					check: function(field, value) {
						that.facade.raiseEvent("show.headers", value);
					}
				}
			}));

			var configure = new Signavio.ux.dialog.Link({
				text: Ext.ux.getI18N("dialog.print.button.configure"),
				cls: "toggle-read-only",
				handler: function() {
					this.hide();

					that.facade.raiseEvent("configure.page", true);
				}
			});
			
			items.push(configure);

			configure.hide();

			this.facade.registerOnEvent("show.headers", function(e, value) {
				configure.setVisible(value);
			});

			var distribution = this.createDistributionCombo();
			items.push(distribution);
		},

		createFormItems: function(attrs) {
			var items = [];

			items.push(new Ext.form.Label({
				text: Ext.ux.getI18N("dialog.print.label")
			}));

			items.push(this.createSpacer(Ext.ux.getI18N("dialog.print.header.general")));
			this.createGeneralControls(items);

			items.push(this.createSpacer(Ext.ux.getI18N("dialog.print.header.orientation")));
			this.createOrientationControls(items, attrs);

			items.push(this.createSpacer(Ext.ux.getI18N("dialog.print.header.distribution")));
			this.createDistributionControls(items);

			if(attrs.selection) {
				items.push(this.createSpacer("Ausgewählte Diagramme"));
				this.createModelTree(attrs, items);
			}

			return items;
		},

		selectionInInternal: function() {
			return  this.facade.getCurrentRootFolder() !== undefined &&
					this.facade.getCurrentRootFolder().get("rep").type === "internal";
		},

		checkLeafConditions: function(tree, node) {
			var count = 0;
			var preview = node;
			tree.root.cascade(function(child) {
				if(count > 1) {
					return;
				}

				if(!child.leaf || !child.ui.isChecked()) {
					return;
				}

				count = count + 1;
				preview = child;
			});

			if(count === 1) {
				this.loadPreviewImage(preview.attributes.identifier);
			}
		},

		checkSelectionConditions: function(tree, node) {
			if(!node.leaf) {
				return;
			}

			this.checkLeafConditions(tree, node);
		},

		isChecked: function(node) {
			if(!node) {
				return false;
			}

			if(node.isChecked) {
				return node.isChecked();
			}

			if(node.attributes) {
				return node.attributes.checked;
			}

			return false;
		},

		allChildrenSelected: function(parent) {
			if(parent.childNodes.length === 0) {
				return true;
			}

			var result = true;
			var that = this;

			parent.childNodes.each(function(node) {
				result = result && that.isChecked(node);
			});

			return result;
		},

		createSelectionPreview: function(selection) {
			var more = "";

			if(selection.length > 1) {
				more = " " + (new Template(Ext.ux.getI18N("dialog.print.label.more.models"))).evaluate({
					count: selection.length - 1
				});
			}

			var model = new Ext.form.Label({
				text: selection.first().get("rep").name + more
			});

			var that = this;

			var configure = new Signavio.ux.dialog.Link({
				text: Ext.ux.getI18N("dialog.print.button.configure"),
				handler: function() {
					that.facade.raiseEvent("configure.models");
				}
			});

			return new Ext.Panel({
				border: false,
				items: [model, configure]
			});
		},

		createModelTree: function(attrs, items) {
			var that = this;

			var preview = this.createSelectionPreview(attrs.selection);

			var tree = new Signavio.ux.dialog.tree.ModelCheckPanel({
				height: 285,
				// width: 390,
				anchor: "-30",
				onNodeCheckChange: function(node) {
					if(!node) {
						return;
					}

					that.checkSelectionConditions(this, node);
				},
				fetchValue: function(result) {
					var models = [];
					var directories = [];

					this.root.cascade(function(node) {
						if(!node.ui.isChecked()) {
							return;
						}

						if(!node.leaf && !that.allChildrenSelected(node)) {
							return;
						}

						if (node.attributes.rel === "mod") {
							models.push(node.attributes.identifier);
						} else {
							directories.push(node.attributes.identifier);
						}
					});

					result.models = models;
					result.directories = directories;
				},
				root: new Signavio.ux.dialog.tree.DefaultRoot(this.facade, {
					checked: false
				})
			}, attrs.selection);

			tree.setVisible(false);

			this.facade.registerOnEvent("configure.models", function() {
				preview.hide();
				tree.setVisible(true);
			});

			items.push(preview, tree);
		},

		createSpacer: function(text) {
			return new Signavio.ux.form.Spacer({
				text: text
			});
		},

		createGeneralForm: function(attrs) {
			var form = new Ext.form.FormPanel({
				border: false,
				labelWidth: 200,
				cls: "form",
				width: 440,
				items: this.createFormItems(attrs),
				fetchValue: function(result) {
					result.imageSettings = {};

					DATA_EXTRACTOR.call(this, result);
				},
				loadValue: DATA_INJECTOR,
				listeners: {
					render: function(comp) {
						Signavio.Utils.defer(function() {
							this.body.setWidth(comp.getInnerWidth());
						}, this);
					}
				}
			});

			return new Ext.Panel({
				width: 460,
				border: false,
				items: [form],
				cls: "form-container",
				fetchValue: DATA_EXTRACTOR,
				loadValue: DATA_INJECTOR
			});
		},

		getDummyProp: function() {
			return {
				stencil: function() {
					return {
						properties: Ext.emptyFn
					};
				},
				title: function() {
					return Ext.ux.getI18N("dialog.print.attribute.own");
				},
				config: function() {
					return {
						singleSelection: true,
						rootElementsOnly: true
					};
				}
			};
		},

		readableAttributeMapperValue: function(value) {
			var items = [];

			value.items.each(function(item) {
				if(items.include(item.title)) {
					return;
				}

				items.push(item.title);
			});

			return items.join(",<br />");
		},

		getAttributeMapper: function(list, type, value) {
			var prop = this.getDummyProp();
			
			var editor = new Ext.ux.propertyeditor.AttributeMapper(prop, this.facade);

			if(value) {
				editor.getValue = function() {
					return $H(value).toJSON();
				};
			}

			var that = this;

			editor.validProperty = function(property) {
				if(property.list) {
					return false;
				}

				if(property.type === "MetaDataComplex") {
					// It's a table! Run!
					return false;
				}

				if(property.type === "MetaDataStringInfo" && property.lineWrap) {
					// No rich text
					return false;
				}

				return true;
			};

			editor.onSave = function(oldValue, newValue) {
				newValue = JSON.parse(newValue);

				if(!newValue.config) {
					newValue.config = {};
				}

				// flag for the backend processer that custom attributes
				// are selected by the user
				newValue.config.selectCustom = true;

				var actions = [
					{
						text: Ext.ux.getI18N("dialog.print.button.edit"),
						cls: "configurable",
						handler: function(list, entry) {
							that.showAttributeMapper(list, entry);
						}
					}
				];

				var newEntry = {
					showCaption: true,
					"class": "AttributeDataContainer",
					attributes: newValue,
					type: type,
					cls: "special",
					title: that.getAttributeName(type)
				};

				if(value) {
					var entry = list.find(function(e) {
						if(e.value["class"] !== "AttributeDataContainer") {
							return false;
						}

						return JSON.stringify(e.value.attributes) === JSON.stringify(JSON.parse(oldValue));
					});

					list.update(entry, that.getListValue(newEntry));
				} else {
					list.add(newEntry, actions);
				}
			};

			return editor;
		},

		getAttributeName: function(attribute) {
			return Ext.ux.getI18N("dialog.print.attribute." + attribute);
		},

		getAttributeStore: function() {
			var fields = ["active", "value", "title"];

			return new Ext.data.SimpleStore({
				fields: fields,
				reader: new Ext.data.ArrayReader({}, fields),
				data: [
					[true, "", ""],
					[true, "ownAttribute", this.getAttributeName("ownAttribute")],
					[true, "lastAuthor", this.getAttributeName("lastAuthor")],
					[true, "publishingDate", this.getAttributeName("publishingDate")],
					[true, "publishingStatus", this.getAttributeName("publishingStatus")],
					[true, "authors", this.getAttributeName("authors")],
					[true, "updateDate", this.getAttributeName("updateDate")],
					[true, "modelPath", this.getAttributeName("modelPath")],
					[true, "pageNumber", this.getAttributeName("pageNumber")],
					[true, "printDate", this.getAttributeName("printDate")],
					[true, "printedBy", this.getAttributeName("printedBy")]
				]
			});
		},

		getAttributeCombo: function(store) {
			var tpl = "" +
				'<tpl for=".">' +
					'<tpl if="active">' +
						"<div class='x-combo-list-item'>{title}</div>" +
					"</tpl>" +
					'<tpl if="!active">' +
						"<div class='x-combo-list-item item-inactive'>{title}</div>" +
					"</tpl>" +
				"</tpl>";

			return new Ext.ux.form.ComboBox({
				mode: "local",
				anchor: "-20",
				store: store,
				allowBlank: true,
				readOnly: true,
				cls: "pdf-attribute-selector-combo",
				ctCls: "configurable-container",
				listClass: "pdf-attribute-selector",
				tpl: new Ext.XTemplate(tpl)
			});
		},

		getListValue: function(value) {
			return {
				text: value.title,
				value: value,
				cls: value.cls
			};
		},

		getAttributeList: function(combo, store) {
			var that = this;

			var change = function(record, key, value) {
				store.suspendEvents();
				
				record.set(key, value);
				
				store.resumeEvents();
				store.fireEvent("datachanged");

				that.facade.raiseEvent("attributes.changed");
			};

			return new Signavio.ux.dialog.List({
				size: 3,
				labelCls: "configurable",
				emptyText: Ext.ux.getI18N("dialog.print.attribute.hint"),
				equals: function(a, b) {
					return a.value === b.value;
				},
				add: function(value, actions, clb) {
					var index = store.findBy(function(record) {
						return record.get("value") === value.type;
					});
					var record = store.getAt(index);
					var listValue = that.getListValue(value);

					listValue.actions = (actions || []).concat([
						{
							text: Ext.ux.getI18N("dialog.print.button.remove"),
							cls: "configurable",
							handler: function(list, entry) {
								list.remove(entry);

								change(record, "active", true);

								combo.setVisible(!list.full());
								combo.setWidth(combo.ownerCt.getInnerWidth() - 2 * Signavio.Config.COMPONENT_SPACING);
							}
						}
					]);

					Signavio.ux.dialog.List.prototype.add.call(this, listValue, clb);

					if(value["class"] === "ReportMetaDataContainer") {
						change(record, "active", false);
					}

					combo.setValue("");
					combo.setVisible(!this.full());
				}
			});
		},

		handleAttributeSelect: function(combo, list, record) {
			var type = record.get("value");

			if(!type) {
				return;
			}

			if(type === "ownAttribute") {
				var editor = this.getAttributeMapper(list, type);
				editor.onTriggerClick();

				combo.setValue("");

				return;
			}

			list.add({
				showCaption: true,
				"class": "ReportMetaDataContainer",
				type: type,
				title: record.get("title")
			});
		},

		showAttributeMapper: function(list, entry) {
			var type = entry.value.type;
			var value = entry.value.attributes;

			var editor = this.getAttributeMapper(list, type, value);
			editor.onTriggerClick();
		},

		listUpdate: function(list, entry) {
			if(entry.value["class"] !== "AttributeDataContainer") {
				return;
			}

			var label = list.getElement(entry);

			Signavio.Utils.defer(function() {
				// wait for the label to be rendered
			    new Ext.ToolTip({
					target: label,
					html: this.readableAttributeMapperValue(entry.value.attributes)
				});
			}, this);
		},

		createAttribute: function(width) {
			var store = this.getAttributeStore();
			var combo = this.getAttributeCombo(store);
			var list = this.getAttributeList(combo, store);

			var that = this;

			combo.on("select", function(field, record) {
				that.handleAttributeSelect(field, list, record);
			});

			list.on("rerender", function() {
				list.entries.each(function(entry) {
					that.listUpdate(list, entry);
				});
			});

			this.facade.registerOnEvent("configure.page", function(e, value) {
				if(!value) {
					return;
				}

				Signavio.Utils.defer(function() {
					combo.syncSize();
				});
			});

			return new Ext.Panel({
				border: false,
				collapsible: false,
				columnWidth: width,
				layout: "anchor",
				cls: "attribute",
				items: [list, combo],
				fetchValue: function(result) {
					result.containers.push(list.getValues());
				},
				loadValue: function(data) {
					var values = data.containers.shift();

					values.each(function(value) {
						var actions = [];

						if(value["class"] === "AttributeDataContainer") {
							actions.push({
								text: Ext.ux.getI18N("dialog.print.button.edit"),
								cls: "configurable",
								handler: function(list, entry) {
									that.showAttributeMapper(list, entry);
								}
							});

							value.cls = "special";
						}

						// translate the title of the attribute according to language
						value.title = that.getAttributeName(value.type);

						list.add(value, actions);
					});
				}
			});
		},

		createAttributes: function(number, cls) {
			var items = [];
			var that = this;

			number.times(function() {
				items.push(that.createAttribute(1/number));
			});

			var panel = new Ext.Panel({
				border: false,
				collapsible: false,
				anchor: "100%",
				layout: "column",
				cls: cls,
				items: items,
				fetchValue: function(result) {
					result.containers = result.containers || [];

					DATA_EXTRACTOR.call(this, result);
				},
				loadValue: DATA_INJECTOR
			});

			panel.setVisible(false);

			this.facade.registerOnEvent("show.headers", function(e, value) {
				panel.setVisible(value);
				panel.doLayout();
			});

			return panel;
		},

		getImageUrl: function(revivision) {
			return Signavio.Config.BACKEND_PATH +
				revivision +
				"/png" +
				"?" +
				Object.toQueryString(Ext.Ajax.getSecurityParameter());
		},

		getImage: function(revision) {
			return "<img src='" + this.getImageUrl(revision) + "' />";
		},

		loadPreviewImage: function(rel) {
			this.facade.raiseEvent("image.change", rel);
		},

		createPreviewImage: function(attrs) {
			var html = "";

			if(Signavio.Utils.isModel(attrs.diagram)) {
				html = this.getImage(attrs.diagram.get("rep").revision);
			}

			var preview = new Ext.Panel({
				border: false,
				anchor: "100%",
				collapsible: false,
				cls: "preview",
				html: html
			});

			this.facade.registerOnEvent("image.grayscale", function(e, value) {
				if(value) {
					preview.addClass("grayscale");
				} else {
					preview.removeClass("grayscale");
				}
			});

			var that = this;

			this.facade.registerOnEvent("image.change", function(e, src) {
				preview.getEl().update(that.getImage(src));
			});

			return preview;
		},

		createDiagramName: function() {
			return {
				border: false,
				collapsible: false,
				columnWidth: 0.7,
				cls: "diagram-name",
				html: Ext.ux.getI18N("dialog.print.diagram.name")
			};
		},

		createLogoUploadButton: function(panel, logo) {
			var that = this;
			
			var text = Ext.ux.getI18N("dialog.print.button.upload");

			if(logo) {
				text = logo.name;
			}

			var button = new Signavio.ux.dialog.Link({
				text: text,
				cls: "upload",
				handler: function() {
					var dialog = that.getUploadDialog();
					dialog.show();

					dialog.on("image.selected", function(image) {
						that.updateLogoButton(panel, button, image);
					});
				}
			});

			return button;
		},

		updateLogoButton: function(panel, button, image) {
			panel.value = {
				id: image.href,
				name: image.rep.name
			};

			panel.remove(button);
			panel.add(this.createLogoUploadButton(panel, panel.value));
			panel.doLayout();
		},

		getUploadDialog: function() {
			return new Signavio.ux.dialog.FileUpload(this.facade, {
				title: Ext.ux.getI18N("dialog.print.button.upload")
			});
		},

		createLogo: function() {
			var that = this;

			var panel = new Ext.Panel({
				border: false,
				collapsible: false,
				columnWidth: 0.3,
				cls: "logo",
				value: {},
				fetchValue: function(result) {
					result.logoFileId = this.value.id;
				},
				loadValue: function(data) {
					if(!data.logoFileId) {
						return;
					}

					Signavio.Core.StoreManager.getStore(data.logoFileId, true, function(store) {
						var info;

						store.each(function(record) {
							if(record.get("rel") !== "info") {
								return;
							}

							info = record;
						});

						if(!info) {
							return;
						}

						that.updateLogoButton(panel, button, {
							href: data.logoFileId,
							rep: info.get("rep")
						});
					});
				}
			});

			var button = this.createLogoUploadButton(panel);
			panel.add(button);

			return panel;
		},

		createHeader: function() {
			return new Ext.Panel({
				border: false,
				anchor: "100%",
				collapsible: false,
				height: 30,
				cls: "header",
				layout: "column",
				items: [
					this.createDiagramName(),
					this.createLogo()
				],
				fetchValue: DATA_EXTRACTOR,
				loadValue: DATA_INJECTOR
			});
		},

		createPage: function(attrs) {
			var preview = this.createPreviewImage(attrs);
			var header = this.createHeader();
			var top = this.createAttributes(3, "top-bar");
			var bottom = this.createAttributes(3, "bottom-bar");

			var that = this;

			var page = new Ext.Panel({
				border: false,
				collapsible: false,
				layout: "anchor",
				cls: "page-preview",
				padding: 40,
				items: [header,	top, preview, bottom],
				landscape: function() {
					var width = this.ownerCt.getInnerWidth() - this.padding;
					var height = width / 1.41;

					return this.setSize(width, height);
				},
				portrait: function() {
					var minHeight = 700;

					var height = Math.max(this.ownerCt.getInnerHeight() - this.padding, minHeight);
					var width = height / 1.41;

					return this.setSize(width, height);
				},
				fetchValue: DATA_EXTRACTOR,
				loadValue: DATA_INJECTOR,
				updatePreview: function() {
					var pad = Signavio.Config.COMPONENT_SPACING;
					var height = 0, padding = pad;

					if(!preview.rendered) {
						return;
					}

					[header, top, bottom].each(function(item) {
						if(!item.rendered) {
							return;
						}

						var size = item.getSize();
						
						height = height + size.height;

						if(item !== bottom) {
							padding = padding + size.height;
						}
					});

					height = page.getSize().height - height - pad;

					var image = preview.getEl().child("img");

					if(image) {
						image.setStyle("maxHeight", height + "px");
					}

					preview.setPosition(0, padding);
					preview.setWidth(page.getSize().width);
				},
				listeners: {
					render: function() {
						if(attrs.horizontal) {
							this.landscape();
						} else {
							this.portrait();
						}

						Signavio.Utils.defer(function() {
							that.facade.raiseEvent("configure.page", false);
						});
					}
				}
			});

			this.facade.registerOnEvent("show.headers", function(e, value) {
				if(!value) {
					page.addClass("no-headers");
				} else {
					page.removeClass("no-headers");
				}

				page.updatePreview();
			});

			this.facade.registerOnEvent("attributes.changed", page.updatePreview);
			this.facade.registerOnEvent("image.change", page.updatePreview);
			this.facade.registerOnEvent("configure.page", function(e, configure) {
				if(!configure) {
					return page.addClass("read-only");
				}

				page.removeClass("read-only");
				page.updatePreview();

				Signavio.Utils.defer(function() {
					page.doLayout();
				});
			});

			return page;
		},

		createPreview: function(attrs) {
			var page = this.createPage(attrs);

			return new Ext.Panel({
				border: false,
				columnWidth: 1,
				cls: "attributes",
				items: page,
				listeners: {
					render: function(comp) {
						comp.setHeight(comp.ownerCt.getInnerHeight());
					}
				},
				fetchValue: DATA_EXTRACTOR,
				loadValue: DATA_INJECTOR,
				updateOrientation: function(orientation) {
					if(!page.rendered) {
						return;
					}

					this.setHeight(this.ownerCt.getInnerHeight());

					orientation = orientation || this.orientation;
					this.orientation = orientation;

					if(orientation === ORIENTATION.LANDSCAPE) {
						page.landscape();
					} else {
						page.portrait();
					}

					page.updatePreview();
				}
			});
		}
	});
}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

ns("ux.dialog");

(function() {

	var RESOURCE = {
		UPLOAD: "upload",
		INTERNAL: "internal",
		EXTERNAL: "external"
	};

	Signavio.ux.dialog.FileUpload = function(facade, attrs) {
		attrs = attrs || {};

		this.facade = facade;

		attrs.disableUpload = attrs.disableUpload || this.fileUploadDisabled(facade);

		var form = this.createForm(attrs);

		var that = this;

		attrs.items = attrs.items || form;
		attrs.title = attrs.title || Ext.ux.getI18N("dialog.upload.title");
		attrs.width = 400;
		attrs.modal = true;
		attrs.buttons = [
			{
				text: "Speichern",
				handler: function() {
					form.getValue(function(value) {
						that.fireEvent("image.selected", value);

						that.close();
					});
				}
			}
		];

		attrs.cls = "file-upload";

		this.addEvents({
			"image.selected": true
		});

		Signavio.ux.dialog.FileUpload.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.dialog.FileUpload, Ext.ux.Window, {

		fileUploadDisabled: function(facade) {
			// TODO: unify if explorer and everything
			// else share the same facade
			if(facade.getConfig) {
				return facade.getConfig("department", "fileUpload") === false;
			} else {
				return !facade.getModelMetaData().fileupload;
			}
		},

		createForm: function(attrs) {
			var description = new Ext.form.Label({
				text: Ext.ux.getI18N("dialog.upload.label.description"),
				cls: "description"
			});

			var info = this.getInfo(attrs);
			var spacer = new Signavio.ux.form.Spacer({
				text: Ext.ux.getI18N("dialog.upload.label.choose.spacer")
			});

			return new Ext.Panel({
				border: false,
				cls: "form",
				getValue: function(clb) {
					this.items.each(function(item) {
						if(!item.getImage) {
							return;
						}

						item.getImage(clb);
					});
				},
				items: [description, info, spacer].concat(this.createFormItems(attrs))
			});
		},

		getConfig: function() {
			// Merge into one, when Explorer and everything else
			// share one facade
			if(this.facade.getConfig) {
				return this.facade.getConfig();
			}

			return this.facade.getModelMetaData();
		},

		getMaxSize: function() {
			var config = this.getConfig();

			return config.singleFileByteQuota;
		},

		getDescription: function(attrs) {
			if(attrs.disabled) {
				return Ext.ux.getI18N("dialog.upload.label.disabled");
			}

			if(attrs.disableUpload) {
				return Ext.ux.getI18N("dialog.upload.label.upload.disabled");
			}
			
			return Ext.ux.getI18N("dialog.upload.label.max.size") + Signavio.Utils.BeautifySize(this.getMaxSize());
		},

		getInfo: function(attrs) {
			return new Ext.form.Label({
				text: this.getDescription(attrs),
				cls: "description"
			});
		},

		createUploadForm: function(attrs) {
			var file = new Ext.form.TextField({
				inputType: "file",
				name: "file",
				cls: "x-upload-fiel-textfield",
				listeners: {
					render: function(comp) {
						if(!attrs.allowedTypes) {
							return;
						}

						comp.getEl().dom.setAttribute("accept", attrs.allowedTypes.join(","));
					}
				}
			});

			var folderPicker = new Signavio.ux.form.FolderPicker(this.facade, {
				name: "directory"
			});
			var securityParam = Signavio.Utils.getSecurityParameterField();

			var that = this;

			var component = new Ext.form.FormPanel({
				disabled: attrs.disabled || attrs.disableUpload,
				border: false,
				fileUpload: true,
				layout: "anchor",
				uploadImage: function(clb) {
					var title = attrs.title, message;

					if(!folderPicker.getValue()) {
						message = Ext.ux.getI18N("dialog.upload.error.no.folder.selected");

						that.showMessage(title, message);

						return;
					}

					if(!file.getValue()) {
						message = Ext.ux.getI18N("dialog.upload.error.no.file.selected");

						that.showMessage(title, message);

						return;
					}

					folderPicker.getEl().dom.value = folderPicker.getValue();

					var form = this.getForm();

					that.doUpload(form, clb);
				},
				items: [
					file,
					folderPicker,
					securityParam
				]
			});

			this.facade.registerOnEvent("upload.type.changed", function(e, type) {
				component.setDisabled(type !== RESOURCE.UPLOAD);
			});

			return component;
		},

		doUpload: function(form, clb) {
			form.errorReader = {
				read: function(e) {
					return {
						success: e.responseText.toLowerCase().replace(/<.*?pre.*?>/g, '').startsWith("{"),
						records: []
					};
				}
			};

			var that = this;

			that.body.mask(Ext.ux.getI18N("dialog.upload.action.upload"), "disabled");

			form.submit({
				url: "/p/file",
				waitMsg: Ext.ux.getI18N("dialog.upload.action.upload"),
				method: "POST",
				success: function(form, action) {
					that.body.unmask();
					
					var response = action.response;

					// TODO: TEST IN ALLEN BROWSERN
					// Might cause errors in the future of if special characters are transported
					// or strict mode is used
					var div = document.createElement("div");
					div.innerHTML = response.responseText;

					that.onUploadSuccess(JSON.parse(div.textContent), clb);
				},
				failure: function() {
					that.body.unmask();

					that.onUploadError(clb);
				}
			});
		},

		showMessage: function(title, message, clb) {
			Ext.MessageBox.show({
				title: title,
				msg: message,
				modal: true,
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.INFO,
				fn: function() {
					if(!clb) {
						return;
					}

					clb();
				}
			});
		},

		showErrorMessage: function(error) {
			var title = Ext.ux.getI18N("dialog.upload.error.file.too.big.title");

			switch(error) {
			case "file_size_violates_single_file_quota":
				this.showMessage(title, Ext.ux.getI18N("dialog.upload.error.file.too.big.single"));
				break;
			case "file_size_violates_all_files_quota":
				this.showMessage(title, Ext.ux.getI18N("dialog.upload.error.file.too.big.all"));
				break;
			}
		},

		onUploadSuccess: function(response, clb) {
			if(response.error) {
				return this.showErrorMessage(response.error);
			}

			clb(response);
		},

		onUploadError: function(clb) {
			var title = Ext.ux.getI18N("dialog.upload.error.file.too.big.title");
			var message = Ext.ux.getI18N("dialog.upload.error.file.too.big.description");

			this.showMessage(title, message, clb);
		},

		createFilePicker: function() {
			var component = new Signavio.ux.dialog.tree.Panel({
				height: 200,
				getImage: function() {
					var record = this.getSelectedRecord();

					if(!Signavio.Utils.isFile(record)) {
						return;
					}

					return record;
				},
				root: new Signavio.ux.dialog.tree.DefaultRoot(this.facade, {
					isChildLeaf: Signavio.Utils.isFile,
					recordRel: [
						Signavio.Const.REL.DIRECTORY,
						Signavio.Const.REL.FILE
					]
				})
			});

			this.facade.registerOnEvent("upload.type.changed", function(e, type) {
				component.setDisabled(type !== RESOURCE.INTERNAL);
			});

			return component;
		},

		createFile: function(attrs, items) {
			var that = this;

			var fileSwitch = new Ext.form.Radio({
				disabled: attrs.disabled,
				checked: !attrs.disabled && attrs.disableUpload,
				name: "upload.type",
				boxLabel: Ext.ux.getI18N("dialog.upload.label.existing.file"),
				getImage: function(clb) {
					if(!this.getValue()) {
						return;
					}

					var image = filePicker.getImage();

					if(!image) {
						var title = Ext.ux.getI18N(attrs.title);
						var message = Ext.ux.getI18N("dialog.upload.error.no.image.selected");
						
						that.showMessage(title, message);

						return;
					}

					clb(image.data);
				},
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.facade.raiseEvent("upload.type.changed", RESOURCE.INTERNAL);
					}
				}
			});

			var filePicker = this.createFilePicker(attrs);

			items.push(fileSwitch, filePicker);
		},

		createUpload: function(attrs, items) {
			var that = this;

			var uploadForm = this.createUploadForm(attrs);
			var uploadSwitch = new Ext.form.Radio({
				disabled: attrs.disabled || attrs.disableUpload,
				checked: !attrs.disabled && !attrs.disableUpload,
				name: "upload.type",
				boxLabel: Ext.ux.getI18N("dialog.upload.label.new.file"),
				getImage: function(clb) {
					if(!this.getValue()) {
						return;
					}

					uploadForm.uploadImage(function(image) {
						if(!image) {
							return;
						}
						
						clb(image);
					});
				},
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.facade.raiseEvent("upload.type.changed", RESOURCE.UPLOAD);
					}
				}
			});

			items.push(uploadSwitch, uploadForm);
		},

		createUrlForm: function(attrs) {
			var component = new Ext.ux.form.UrlLinkFieldList({
				disabled: !attrs.allowExternals,
				emptyListText: Ext.ux.getI18N("dialog.upload.label.external.empty")
			});

			this.facade.registerOnEvent("upload.type.changed", function(e, type) {
				component.setDisabled(type !== RESOURCE.EXTERNAL);
			});

			return component;
		},

		createUrl: function(attrs, items) {
			var that = this;

			var urlForm = this.createUrlForm(attrs);
			var urlSwitch = new Ext.form.Radio({
				name: "upload.type",
				boxLabel: Ext.ux.getI18N("dialog.upload.label.external.file"),
				disabled: !attrs.allowExternals,
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.facade.raiseEvent("upload.type.changed", RESOURCE.EXTERNAL);
					}
				}
			});

			items.push(urlSwitch, urlForm);
		},

		createFormItems: function(attrs) {
			var items = [];

			this.createUpload(attrs, items);

			items.push(new Signavio.ux.form.Spacer({
				text: Ext.ux.getI18N("dialog.upload.label.spacer.or")
			}));

			this.createFile(attrs, items);

			if(!attrs.allowExternals) {
				// Hide the third option and not only disable it.
				return items;
			}

			items.push(new Signavio.ux.form.Spacer({
				text: Ext.ux.getI18N("dialog.upload.label.spacer.or")
			}));

			this.createUrl(attrs, items);

			return items;
		}

	});

}());
/**
 *  (c) 2010 Signavio GmbH
 *
 *  @author Willi Tscheschner
 *
 *  UX is a shared javascript library which provides common
 *  functionalities for all applications in the Signavio Process Editor
 *
 */


new function(){


	/**
	 * URL for the ROOT image folder
	 */
	Ext.IMAGE_URL = "/images";

	/**
	 * Fixes for the user agent
	 */

	// IE
	Ext.getIEdocumentMode = function() {
		return (document||{}).documentMode;
	}
	
	Ext.isIE8 = Ext.isIE && Ext.getIEdocumentMode() == 8; //String(window.navigator.userAgent).include("MSIE 8.");
	Ext.isIE9 = Ext.isIE && Ext.getIEdocumentMode() == 9; //String(window.navigator.userAgent).include("MSIE 9.");
	Ext.isIE10 = Ext.isIE && Ext.getIEdocumentMode() == 10; //String(window.navigator.userAgent).include("MSIE 10.");

	// Fix recognition of IE7 in Ext
	if(Ext.isIE7) {
		if(Ext.getIEdocumentMode() && Ext.getIEdocumentMode() != 7) {
			Ext.isIE7 = false;
		}
	}

	Ext.isIE6 = Ext.isIE6 && !Ext.isIE8 && !Ext.isIE9 && !Ext.isIE10;

	if (Ext.isIE){

		// Check for IE9 compatiblity view
		// IE 9 no Compatibility -> "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)"
		// IE 9    Compatibility -> "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0)"
		Ext.isIECompatibility = parseInt((window.navigator.userAgent.match(/Mozilla\/([0-9.]+)/i)||[])[1]) <= 4 &&
								parseInt((window.navigator.userAgent.match(/Trident\/([0-9.]+)/i)||[])[1]) >= 5;
	}

	// Chrome
	Ext.isChrome = String(window.navigator.userAgent).include("Chrome/");

	// Firefox
	Ext.isFF3 = String(window.navigator.userAgent).include("Firefox/3.6");
	Ext.isFF = String(window.navigator.userAgent).include("Firefox") && !Ext.isFF3;

	/**
	 * Returns the browser version of the current client
	 * @returns {Float}
	 */
	Ext.getBrowserVersion = function(){
		if (Ext.isIE){
			return Ext.getIEdocumentMode() || parseFloat(window.navigator.userAgent.match(/MSIE ([0-9\.]+)/i)[1]);
		}
		return parseFloat(window.navigator.userAgent.split("/")[3]);
	};

	/**
	 * IE9 Fixes
	 */
	if (Ext.isIE9 /*|| Ext.isIECompatibility*/){
		(function(){
			// @overwrite
			Element.hasClassName = Element.Methods.hasClassName = function(element, className) {
			    if (!(element = $(element))) return;
			    var elementClassName = element.getAttribute("class") || "";
			    return (elementClassName.length > 0 && (elementClassName == className ||
			      new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
			};

			// @overwrite
			var inHtml = Ext.DomHelper.insertHtml;
			Ext.DomHelper.insertHtml = function(foo, bar, html){
				html = html.gsub("ext:qtip=", "title="); // IE9 doesn't support insertion of namespace conform xml attributes
				html = html.gsub("ext:tree-node-id=", "tree-node-id=");
				return inHtml.call(this, foo, bar, html);
			};

			// Implementation of a missing function
			if (window.Range && !(Range.prototype.createContextualFragment instanceof Function)){
				Range.prototype.createContextualFragment = function(html){
	        		var node = document.createElement("div");
	        		node.innerHTML = html;
	        		return node.children[0];
	        	};
	        }

			// Implementation for missing setValue-Method for HTMLInputElement
			HTMLInputElement.prototype.setValue = function(value){
				if (this.type === "checkbox"){
					this.checked = value;
				}
			};

			(function() {
				// Used with IE9 jQuery 1.4.1 and Prototype 1.6 influence each 
				// other in a way that document.documentElement and document.body 
				// are missing. However, jQuery needs these two in order for the 
				// width/height methods to be working.
				//
				// Source: http://bugs.jquery.com/ticket/6431
				if(window.DocumentFragment && !DocumentFragment.prototype.documentElement) {
					DocumentFragment.prototype.documentElement = {};
				}

				if(window.DocumentFragment && !DocumentFragment.prototype.body) {
					DocumentFragment.prototype.body = {};
				}
			}());

			// Remove namespace awareness of node ids
			Ext.tree.TreeEventModel.prototype.getNode = function(e){
		        var t;
		        if(t = e.getTarget('.x-tree-node-el', 10)){
		            var id;
		            if (Ext.fly(t, '_treeEvents').dom.getAttributeNS instanceof Function){
		            	id = Ext.fly(t, '_treeEvents').dom.getAttributeNS(null, 'tree-node-id');
		            } else {
		            	id = Ext.fly(t, '_treeEvents').dom.getAttribute('tree-node-id');
		            }
		            if(id){
		                return this.tree.getNodeById(id);
		            }
		        }
		        return null;
		    };

		    // @overwrite
		    var update = Ext.Element.prototype.update;
		    Ext.Element.prototype.update = function(html, foo, bar){
		    	update.call(this, String(html||"").gsub(decodeURI("%EF%BF%BFu201e"), "Ä"), foo, bar);
		    };

		}());
	}

	/**
	 * IE10 Fixes
	 */

	if (Ext.isIE10){

		// @overwrite
		Element.hasClassName = Element.Methods.hasClassName = function(element, className) {
		    if (!(element = $(element))) return;
		    var elementClassName = element.getAttribute("class") || "";
		    return (elementClassName.length > 0 && (elementClassName == className ||
		      new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
		};

		// Implementation of a missing function
		if (window.Range && !(Range.prototype.createContextualFragment instanceof Function)){
			Range.prototype.createContextualFragment = function(html){
        		var node = document.createElement("div");
        		node.innerHTML = html;
        		return node.children[0];
        	};
        }

		// @overwrite
		var inHtml = Ext.DomHelper.insertHtml;
		Ext.DomHelper.insertHtml = function(foo, bar, html){
			html = html.gsub("ext:qtip=", "title="); // IE10 doesn't support insertion of namespace conform xml attributes
			html = html.gsub("ext:tree-node-id=", "tree-node-id=");
			return inHtml.call(this, foo, bar, html);
		};

		// Implementation for missing setValue-Method for HTMLInputElement
		HTMLInputElement.prototype.setValue = function(value){
			if (this.type === "checkbox"){
				this.checked = value;
			}
		};


		// Remove namespace awareness of node ids
		Ext.tree.TreeEventModel.prototype.getNode = function(e){
	        var t;
	        if(t = e.getTarget('.x-tree-node-el', 10)){
	            var id;
	            if (Ext.fly(t, '_treeEvents').dom.getAttributeNS instanceof Function){
	            	id = Ext.fly(t, '_treeEvents').dom.getAttributeNS(null, 'tree-node-id');
	            } else {
	            	id = Ext.fly(t, '_treeEvents').dom.getAttribute('tree-node-id');
	            }
	            if(id){
	                return this.tree.getNodeById(id);
	            }
	        }
	        return null;
	    };



	}
	/**
	 * Chrome Fixes
	 */
	if (Ext.isChrome || Ext.isSafari){
		(function(){

			// Fixes for Chrome Bug
			// http://code.google.com/p/chromium/issues/detail?id=58493

			// Check if there exists the bug in the current chrome version
//			var parseNode = (new DOMParser()).parseFromString("<div ext:qtip='tooltip'></div>", "text/xml");
//			if (parseNode.getElementsByTagName("parsererror").length == 0){
//
//				(function(){
//					var inHtml = Ext.DomHelper.insertHtml;
//					Ext.DomHelper.insertHtml = function(foo, bar, html){
//						html = html.gsub(" ext:", " xmlns:ext=\"http://b3mn.org/2007/ext\" ext:");
//						return inHtml.call(this, foo, bar, html);
//					};
//				}());
//
//				return;
//			}

			// @overwrite
			var inHtml = Ext.DomHelper.insertHtml;
			Ext.DomHelper.insertHtml = function(foo, bar, html){
				html = html.gsub("ext:qtip=", "title=");
				html = html.gsub("ext:tree-node-id=", "tree-node-id=");
				return inHtml.call(this, foo, bar, html);
			};

			// Remove namespace awareness of node ids
			Ext.tree.TreeEventModel.prototype.getNode = function(e){
		        var t;
		        if(t = e.getTarget('.x-tree-node-el', 10)){
		            var id = Ext.fly(t, '_treeEvents').dom.getAttributeNS(null, 'tree-node-id');
		            if(id){
		                return this.tree.getNodeById(id);
		            }
		        }
		        return null;
		    };

		    // Fix use of ext namespaces
		    Ext.Template.prototype.overwrite = function(el, values, returnElement){
		        el = Ext.getDom(el);
		        el.innerHTML = this.applyTemplate(values).gsub(" ext:qtip=", " title=");
		        return returnElement ? Ext.get(el.firstChild, true) : el.firstChild;
		    };

		}());
	}


	/**
	 * General Ext Bugfix Section
	 */


	/**
	 * Sometimes it happens that the wrap element was not in the
	 * dom anymore, but the method get still called, which leads
	 * into problems (mainly in IE9). So now, a parent exist
	 * check get performed prior.
	 *
	 */
	Ext.Element.prototype.fxUnwrap = function(wrap){
		if (wrap.dom.parentNode){
			Ext.Fx.fxUnwrap.apply(this, arguments);
		}
	};

	/**
	 * Sometimes it happens that no anchor exists, so when calling
	 * focus on it, it simply drops into the empty catch block, which
	 * is somewhat desired behaviour. However, firebug breaks on it
	 * since it's an evil bug and prevents the page from loading.
	 *
	 */
	Ext.tree.TreeNodeUI.prototype.focus = function(){
	    if(!this.node.preventHScroll){
	        try{this.anchor.focus();
	        }catch(e){}
	    }else if(!Ext.isIE){
	        try{
	            var noscroll = this.node.getOwnerTree().getTreeEl().dom;
	            var l = noscroll.scrollLeft;
	            this.anchor && this.anchor.focus();
	            noscroll.scrollLeft = l;
	        }catch(e){}
	    }
	};

	Ext.form.NumberField.create = function(args) {
		args = args || {};

		var fallback = args.decimalSeparator;
		var language = Signavio.Utils.getApplicationLanguage();
		var separator = Signavio.Utils.getDecimalSeparator(language, fallback);

		args.decimalSeparator = separator;

		if(args.allowNegative === false) {
			// If you are quick enough you can trick negative values
			// into the field even if the allowNegative flag ist set
			// to false. This function ensures that really no negative
			// values get into the field.
			args.parseValue = function(value) {
                value = Ext.form.NumberField.prototype.parseValue.call(this, value);

                if(value < 0) {
                    value = -value;
                }

                return isNaN(value) ? "" : value;
            };
		}

		return new Ext.form.NumberField(args);
	};

	/**
	 * The Date.formatCodeToRegex function returns an erroneous regex
	 * group for the format parameter 'z'. This should fix it
	 */
	Date.originalFormatCodeToRegex = Date.formatCodeToRegex;
	Date.formatCodeToRegex = function(character, currentGroup) {
		var date = Date.originalFormatCodeToRegex(character, currentGroup);
		if (character === "z") {
			date.s += ")";
		}
		return date;
	};
	
	/**
	 * A get method which returns the first record with an exact match of field and value 
	 * or undefined if no record could be found.
	 * 
	 * @param field name of the field
	 * @param value the value to be matched
	 */
	Ext.data.Store.prototype.get = function(field, value) {
		return this.getRange().find(function(r) {
			return r.get(field) === value;
		});
	};
    
    /**
     * Returns the range for the given start and end and bypasses any filter.
     *
     * @param start start index
     * @param end end index
     */
    Ext.data.Store.prototype.getRawRange = function(start, end) {
    	if (this.snapshot) {
    		return this.snapshot.getRange(start, end);
    	} else {
    		return this.getRange(start, end);
    	}
    };

    if(!Ext.data.Store.prototype.select) {
    	Ext.data.Store.prototype.select = function(clb) {
    		var result = [];

    		this.each(function(record) {
    			if(clb(record) !== true) {
    				return;
    			}

    			result.push(record);
    		});

    		return result;
    	};
    }

    if(!Ext.data.Store.prototype.touch) {
    	Ext.data.Store.prototype.touch = function(ref) {
			var args = $A(arguments).slice(1);

			this.suspendEvents();

			args.each(function(record) {
				record.set(ref, Object.clone(record.get(ref)));
			});

			this.resumeEvents();
    	};
    }

    if(!Ext.data.Store.prototype.first) {
    	Ext.data.Store.prototype.first = function(clb) {
    		var index = this.findBy(clb);

    		return this.getAt(index);
    	};
    }

    if(!Ext.data.Store.prototype.contains) {
    	Ext.data.Store.prototype.contains = function(record) {
    		var href = record.get("href");

    		return !!this.first(function(r) {
				return r.get("href") === href;
    		});
    	};
    }

    if(!Ext.data.Store.prototype.getRecords) {
    	Ext.data.Store.prototype.getRecords = function(rel) {
    		var records = [];

    		if(rel && !(rel instanceof Array)) {
    			rel = [rel];
    		}
			
			(this.snapshot || this.data).each(function(record){
				if(rel && !rel.include(record.get("rel"))) {
					return;
				}

				records.push(record);
			});

			return records;
    	};
    }
    
    /**
     * Just updates the value for the given name and bypasses all callbacks and events.
     * WARNING: Just use this function if you know, what you do!
     *
     * @param name key of the field
     * @param value the new value
     */
    Ext.data.Record.prototype.setRaw = function(name, value) {
        this.data[name] = value;
    };
    
    /**
     * Extension of the original select method that allows to prevent the method from firing a select event.
     * This is useful if you want to select a color in the palette from your code.
     * @param {String} color the color to select
     * @param {Boolean} preventEvents true if no events shall be fired
     */
    Ext.ColorPalette.prototype.select = function(color, preventEvents) {
        color = color.replace("#", "");
        if(color != this.value || this.allowReselect){
            var el = this.el;
            if(this.value){
                var oldChild = el.child("a.color-"+this.value);
                if (oldChild) {
                    oldChild.removeClass("x-color-palette-sel");
                }
            }
            var child = el.child("a.color-"+color);
            if (child) {
                child.addClass("x-color-palette-sel");
            }
            this.value = color;
            if (!preventEvents) {
                this.fireEvent("select", this, color);
            }
        }
    };
    
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" == typeof window.Ext){ window.Ext = {}; }
if ("undefined" == typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" == typeof Ext.ux.form){ Ext.ux.form = {}; }

new function(){
	
	/**
	 * Class for a generic combo box
	 * 
	 * @class
	 * @param attr
	 * @return
	 */
	Ext.ux.form.ComboBox = function(attr){

		if (!attr.store && attr.url){
			var store = new Ext.data.JsonStore({
				url: attr.url,
			    fields: ['value', 'title']
			});
			// Set proxy for GET-Method
			store.proxy = new Ext.data.HttpProxy({url: attr.url, method:"GET"});
			store.relayEvents(store.proxy,  ["loadexception"]);
			
			// If optional, add an empty record
			if (attr.allowBlank) {
				store.reader.readRecords  = function(o){
					o.unshift({value:"", title:""});
					return Ext.data.JsonReader.prototype.readRecords.apply(this, [o]);
				}
			}
			attr.store = store;
		}	
								
		// Call super
	    Ext.ux.form.ComboBox.superclass.constructor.call(this, attr);	    
	};
	
	Ext.extend(Ext.ux.form.ComboBox, Ext.form.ComboBox, {
		
		loadingText: "<i>Loading...</i>",
		exceptionText: "Data could not been loaded.",
		selectOnFocus: true,
	    displayField:'title',
		valueField: 'value',
	    triggerAction: 'all',
		queryParam: 'q',
		minChars: 2,
		
		/**
		 * @cfg {Boolean} preventFromDisable
		 * If set to true, the Button can't be disabled.
		 */
		preventFromDisable  : false,
		
		/**
		 * @cfg {Boolean} preventFromEnable
		 * If set to true, the Button can't be enabled.
		 */
		preventFromEnable	: false,
		
		
		/**
		 * Returns the value of the combo box
		 * Workaround for applying user defined values to the field, overriding
		 * Ext's default way.
		 */
		getValue : function(){
			if(!this.forceSelection){
				var value = Ext.form.ComboBox.superclass.getValue.call(this);
                if(value != this.lastSelectionText) {
                	this.setValue(value);
                }
			}
			if(this.valueField){
            	return typeof this.value != 'undefined' ? this.value : '';
            } else {
            	return Ext.form.ComboBox.superclass.getValue.call(this);
            }
		},
		
//		getValue: function(){
//			if (!this.forceSelection&&!this.value)
//				return Ext.form.ComboBox.superclass.getValue.call(this);
//			return Ext.ux.form.ComboBox.superclass.getValue.call(this);
//		},
		
	    onLoad : function(){
	        if(!this.hasFocus){
	            return;
	        }
	        if(this.store.getCount() > 0){
	            this.expand();
	            this.restrictHeight();
	            if(this.lastQuery == this.allQuery){
	                if(this.editable){
	                    this.el.dom.select();
	                }
	                if(!this.selectByValue(this.value, true)){
	                    this.select(0, true);
	                }
	            } else {
					if (this.selectedIndex !== -1 || this.forceSelection){
						this.selectNext();
					}
	                if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
	                    this.taTask.delay(this.typeAheadDelay);
	                }
	            }
	        }else{
	            this.onEmptyResults();
	        }
	        //this.el.focus();
	    },
	    
	    /**
	     * Get called if an exception is raised while loading the data
	     */
	    onLoadException: function(){
	    	if (this.exceptionText){
	    		 this.innerList.update('<div class="x-exception-indicator">'+this.exceptionText+'</div>');
	    	}
	    },

	    onViewClick : function(doFocus){
	        var index = this.view.getSelectedIndexes()[0];
	        var r = this.store.getAt(index);
	        if(r){
	            this.onSelect(r, index);
	        } else if (!this.forceSelection) {
				this.setValue(Ext.form.ComboBox.superclass.getValue.call(this));
				this.collapse();
			}
	        if(doFocus !== false){
	            this.el.focus();
	        }
	    },
		
	    // private
	    onTypeAhead : function(){
	        if(this.store.getCount() > 0){
	            var r = this.store.getAt(0);
	            var newValue = r.data[this.displayField];
	            var len = newValue.length;
	            var selStart = this.getRawValue().length;
	            if(newValue && selStart != len){
	                this.setRawValue(newValue);
	                this.selectText(selStart, newValue.length);
	            }
	        }
	    },
	    
	    /**
		 * Set true to prevent the button from being disabled
		 * @param {Boolean} prevent
		 */
		setPreventFromDisable : function(prevent) {
			this.preventFromDisable = prevent;
		},
		
		/**
		 * Set true to prevent the button from being enabled
		 * @param {Boolean} prevent
		 */
		setPreventFromEnable : function(prevent) {
			this.preventFromEnable = prevent;
		},
		
		/**
		 * Convenient method to check if the button can be disabled.
		 * @returns {Boolean}
		 */
		getPreventFromDisable : function() {
			return this.preventFromDisable;
		},		
		
		/**
		 * Convenient method to check if the button can be enabled.
		 * @returns {Boolean}
		 */
		getPreventFromEnable : function() {
			return this.preventFromEnable;
		},		
		
		/**
	     * Convenient function for setting disabled/enabled by boolean. If preventFromDisable is true, it is not
	     * possible to disable the button.
	     * @override
	     * @param {Boolean} disabled
	     */
	    setDisabled : function(disabled){
        	this[disabled && !this.preventFromDisable ? "disable" : "enable"]();
	    },
	    
	    /**
	     * Disables the button if it's not forbidden
	     * @returns {Ext.ux.Toolbar.Button} this
	     */
	    disable : function() {
	    	if (!this.preventFromDisable) {
		    	if(this.rendered){
		            this.onDisable();
		        }
		        this.disabled = true;
		        this.fireEvent("disable", this);
	    	} 
	        return this;

	    },
	    
	    /**
	     * Enables the button if it's not forbidden
	     * @returns {Ext.ux.Toolbar.Button} this
	     */
	    enable : function() {
	    	if (!this.preventFromEnable) {
	    		if(this.rendered){
		            this.onEnable();
		        }
		        this.disabled = false;
		        this.fireEvent("enable", this);
	    	}
	    	return this;
	    },
	    /**
	     * Overwrites the bindStore method to enable loading exception indication
	     * @param store
	     * @param initial
	     */
	    bindStore: function(store, initial){
	    	if (this.exceptionText){
		    	if(this.store && !initial){
		            this.store.un('loadexception', this.onLoadException, this);
		    	}
		    	if(store){
		            store.on('loadexception', this.onLoadException, this);
		    	}
	    	}
	    	Ext.ux.form.ComboBox.superclass.bindStore.apply(this, arguments);
	    	if (this.exceptionText){
	    		if(this.store){
	    			 this.store.un('loadexception', this.collapse, this);
		    	}
	    	}
	    }
    });
	
}();
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

 if(!Ext) { var Ext = {}; }
 if(!Ext.ux) { Ext.ux = {}; }
 if(!Ext.ux.form) { Ext.ux.form = {}; }
 
 (function() {
 
     Ext.ux.form.ComboFieldList = function(attr) {
         
         this.values = [];
         
         Ext.ux.form.ComboFieldList.superclass.constructor.call(this, attr);
     };
     
     Ext.extend(Ext.ux.form.ComboFieldList, Ext.ux.form.ComboBox, {
         
         ctCls: "x-form-textfield-list",
         
         exists: function(value) {
             var existing = this.values.find(function(el) {
                 if(el[1] === value) {
                     return true;
                 }
             });  
            
             return !!existing;
         },
         
         addValue: function(value) {
             if(!this.exists(value)) {
                 var index = this.store.findBy(function(record) {
                     if(record.get("value") === value) {
                         return true;
                     } 
                 });
                 
                 var record = this.store.getAt(index);
                 
                 if(record) {
                     this.values = this.values.concat([[record.get("title"), record.get("value")]]);
                 }
             }
         },
         
         onRender: function() {
             Ext.ux.form.ComboFieldList.superclass.onRender.apply(this, arguments);
             
             this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {
                tag: 'div',
                style: 'margin: 1px 0px 0px 0px; display:none;' + this.listStyle
            }));
            
            if(!this.itemFieldTpl) {
                this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty"></span></tpl>',
                							'<tpl for=".">',
                								'<span class="y-filter-combo-list">{[Signavio.Utils.escapeHTML(values[0])]} ', 
                									'<span class="x-smaller">', 
                                                        '(', 
                                                            '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>',
                                                        ')',
                                                    '</span>', 
                								'</span>',
                							 '</tpl>');
            }
            
            this.updateView();
            
            var wrap = this.wrap.boxWrap();
			wrap.child(".x-box-mc");
         },
         
         onUpdateView: Ext.emptyFn,
         
        updateView: function() {
            if(!this.itemFieldTpl || !this.itemField) {
                return;
            }
            
            this.itemFieldTpl.overwrite(this.itemField, this.values || []);
            this.itemField.setDisplayed((this.values || []).length > 0);
            
            this.updateEvents();
            
            if(this.ownerCt && this.ownerCt.updateSize) {
                this.ownerCt.updateSize();
            }
            
            this.onUpdateView();
        },
        
        updateEvents: function() {
        
            var getId = function(el){
                return parseInt(el.getAttribute("href").split('#').last());
            };
            
            this.itemField.select("a.x-remove").on("click", function(e, t) {
                Event.stop(e);
                
                var index = getId(t);
                this.remove(index);
                this.updateView();
            }.bind(this));
            
        },
        
        remove: function(index) {
            delete this.values[index];
            this.values = this.values.compact();
        },
        
        onSelect: function(record) {
            Ext.ux.form.ComboFieldList.superclass.onSelect.call(this, record);

            var value = record.get("value");
            
            this.setRawValue("");
            this.setValue(value);  
        },

        getValue: function(){
			return this.values.clone();
		},
        
        setValue: function(value) {
            if(value instanceof Array) {
                this.values = value.clone();
            } else {
                this.addValue(value);
            }
            
            this.updateView();
        }
         
     });
 
 })();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { window.Ext = {}; }
if(!Ext.form) { Ext.form = {}; }

(function() {
   
    Ext.form.ComplexTextField = Ext.extend(Ext.form.TriggerField,  {
        
        defaultAutoCreate : {tag: "textarea", rows:1, style:"height:16px;overflow:hidden;" },
    
        /**
         * If the trigger was clicked a dialog has to be opened
         * to enter the values for the complex property.
         */
        onTriggerClick : function(){
            
            if(this.disabled){
                return;
            }   

            var selection = (this.facade.getSelection().length > 0 ? this.facade.getSelection()[0] : this.facade.getCanvas());
            
            if (this.dataSource){
                var values = this.events.dialogclosed.listeners[0].scope.scope.shapeSelection.commonPropertiesValues, 
                    property = this.dataSource.getAt(this.row).get("gridProperties").property,
                    buttons = [];
                
                if (ORYX.CONFIG.MULTI_LANGUAGES_ENABLED && property.language()){
                    var oprop = property.origin();
                    $H(ORYX.CONFIG.MULTI_LANGUAGES||{}).keys().any(function(lang){
                        var key = oprop.prefix() + "-" + oprop.id() + (lang == ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT ? "" : "_" + lang );
                        if (property.language() != lang && (values[key]||"") != oprop.value()){
                            buttons.push({
                                icon: ORYX.CONFIG.EXPLORER_PATH + "/src/img/flags/" + ORYX.CONFIG.MULTI_LANGUAGES[lang],
                                iconCls: "x-dummy",
                                text: " <img src='"+Ext.IMAGE_URL+"/famfamfam/bullet_go.png' style='margin-bottom:-5px;margin-left:-13px;margin-right:-5px;position:relative;'/>",
                                handler: function(){
                                    grid.setValue([grid.getValue()||"", Ext.ux.Richtext.encode(values[key], selection.getFormat(key))||undefined].compact().join("\n"));
                                    // If the grid is an advanced richtext grid, log the changes after setting the value 
                                    if ("function" === typeof grid.logKeys) {
                                        grid.logKeys();
                                    }
                                }
                            });
                        }
                    }.bind(this));
                }
            }
            
            /*
             * Create an advanced editor grid if richtext step 2 is enabled
             */
            if (ORYX.CONFIG.RICHTEXT_2_ENABLED) {
                var id = this.property ? this.property.id() : this.dataSource.getAt(this.row).data.gridProperties.propId;
                var json = (selection.getFormat(id)||[]);
                var grid = new Ext.ux.form.RichtextEditor({
                    enableSourceEdit: false,
                    anchor          : '100% 100%',
                    value           : (this.value === '' ? '<br/>' : Ext.ux.Richtext.encode(this.value, json)),
                    modal           : true,
                    ctCls           : 'y-richtext-editor' + (Ext.isIE9 ? ' y-richtext-editor-ie9' : Ext.isChrome ? ' y-richtext-editor-chrome' : ''),
                    listeners       : {
                        initialize  : function(comp) {
                            this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
                        }.bind(this),
                        destroy     : function() {
                            this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
                        }.bind(this)
                    },
                    // Add the multi language support button to the richtext editor's toolbar
                    tbar            : (buttons && buttons.length > 0) ? buttons : undefined
                });
            } else {
                // Else create only a normal text area
                var grid = new Ext.form.TextArea({
                    anchor      : '100% 100%',
                    value       : this.value,
                    listeners   : {
                        focus: function(){
                            if (this.facade)
                                this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
                        }.bind(this)
                    }
                });
            }
            
            
            var dialog = this.getEditorWindow(grid, buttons);
            
            if (!dialog) {
                return;
            }
            dialog.show();      
            grid.render();
            
            if (this.grid)
                this.grid.stopEditing();
            grid.focus( false, 100 );
            
        },
        
        /**
         * Returns a new window for editing text blocks.
         * If richtext 2 functionality is enabled, an advanced editor is used, else only a basic editor.
         * @param grid
         * @param buttons
         * @returns {Ext.Window}
         */
        getEditorWindow : function(grid, buttons) {
            if (ORYX.CONFIG.RICHTEXT_2_ENABLED) {
                // Advanced Richtext Dialogue
                var dialog = new Ext.Window({ 
                    layout      : 'anchor',
                    autoCreate  : true, 
                    // Get the title of the property to change
                    title       : (this.dataSource ? this.dataSource.getAt(this.row).get("gridProperties").property.title() : ORYX.I18N.PropertyWindow.text), 
                    height      : 500,
                    width       : 650,
                    minWidth    : 600,
                    modal       : true, 
                    shadow      : true,
//                  tbar        : (buttons && buttons.length > 0) ? buttons : undefined,
                    keys:[{
                        key : 27,
                        fn  : function(){
                                dialog.hide();
                        }.bind(this)
                    }],
                    items       :[grid],
                    listeners   :{
                        hide: function(){
                            dialog.destroy();
                        }.bind(this)
                    },
                    tools       : [
                                   {
                                       id       : "maximize",
                                       handler  : function(foo, bar, panel) {
                                           panel.maximize();
                                       }
                                   }, {
                                       id       : "restore",
                                       hidden   : true,
                                       handler  : function(foo, barr, panel) {
                                           panel.restore();
                                       }
                                   }
                    ],
                    
                    buttons     : [{
                        /*
                         * The OK Button in the richtext editor
                         */
                        text: ORYX.I18N.PropertyWindow.ok,
                        handler: function(){     
                            // Get the plain text to display in the property window
                            //XXX
                            var content = Ext.ux.Richtext.decode(grid.body);
                            
                            this.value = content.text;
                            this.newFormat = content.format;
                            this.setValue(this.value);
                            
                            if (this.dataSource) {
                                this.dataSource.getAt(this.row).set('value', this.value);
                                this.dataSource.commitChanges();
                            }

                            this.fireEvent('dialogClosed', this.value, this.newFormat);
                            dialog.hide();
                        }.bind(this)
                    }, {
                        /*
                         * The Cancel Button in the richtext editor
                         */
                        text: ORYX.I18N.PropertyWindow.cancel,
                        handler: function(){
                            //this.setValue(this.value);
                            dialog.hide();
                        }.bind(this)
                    }]
                });     
            } else {
                // Basic Dialogue
                var dialog = new Ext.Window({ 
                    layout      : 'anchor',
                    autoCreate  : true, 
                    title       : ORYX.I18N.PropertyWindow.text, 
                    height      : 500, 
                    width       : 500, 
                    modal       : true,
                    collapsible : false,
                    fixedcenter : true, 
                    shadow      : true, 
                    proxyDrag   : true,
                    tbar        : (buttons && buttons.length > 0) ? buttons : undefined,
                    keys:[{
                        key : 27,
                        fn  : function(){
                                dialog.hide();
                        }.bind(this)
                    }],
                    items       :[grid],
                    listeners   :{
                        hide: function(){
                            this.fireEvent('dialogClosed', this.value);
                            dialog.destroy();
                        }.bind(this)                
                    },
                    buttons     : [{
                        text: ORYX.I18N.PropertyWindow.ok,
                        handler: function(){     
                            // store dialog input
                            var value = grid.getValue();
                            this.setValue(value);
                            
                            if (this.dataSource) {
                                this.dataSource.getAt(this.row).set('value', value);
                                this.dataSource.commitChanges();
                            }
        
                            dialog.hide();
                        }.bind(this)
                    }, {
                        text: ORYX.I18N.PropertyWindow.cancel,
                        handler: function(){
                            this.setValue(this.value);
                            dialog.hide();
                        }.bind(this)
                    }]
                });     
            }
            return dialog;
        }
    });
    
}());/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.form){ Ext.ux.form = {}; }


(function(){
	
	var GlossaryListItemTpl = "" +	
		'<tpl for=".">'+
			'<div class="x-inline">'+	
				'<tpl if="values.data.href">'+
					'<div class="x-glossary-color" style="background-color: {[values.data.rep.color]}"></div>' +
					'<div class="{[values.data.rep.category ? "x-"+values.data.rep.category.toLowerCase()+" x-image" : ""]} x-glossary-title">'+
						'{[Signavio.Utils.escapeHTML(this.translate(values.data.rep))]} '+
					'</div>'+
					'<span class="x-smaller">' +
						'(<a href="/p/glossary#gitem={[values.data.rep.id]}" class="x-open" target="_blank" tabindex="-1">' +
							'{[(Ext.ux.getI18N("btnOpen"))]}' +
						'</a>, ' +
						'<a href="#{[values.data.rep.id]}" class="x-remove" tabindex="-1">' +
							'{[(Ext.ux.getI18N("btnRemove"))]}' +
						'</a>)' +
					'</span>'+
				'</tpl>'+
				'<tpl if="!values.data.href">'+	
					'<div class="x-glossary-color" style="background-color: {[values.data.rep.color]}"></div>' +
					'<div class="{[values.data.rep.category ? "x-"+values.data.rep.category.toLowerCase()+" x-image" : ""]} x-glossary-title">'+
						'{[Signavio.Utils.escapeHTML(this.translate(values.data.rep))]} '+
					'</div>'+
					'<span class="x-smaller">({[(Ext.ux.getI18N("createGlossaryNew"))]}, <a href="#{[values.data.rep.id]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>)</span>'+														
				'</tpl>'+
				'<tpl if="xindex!==xcount">, </tpl>'+
			'</div>'+
		'</tpl>';
	
	
	/**
	 * A factory to generate certain fields by its type
	 * 
	 * @class Ext.ux.form.FieldFactory
	 */
	Ext.ux.form.FieldFactory = {
			
		/**
		 * Generate a field by its type
		 * 
		 * @param {Object} type
		 * @param {Object} option
		 */
		generate: function(type, option){
			option = option || {};
			
			if (this["generate"+type] instanceof Function){
				return this["generate"+type](option);
			}
			
			return this.generateMetaDataStringInfo(option);
		},
		
		/**
		 * Type: String
		 * @param {Object} option
		 */
		generateMetaDataStringInfo: function(option){
			// return simple text field if single line
			if (!option.lineWrap) {
				return new Ext.form.TextField(Ext.apply({}, option));
			}
			
			// return normal text area if no richtext is available
			if (!option.richtextEnabled) {
				return new Ext.form.TextArea(Ext.apply({}, option));
			}
			
			
			// return a richtext editor for multiline meta data
			var rt = new Ext.ux.form.RichtextEditor(Ext.apply({
        		enableSourceEdit: false,
        		anchor			: '100% 100%',
        		modal			: true,
        		ctCls			: 'y-richtext-editor' + (Ext.isIE9 ? ' y-richtext-editor-ie9' : Ext.isChrome ? ' y-richtext-editor-chrome' : ''),
        		listeners	: {
        			render : function(rt) {
        				var editingWindow = rt.ownerCt;
        				
        				rt.getToolbar().add({
        					icon		: "/images/fugue/icons/selection-input.png",
        					iconCls		: "x-dummy",
        					cls			: "x-btn-icon y-horizontal-menu-button",
        					tabIndex	: -1,
        					tooltip 	: {
        						title		: Ext.ux.getI18N("richtext.simpleeditingmodetitle"),
        						text		: Ext.ux.getI18N("richtext.simpleeditingmodedesc")
        					}, 
        					handler		: function () {
        						// Display a warning that all formats could be lost
        						Ext.MessageBox.show({
        							title	: Ext.ux.getI18N("richtext.simpleeditingmodetitle"),
        							msg		: Ext.ux.getI18N("richtext.simpleeditingmodewarning"),
        							buttons	: Ext.MessageBox.OKCANCEL,
        							fn		: function(btn) {
        								if (btn === "ok") {
        									// Create a new simple editor
        									var simpleEditor = new Ext.form.TextArea(Ext.apply({style:"height:"+rt.container.getHeight()+"px;", labelStyle:rt.labelStyle}, option));
        									// Apply the plain text of the richtext editor to the simple editor
        									simpleEditor.setValue(Ext.ux.Richtext.decode(rt.body).text);
    										
    										// Replace the richtext editor with a simple text area
    										editingWindow.items.replace(rt.id, simpleEditor);
//	        									editingWindow.remove(rt);
        									rt.el.parent().parent().parent().remove();
    										
    										// Refresh the containing window
    										editingWindow.syncSize();
    										editingWindow.updateSize();
    										
    										// Focus
    										simpleEditor.focus( false, 100 );
        								}
        							}.bind(this),
        							icon	: Ext.MessageBox.WARNING
        						});
        					}.bind(this)
        				});
        				
        				// Add focus listener to throw a mousedown event outside the iframe
        				Event.observe(rt.win, 'focus', function() {
        					// ALL BROWSERS EXCEPT IE < 9
        					if (document.createEvent instanceof Function) {
	        					var ev = document.createEvent('MouseEvents');
	        					ev.initMouseEvent("mousedown", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
	        					ev._fake = true;
	        					Ext.apply(ev, {});
	        					rt.el.dom.dispatchEvent(ev);
        					} else {
        						var ev = document.createEventObject();
        						rt.el.dom.fireEvent("onMouseDown", ev);
        					}
        					
        				}.bind(this));
        			}.bind(this)
        		}
        	}, option));
			
			rt.setValue(option.value);
			
			return rt;	
		},
		
		/**
		 * Type: String
		 * List: true
		 * @param {Object} option
		 */
		generateMetaDataStringInfoList: function(option){
			return new Ext.ux.form.TextFieldList(Ext.apply({}, option));
		},
		
		/**
		 * Type: Boolean
		 * @param {Object} option
		 */
		generateMetaDataBoolean: function(option){
			return new Ext.form.Checkbox(Ext.apply({
					cls: "x-checkbox-left",
					checked: option.value || false
				}, option));
		},
		
		/**
		 * Type: Enum
		 * @param {Object} option
		 */
		generateMetaDataChoiceInfo: function(option){
			return new Ext.form.ComboBox(Ext.apply({
		     			forceSelection	: true,
		     			mode			: 'local',
		     			allowBlank		: false,
		     			valueField		: "href",
		     			displayField	: "rep",
		     			displayField2	: "type",
		     			triggerAction	: 'all',
		     			lazyRender		: true,
		     			lazyInit		: false
		     		}, option));
		},
		
		/**
		 * Type: Glossary Link
		 * @param {Object} option
		 */
		generateMetaDataGlossaryLink: function(option){
			return new Ext.ux.form.GlossaryField(Ext.apply({
				onNewRecord: function(rec){
					this.records = [rec];
					this.updateView();
					
					// Try to focus the next field
					var next = this.container.parent().next();
					var focusEl;
					if (next)
						focusEl = next.child('.x-form-field');
					else 
						// Fix for focus: now that we're using the Ext.ux.Window, the first button is a link button, focussing it like this breaks it
						focusEl = this.ownerCt.buttons[1];
								
					window.setTimeout(focusEl.focus.bind(focusEl), 10);
				},
				getValue: function(){
					return this.records&&this.records.length === 1 ? this.records[0].get("href") || this.records[0].get("rep") : this.getRawValue();
				},
				initValue: function(){
					if (this.value instanceof Object&&this.value.title&&this.value.id) {
						this.records = [Signavio.Core.RecordCreator.create("gitem", Signavio.Glossary.Config.GLOSSARY_URL + "/" + this.value.id, this.value)];
						this.value = this.value.title;
					} else if(this.value instanceof Ext.data.Record&&this.dataField) {
						this.value = this.value.get("rep")[this.dataField];				
					}
					Ext.ux.form.GlossaryField.superclass.initValue.apply(this, arguments);	
				},
				onRender:function(){
					Ext.ux.form.GlossaryField.superclass.onRender.apply(this, arguments);	
					
					this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {tag:"div", style:"margin:1px 0px 3px 0px;display:none;", cls:'x-field-wrap'}));
					this.itemFieldTpl = new Ext.XTemplate(GlossaryListItemTpl, {translate: function(values){ return this.translate(values, "title"); }.bind(this)});
					
					this.updateView();
				},
				updateView: function(){
					if (this.records&&this.records.length === 1){
						this.itemFieldTpl.overwrite(this.itemField, this.records);
						this.itemField.select("a.x-remove").update(Ext.ux.getI18N("btnReset")).on("click", function(evt){
							Event.stop(evt);
							this.setValue("");
							this.records = [];
							this.updateView();
							this.focus();
						}.bind(this))
						
						this.el.setDisplayed(false);
						this.itemField.setDisplayed(true);
					} else {
						this.itemField.update("");
						this.itemField.setDisplayed(false);
						this.el.setDisplayed(true);
					}
					this.collapse();
				}
			}, option))
		},
		
		/**
		 * Type: Glossary Link
		 * List: true
		 * @param {Object} option
		 */
		generateMetaDataGlossaryLinkList: function(option){
			return new Ext.ux.form.GlossaryField(Ext.apply({
				cls			: "x-MetaDataGlossaryLinkList",
				triggerClass: "x-form-add-trigger",
      			hideTrigger	: false,
				records		: [],
				initValue	: function(){
					if (this.value instanceof Array){
						this.records = this.value.map(function(rec){ return Signavio.Core.RecordCreator.create("gitem", "/glossary/"+rec.id, rec)});
						this.value = "";
					}
					Ext.ux.form.GlossaryField.superclass.initValue.apply(this, arguments);
				},
				onRender	: function(){
					Ext.ux.form.GlossaryField.superclass.onRender.apply(this, arguments);	    
					
					if (!this.valueList)
						this.valueList = new Ext.XTemplate("<div class='x-value-list'></div>").append(this.container, {}, true);

					if (!this.valueTpl)
						this.valueTpl = new Ext.XTemplate(GlossaryListItemTpl, {translate: function(values){ return this.translate(values, "title"); }.bind(this)});	
					this.valueTpl.compile();
					
					if (this.hideInput){
						this.wrap.setDisplayed(false);
						this.container.parent().first().setDisplayed(false);
					}
					this.updateValueList();
				},
				updateView: Ext.emptyFn,
				updateValueList: function(){
					this.valueTpl.overwrite(this.valueList, this.records||[]);
					this.valueList.select("a.x-remove").on("click",function(evt, t){
						Event.stop(evt);
						var id = t.getAttribute("href").split("#").last();
						this.records = this.records.without(this.records.find(function(rec){return rec.get("rep").id === id}))
						this.updateValueList();
					}.bind(this))
					
					this.valueList.setDisplayed((this.records||[]).length !== 0);
					
					if (this.ownerCt&&this.ownerCt.updateSize){
						this.ownerCt.updateSize();
					}
					
					this.updateView();
					
					this.hiddenItems = this.records.pluck("data").pluck("href");
				},
				onNewRecord: function(record){
					// Update
					this.updateValueList();
					this.setValue();
				}
			}, option))
		},
		
		/**
		 * Type: URL
		 * @param {Object} option
		 */
		generateMetaDataUrl: function(option){
			return new Ext.ux.form.UrlLinkFieldList(Ext.apply({
				data: [option.value].compact(),
				hideTrigger: true,
				listStyle: "margin:2px 0px 4px 0px;white-space:nowrap;",
				onTriggerClick: function(){
					Ext.ux.form.UrlLinkFieldList.prototype.onTriggerClick.apply(this, arguments);
					
					// Try to focus the next field
					var next = this.container.parent().next();
					var focusEl;
					if (next) 
						focusEl = next.child('.x-form-field');
					else 
						// Fix for focus: now that we're using the Ext.ux.Window, the first button is a link button, focussing it like this breaks it
						focusEl = this.ownerCt.buttons[1];
					
					//focusEl.focus();
					if (focusEl) 
						window.setTimeout(focusEl.focus.bind(focusEl), 100);
				},
				onUpdateView: function(){
					if (!this.el || !this.fel) {
						return
					}
					var visible = this.data.length === 0;
					this.el.setDisplayed(visible);
					this.fel.el.setDisplayed(visible);
					if (this.ownerCt && this.ownerCt.updateSize) {
						this.ownerCt.updateSize();
					}
				},
				onStartEdit: function(){
					this.el.setDisplayed(true);
					this.fel.el.setDisplayed(true);
					this.itemField.setDisplayed(false);
				},
				onStopEdit: function(){
					this.el.setDisplayed(false);
					this.fel.el.setDisplayed(false);
					this.itemField.setDisplayed(true);
				},
				onRemove: function(){
					this.fel.focus(false, true);
				},
				getValue: function(){
					return Ext.ux.form.UrlLinkFieldList.prototype.getValue.call(this)[0] || "";
				}
			}, option));
		},
		
		/**
		 * Type: URL
		 * List: true
		 * @param {Object} option
		 */
		generateMetaDataUrlList: function(option){
			return new Ext.ux.form.UrlLinkFieldList(Ext.apply({
						data : option.value || []
					}, option))
		}
	}

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/


ns("ux.form");

(function() {

	Signavio.ux.form.FolderPicker = function(facade, attrs) {
		attrs = attrs || {};
		
		this.facade = facade;

		this.setupFolders(attrs);

		attrs.store = attrs.store || new Ext.data.SimpleStore({
			fields: [
				{ name: "title" },
				{ name: "value" }
			],
			data: this.gatherFolderInfo(attrs.folderStore, attrs.rootFolder)
		});

		delete attrs.rootFolder;
		
		attrs.valueField = "value";
		attrs.displayField = "title";
		attrs.mode = "local";
		attrs.selectOnFocus = true;
		attrs.editable = true;
		attrs.readonly = true;
		attrs.emptyText = Ext.ux.getI18N("component.folder.picker.empty");
		attrs.cls = "folder-picker";
		attrs.anchor = "100%";
		
		attrs.tpl = '<tpl for=".">' +
			'<div class="x-combo-list-item">' +
				'{[ values.value === "custom" ? "<a href=\'\' onclick=\'return false;\'>" : ""]}' +
					'{[ values.title.escapeHTML() ]}' +
				'{[ values.value === "custom" ? "</a>" : ""]}' +
			'</div>' +
		'</tpl>';
		
		if(attrs.value) {
			this.oldValue = attrs.value;
		}
		
		Signavio.ux.form.FolderPicker.superclass.constructor.call(this, attrs);
		
		var that = this;

		this.on("select", function(comp, record) {
			that.handleSelect(record, {
				trashRecord: attrs.trashRecord,
				folderStore: attrs.folderStore
			});
		});
	};
	
	Ext.extend(Signavio.ux.form.FolderPicker, Ext.ux.form.ComboBox, {
		
		ensure: function(attrs, key, accessor) {
			if(this.facade[accessor]) {
				attrs[key] = attrs[key] || this.facade[accessor]();
			}

			return !!attrs[key];
		},

		// TODO: remove this method when explorer and editor
		// share one component. It just loads the current folder
		// store in the editor. This should not be neccissary when
		// the facade of the explorer is available
		loadFolderStore: function(folder) {
			var that = this;

			var store = new Ext.data.SimpleStore({
				fields: [
					{ name: "title" },
					{ name: "value" }
				]
			});

			Signavio.Utils.Request.execute("/p" + folder, {
				success: function(response) {
					var info = response.find(function(record) {
						return record.rel === "info";
					});

					that.currentFolder = {
						name: info.rep.name,
						id: folder
					};

					var data = that.createData(info, folder);
					store.loadData(data);
				}
			});

			return store;
		},

		setupFolders: function(attrs) {
			if(!this.ensure(attrs, "folderStore", "getCurrentFolderStore")) {
				var folder = this.facade.getModelMetaData().parent;
				attrs.store = this.loadFolderStore(folder);
			}

			this.ensure(attrs, "rootFolder", "getCurrentRootFolder");
			this.ensure(attrs, "trashRecord", "getTrashRecord");
		},

		createData: function(folderInfo, folderId) {
			var data = [];
			
			if(folderInfo.type) {
				// only root dirs have type attribute
				if(this.rootFolder.id !== folderId) {
					data = [
						[Ext.ux.getI18N("component.types." + folderInfo.type) || folderInfo.name, folderId]
					];
				}
				
				if(!this.currentFolder.isRoot) {
					data = data.concat([
						[this.currentFolder.name, this.currentFolder.id]
					]);
				}
				
			} else {
				if(folderId !== this.currentFolder.id && !this.currentFolder.isRoot) {
					data = [
						[folderInfo.name, folderId],                       // currently selected folder
						[this.currentFolder.name, this.currentFolder.id],  // current folder
					];
				} else {
					data = [
						[folderInfo.name, folderId]    // current folder
					];
				}
			}
			
			return [[this.rootFolder.name, this.rootFolder.id]].concat(
				data,
				[[Ext.ux.getI18N("component.folder.picker.custom"), "custom"]
			]);
		},
		
		gatherFolderInfo: function(folderStore, rootFolder) {
			var records = folderStore.getRecords("info");
			
			var folderInfo = records.invoke("get", "rep")[0];
			var folderId = records.invoke("get", "href")[0];
			
			if(folderId.endsWith("/info")) {
				folderId = folderId.replace("/info", "");
			}
			
			if(folderInfo.type) {
				this.currentFolder = {
					name: Ext.ux.getI18N("component.types." + folderInfo.type),
					id: folderId,
					isRoot: true
				};
			} else {
				this.currentFolder = {
					name: folderInfo.name,
					id: folderId,
					isRoot: false
				};
			}
			
			var rootInfo = rootFolder.get("rep");
			var rootName = Ext.ux.getI18N("component.types." + rootInfo.type);
			
			this.rootFolder = {
				name: rootName,
				id: rootFolder.get("href")
			};
			
			return this.createData(folderInfo, folderId);
		},

		showFolderWindow: function(option) {
			var oldValue = this.oldValue;
			this.oldValue = this.getValue();

			var folderTree = this.getFolderTree(option.trashRecord, option.folderStore);
			
			var label = new Ext.form.Label({
				cls		: "y-wizard-description-label",
				text    : Ext.ux.getI18N("component.folder.picker.description")
			});
			
			var invalid = true;
			
			var win = new Ext.ux.Window({
				title: Ext.ux.getI18N("component.folder.picker.head"),
				width: 500,
				modal: true,
				cancelButton: {
					text: Ext.MessageBox.buttonText.cancel,
					handler: function() {
						this.setValue(oldValue || "");
						
						win.close();
					}.bind(this)
				},
				buttons: [
					{
						text: Ext.MessageBox.buttonText.ok,
						handler: function() {
							invalid = false;
							var selectedRecord = folderTree.getSelectedRecord();
							
							if(selectedRecord) {
								this.updateSelectedFolder(selectedRecord);
								win.close();
							}
						}.bind(this)
					}
				],
				items: [label, folderTree]
			});
			
			win.on("close", function() {
				if(!invalid) {
					return;
				}

				this.setValue(oldValue || "");
				this.oldValue = oldValue;
			}.bind(this));
			
			win.show();
		},
		
		handleSelect: function(record, option) {
			if(record.get("value") !== "custom") {
				return;
			}
			
			this.showFolderWindow(option);
		},
		
		updateSelectedFolder: function(record) {
			this.oldValue = record.get("href");

			var data = this.createData(record.get("rep"), record.get("href"));
			
			this.store.loadData(data);
			this.setValue(record.get("href"));
		},
		
		getFolderTree: function(trashRecord, folderStore) {
			return new Signavio.ux.dialog.tree.FolderPanel(this.facade, {
				data: [folderStore],
				height: 250
			});
		},
		
		getJSON: function() {
			return this.getValue();
		}
		
	});

}());
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.form){ Ext.ux.form = {} }
if (!Ext.ux.data){ Ext.ux.data = {} }

new function(){
	
	Ext.ux.data.RecordCreator = {}
	
	/**
	 * Creates a new record, including 'rel', 'href', and 'rep' attributes
	 * @param {String} rel
	 * @param {String} href
	 * @param {Object} rep
	 * @static
	 */
	Ext.ux.data.RecordCreator.create = function(rel, href, rep){
					
		var Rec = Ext.data.Record.create(["rel", "href", "rep"]);

		var record = new Rec({
		    rel	: rel,
		    href: href,
		    rep	: rep
		});
		return record;
	}	
	

	/**
	 * Implements a json reader to read
	 * glossary items
	 * 
	 * @class Ext.ux.data.GlossaryReader 
	 * @param {Object} meta
	 */
	Ext.ux.data.RecordReader = function(meta){
	    meta = meta || {};
	    this.rels = meta.rels || this.rels;
	    Ext.ux.data.RecordReader.superclass.constructor.call(this, meta, ['rep','href','rel']);
	};
	Ext.extend(Ext.ux.data.RecordReader, Ext.data.JsonReader, {
		
		// Define the filter depending on the "rel"-attribute
		rels: ["gitem"],
		
		/**
		 * Specific implementation to 
		 * read the json with the defined attributes
		 * 
		 * @param {Object} response
		 */
		read : function(response){
			var json = response.responseText;
			var o = eval("("+json+")");
			if(!o) {
				throw {message: "JsonReader.read: Json object not found"};
			}
			var Record = this.recordType;
			var records = [], total = 0;
			o.each(function(rec){
				if (this.rels.include(rec.rel)) {
					records.push(new Record(rec));
				} 
				if (rec.rel == "info" && rec.rep.size){
					total = rec.rep.size;
				}
			}.bind(this))
			return {
				success : true,
				records : records,
				totalRecords : total || records.length
			}
		}
	})
	
	
	
	/**
	 * Class for remote glossary entry search
	 * 
	 * @class
	 * @param attr
	 * @return
	 */
	Ext.ux.form.GlossaryField = function(attr){

		// Set paging parameter to offset
		Ext.PagingToolbar.prototype.paramNames.start = "offset";
		
		// Set attr
	    attr = attr || {};
	    
		// Set default request params
		var params = {select:"title"}
		if (attr.linkableType){
			params.category  = attr.linkableType
		}
		
		// Get cached or new catgeory store
		attr.categoryStore = Ext.StoreMgr.get('category');
		if (!attr.categoryStore) {
			attr.categoryStore = new Ext.data.Store({
							baseParams: {},
							id : 'category',
				            proxy: new Ext.data.HttpProxy({
				            	useAjax	: true,
				            	method	: "GET", 
				            	headers	: {accept:"application/json"},
				                url		: ((Signavio && Signavio.Config && Signavio.Config.BACKEND_PATH)||'/p')+'/glossary'
				            }),
				            reader: new Ext.ux.data.RecordReader({rels:'cat'})
				        });
						
			// Load it with a delay.
			//window.setTimeout(function(){
				attr.categoryStore.load();
			//}, 100);
		}
		
		// Set the new store
		attr.store = new Ext.data.Store({
							baseParams: params,
				            proxy: new Ext.data.HttpProxy({
				            	useAjax	: true,
				            	method	: "GET", 
				            	headers	: {accept:"application/json"},
				                url		: ((Signavio && Signavio.Config && Signavio.Config.BACKEND_PATH)||'/p')+'/glossary'
				            }),
				            reader: new Ext.ux.data.RecordReader({rels:'gitem'})
				        });
		
		// Set the template
	
		attr.tpl = new Ext.XTemplate(
				            '<tpl for="."><div class="search-item">',
								'<span class="x-{[values.rep.category.toLowerCase()]} x-glossary-color" style="float:left;margin-right:4px;width:13px;height:13px;background:{values.rep.color}"></span>',
								'<tpl if="values.href">',
			            			'<tpl for="rep">{[Signavio.Utils.escapeHTML(this.translate(values))]}</tpl>',
								'</tpl>',
								'<tpl if="!values.href">',
			            			'<tpl for="rep">{emptyTitle}</tpl>',
								'</tpl>',
				            '</div></tpl>', {
				            	translate: function(values){
									return this.translate(values, "title") || "&nbsp;";
				            	}.bind(this)
				            });
						
		// Overwrite some attributes
		attr.cls = "x-glossary-support";

        if(typeof attr.showEmptyItems !== "undefined") {
            this.showEmptyItems = attr.showEmptyItems;
        }

		// Call super
	    Ext.ux.form.GlossaryField.superclass.constructor.call(this, attr);	    
	};
	
	Ext.extend(Ext.ux.form.GlossaryField, Ext.form.ComboBox, {
        typeAhead		: false,
		forceSelection	: true,
        lazyRender		: false,
        lazyInit 		: false,
        listClass 		: 'x-glossary-support',
        displayField	: 'rep.title',
        loadingText		: 'Searching...',
        emptyTextList	: '<div class="x-no-entry">'+Ext.ux.getI18N("noglossary_entry")+'</div>',
        queryDelay		: 100,
        minChars		: 2,
		pageSize		: 10,
        preventScrollbars:true,
        queryParam		: "q",
        hideTrigger		: true,
        resizable 		: true,
        itemSelector	: 'div.search-item',
        
		// Callback if a new element has to be created
        onCreateNew		: null,
		
		// Show a set of empty category items to create new one
		showEmptyItems	: true,
		
		// Define the set on items which should not been shown
		hiddenItems		: [],

		/**
		 * Translates the value with the given key
		 * @param values
		 * @param key
		 * @returns {Object}
		 */
        translate		: function(values, key){
        	
        	var langs = this.languages,
				lang  = this.language;
        	
        	if (!langs || langs.length < 2){
        		return values[key];
        	}
        	
        	if (!lang){
        		lang = langs.first();
        	}
        	
			// Get the multi languaged title
			if (langs && lang && langs.length > 1){
				[].concat(lang, langs).each(function(l){
					if (values[key+(l==langs.first()?"":"_"+l)]){
						key = (key+(l==langs.first()?"":"_"+l));
						throw $break;
					}
				});
			}
			
			return values[key];
        },
        
		// @overwrite
		initEvents 		: function(){
			Ext.ux.form.GlossaryField.superclass.initEvents.call(this);
			
			// Overwrite tab behavior
			this.keyNav.tab = function(){
				if (this.selectedIndex >= 0){
					this.onViewClick(false);
				} else {
					this.collapse();
				}
				return true;
			}
			
			if (this.zindex){
				this.list.setZIndex(this.zindex);	
			}
		},
		
		/**
		 * Callback which will be called if a new 
		 * glossary has been added to the list
		 * 
		 * @param {Object} record
		 */
		onNewRecord: function(record){

		},
		
		// @overwrite
		getValue: function(){
			return (this.records||[]).map(function(rec){ return rec.get("href") || rec.get("rep")}) 
		},
		
		disableBlur : function(){
			this.disabledBlur = true;
			this.validateBlur 	= function(){ return false; }
		},
		
		collapseIf: function(){
			if (!this.disabledBlur){
				Ext.ux.form.GlossaryField.superclass.collapseIf.apply(this, arguments);
			}
		},
		
		enableBlur : function(){        
			delete this.disabledBlur;
			this.validateBlur 	= Ext.form.ComboBox.prototype.validateBlur.bind(this);
		},
		
		// @overwrite
        onSelect		: function(record){
			
			if (record && !record.get("href") && this.onCreateNew instanceof Function && this.onCreateNew(record) === false){
				return;
			}
			
			// Strip title
			var title = Signavio.Utils.unescapeHTML(this.translate(record.get("rep"),"title")||this.translate(record.get("rep"),"name")||"");
		
			// If forceselection
			if (this.forceSelection){
				// Set value
				this.lastSelectedCursor = 0;
				this.setValue(title);
			} else {
				// Otherwise try to replace 
				var text = this.getRawValue();
				var cursor = this.getCursorPosition();
				var newText = Signavio.Utils.replaceCommonSubString(text, title, cursor);
				
				var pos = 0, ref = newText.toLowerCase();
				Signavio.Utils.tokenize(title).each(function(token){
					pos = Math.max(ref.indexOf(token.toLowerCase(), pos) + token.length, 0) || pos;
				})
				
				this.lastSelectedCursor = pos;
				this.setValue(newText);
			}
			
			// Collapse
			this.collapse();
			this.selectedIndex = -1;
			
			// Check
			if (!this.records) {
				this.records = [];
			}
			
			// Add, if uniq
			if (!this.records.any(function(r){ return record.get("href") && r.get("href") === record.get("href"); })) {
				this.records.push(record);
			}
			
			this.onNewRecord(record);
        },
		
		/**
		 * Returns the position of the cursor
		 * @return {int}
		 */
		getCursorPosition: function(){
			var input = this.el.dom;
			if (input && typeof input.selectionStart !== "undefined") {
				return input.selectionStart;
			} else {
				return input.value.length;
			}
		},
        
		// @private
        initList: function(){
        	Ext.ux.form.GlossaryField.superclass.initList.apply(this, arguments);
        	
        	if (this.emptyTextList) {
        		this.view.emptyText = this.emptyTextList;
        	}
        	
        	if (this.view) {
        		this.view.onMouseOut = function(e){
	                if(this.lastItem){
	                	try {
	                		if(!e.within(this.lastItem, true)){
	                			Ext.fly(this.lastItem).removeClass(this.overClass);
	                			delete this.lastItem;
	                		}
	                	} catch(error){ }
	                }
	            }.bind(this.view);
        	}
        	
			
			// If toolbar
			if (this.pageTb){
				// Remove all items
				var tb = this.pageTb;
				this.pageTb.items.each(function(item){
					if (!(item == tb.first||item == tb.prev||item == tb.next||item == tb.last)){
						item.hide();
					}
				})
				
				// Add text
				var te = tb.addText("");
				var index = 2;
				tb.tr.insertBefore(te.el.parentNode, tb.tr.childNodes[index]);
				tb.items.remove(te);
				tb.items.insert(index, te);
				tb.displayMsg = "{0}/{1}"
				tb.displayEl = Ext.fly(te.el).createChild({cls:'x-paging-info', style:{display:"inline",position:"relative",left:"0",top:"0"}}); // Text will be automatically updated through original class
				
				// Add spacer
				var sp = tb.addFill();
				tb.tr.insertBefore(sp.el.parentNode, tb.tr.childNodes[++index]);
				tb.items.remove(sp);
				tb.items.insert(index, sp);
				
				var count = this.pageSize, me = this;
				tb.updateInfo = function(){
			        if(this.displayEl){
			            var msg = this.store.getTotalCount() <= count ?
			                "" :
			                String.format(
			                    this.displayMsg,
			                    Math.ceil((this.cursor+1)/count), Math.ceil(this.store.getTotalCount()/count)
			                );
			           this.displayEl.update(msg);
					   if (!msg){
						   	me.assetHeight -= !this.hidden ? 23 : 0;
					   		this.hide();
					   } else {
						   	me.assetHeight += this.hidden ? 23 : 0;
					   		this.show();
					   }
        			}
				}
			}
			
        	if (!this.pageSize)
				this.pageSize = 10;
        },
        
		// @overwrite
        onDestroy : function(){
            if(this.textSizeEl){
                Ext.removeNode(this.textSizeEl);
            }
            
            if (this.view&&this.view.lastItem) {
            	delete this.view.lastItem;
            }
    	    
            Ext.ux.form.GlossaryField.superclass.onDestroy.call(this);
        },

		// @overwrite        
        onBeforeLoad : function(){
            if(!this.hasFocus){
                return;
            }
            
            if (!this.innerList.child("div.loading-indicator")) {
            	if (this.store.getCount()>0) {
            		this.innerList.createChild({tag: 'div', cls: 'loading-indicator', html: this.loadingText});
            	} else {
            		this.innerList.update(this.loadingText ? '<div class="loading-indicator">'+this.loadingText+'</div>' : '');
            	}
            } 
            if (this.selectedIndex>=0){
            	this.lastSelectedRecord = this.store.getAt(this.selectedIndex);
            } else {
            	delete this.lastSelectedRecord;
            }
            
            this.restrictHeight();
        },
		
		getSearchQuery: function(){
			return (this.getRawValue()||"").trim();
		},
		
    	// @overwrite
        initQuery : function(){
        	if (this.list) {
				this.doQuery(this.getSearchQuery());				
			}
        },

    	// @overwrite
        doQuery : function(q, forceAll,includeAll){
        	if(!this.store) {
        		return;
        	}
            if(q === undefined || q === null){
                q = '';
            }
            var qe = {
                query: q,
                forceAll: forceAll,
                combo: this,
                cancel:false
            };
                      
            if(this.fireEvent('beforequery', qe)===false || qe.cancel){
                return false;
            }
            q = qe.query;
            forceAll = qe.forceAll;
            var qq = (q||"").strip().split(/\s+/).findAll(function(r){ return r.length >= this.minChars }.bind(this))
            if(forceAll === true || qq.length > 0){
            	qq = qq.join(" ");
                if(this.lastQuery !== qq){
                    this.lastQuery = qq;
                    if(this.mode == 'local'){
                        this.selectedIndex = -1;
                        if(forceAll){
                            this.store.clearFilter();
                        }else{
                            this.store.filter(this.displayField, q);
                        }
                        this.onLoad();
                    }else{
                        this.store.baseParams[this.queryParam] = qq;
                        var params = this.getParams(qq);
                        if (includeAll === true){
                        	params.include = "all";
                        }
                        this.store.load({
                            params: params
                        });
                        this.expand();
                    }
                }else{
                    this.selectedIndex = -1;
                    this.onLoad();
                }
            }
        },
        
		/**
		 * Filters the store by the hidden items
		 * 
		 */
		filterStore : function(){
			this.store.filterBy(function(r){
				return !this.hiddenItems.include(r.get("href"));
			}.bind(this));
			this.store.data.length = Math.min(this.pageSize, this.store.data.length);
			this.store.fireEvent("datachanged", this.store);
		},
		
    	// @overwrite
        onLoad : function(){
            if(!this.hasFocus){
                return;
            }
			
			// Filter the store by the hidden items
			this.filterStore();
			
            if(this.store.getCount() > 0){
                this.expand();
                this.restrictHeight();
                if(this.lastQuery == this.allQuery){
                    if(this.editable){
                        this.el.dom.select();
                    }
                    /*if(!this.selectByValue(this.value, true)){
                        this.select(0, true);
                    }*/
                } else {
                    //this.selectNext();
                    if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
                        this.taTask.delay(this.typeAheadDelay);
                    }
                }
                
                var index = 0;
                if (this.lastSelectedRecord) {
                	index = this.store.find("href", this.lastSelectedRecord.get("href"));
                }
            	this.select(index, true);
            	
            }else{
                this.onEmptyResults();
            }
            //this.el.focus();
        },
        
		/**
		 * Creates the set on empty items
		 * 
		 */
		createEmptyItems: function(){
			
			this.selectedIndex = -1;
			
			// Get latest text snipped
			var text = this.getRawValue();
			var cursor = this.getCursorPosition();
			var lCursor = this.lastSelectedCursor || 0;
			text = text.slice(lCursor <= cursor ? lCursor : 0);
			text = text.strip().replace(/\s+/g, " ");
			
			// Add new create elements
			if (text) {			
				this.categoryStore			// Get the category store
					.data.items				// Get all categories
					.pluck("data")			// Get the name
					.each(function(categoryData){
						if (this.linkableType && this.linkableType !== categoryData.href){
                                
							return;
						}
						var title = categoryData.rep.name;
						var color = categoryData.rep.color;
						title = new Template(Ext.ux.getI18N("createGlossaryOnTheFly")).evaluate([Signavio.Utils.escapeHTML(text), Ext.ux.getI18N(title) || title]);
						this.store.add(new Ext.ux.data.RecordCreator.create("gitem", "", {title:text, emptyTitle:title, category:categoryData.href, color:color, random: String((new Date()).getTime())}));
				}.bind(this));
			
                // Prepend empty text if not already set
				if (this.view.el.dom.textContent !== Ext.ux.getI18N("noglossary_entry")) {
					this.view.el.createChild(this.emptyTextList, this.view.el.first())	
				}
			}
		},
		
		// @overwrite
        onEmptyResults : function(){
			// Creates the set on empty items
			if (this.showEmptyItems)
				this.createEmptyItems();
			// Update height
        	this.restrictHeight();

        },
		
		// @overwrite
		onTypeAhead : function(){
	        if(this.store.getCount() > 0){
	            var r = this.store.getAt(0);
	            var newValue = Signavio.Utils.extractValue(r, this.displayField);
	            var len = newValue.length;
	            var selStart = this.getRawValue().length;
	            if(selStart != len){
	                this.setRawValue(newValue);
	                this.selectText(selStart, newValue.length);
	            }
	        }
	    },
		
		// @overwrite
	    getParams : function(q){
	        var p = {};
	        if(this.pageSize){
	            p.offset = 0;
	            p.limit = this.pageSize + (this.hiddenItems||[]).length;
	        }
	        return p;
	    }
    })
	
}()
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

 if(!Ext) { var Ext = {}; }
 if(!Ext.ux) { Ext.ux = {}; }
 if(!Ext.ux.form) { Ext.ux.form = {}; }
 
(function() {
     
    Ext.ux.form.GlossaryList = function(attr) {
     
        attr.listeners = Ext.apply({}, {
            specialkey: function(t, e) {
                if(e.getKey() === e.ENTER) {
                    t.onTriggerClick();
                    
                    return false;
                } else if (e.getKey() === e.ESC) {
                    t.stopEditing();
                }
            }
        }, attr.listeners);
        
        this.data = [];
        
        Ext.ux.form.GlossaryList.superclass.constructor.call(this, attr);
    };
     
    Ext.extend(Ext.ux.form.GlossaryList, Ext.ux.form.GlossaryField, {
         
        data: [],
        hideTrigger: false,
        triggerClass: "x-form-add-trigger",
        ctCls: "x-form-textfield-list",
         
        onTriggerClick: function() {
            var index = this.editing !== undefined ? this.editing : this.data.length;
            var value = this.currentValue;
            
            if(!value) {
                return;
            }
            
            if(this.editing !== undefined) {
                this.data[this.editing] = value;
                this.stopEditing();
            } else {
                if(!this.exists(value)) {
                    this.data.push(value);
                }
            }
            
            this.setRawValue("");
            this.updateView();
            
            var ni = (this.itemField.query("li") || [])[index];
            if(ni && this.ownerCt) {
                Ext.fly(ni).scrollIntoView(this.ownerCt.body);
            }
            
            delete this.currentValue;
            window.setTimeout(this.focus.bind(this), 10);
        },
        
        exists: function(value) {
            var existing;
            
            if(value instanceof Array) {
                existing = this.data.find(function(el) {
                    if(el[0] === value[0]) {
                        return true;
                    }
                });  
            }
            
            return !!existing;
        },
         
        isGlossaryEntry: function(value){
            return typeof value === "string" && !!value.match(/\glossary\:\/\/.+\/[\w\W]+\;\;/g);
        },

        glossaryId: function(grecord) {
            if(typeof grecord === "string") {
            	if (!!grecord.match(/\glossary\:\/\/.+\/[\w\W]+\;\;/g)){
            		return (grecord||"").split(";;").invoke("replace", /\glossary\:\/\//g, "").invoke("replace", /\/[\w\W]+/g, "").first();
            	} else if (grecord.startsWith("/glossary/")){
            		return (grecord||"").replace("/glossary/", "");
            	}
            }
            
            return "";
        },
        
        glossaryTitle: function(grecord) {
            if(typeof grecord === "string" && !!grecord.match(/\glossary\:\/\/.+\/[\w\W]+\;\;/g)) {
            	return (grecord||"").replace(/;;$/, "").replace(/\glossary\:\/\/.+?\//g, "");
            }
            return "";
        },
        
        getInGlossarySchema: function(id, title) {
            id = (id||"").replace(/([\/]|glossary)/g, "");
            return "glossary://" + id + "/" + title + ";;";
        },
         
        initValue: function() {
            var href, title;
            
            if (this.value !== undefined && this.isGlossaryEntry(this.value)){
                href = this.value;
                
                this.value = this.glossaryTitle(this.value);
                
                title = this.value;
            } else {
                Ext.ux.form.GlossaryList.superclass.initValue.apply(this, arguments);
                return;
            }
            
            if(typeof this.value === "string") {
                this.value = this.value ? [href, title] : [];
            }
            
            if(this.value instanceof Array) {
                this.data = this.value;
                
                var value = this.value;
                this.value = "";
            }
            
            if(value) {
                this.data = value;
                this.updateView();
            }
        },
         
        onShow: function() {
            Ext.ux.form.GlossaryList.superclass.onShow.apply(this, arguments);
            
            if(!this.width) {
                delete this.lastSize;
                this.setWidth(this.width);
            }  
        },
         
        onRender: function() {
            Ext.ux.form.GlossaryList.superclass.onRender.apply(this, arguments);
            
            if(!this.itemFieldTpl) {
                this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty"></span></tpl>',
                							'<tpl for=".">',
                								'<span class="y-filter-combo-list">{[Signavio.Utils.escapeHTML(values[1])]} ', 
                									'<span class="x-smaller">', 
                                                        '(', 
                                                            '<a href="#{[xindex-1]}" class="x-edit" tabindex="-1">{[(Ext.ux.getI18N("btnEdit"))]}</a>, ', 
                                                            '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>',
                                                        ')',
                                                    '</span>', 
                								'</span>',
                							 '</tpl>');
            }
            
            
            if (!this.itemField){
	            this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {
	                tag: 'div',
	                cls: 'x-glossary-list-root',
	                style: 'margin: 1px 0px 0px 0px; display:none;' + this.listStyle
	            }));
	            

	            this.updateView();
	            
	            var wrap = this.wrap.boxWrap();
				wrap.child(".x-box-mc");
            }            
        },
         
        onUpdateView: Ext.emptyFn,
         
        updateView: function() {
            if(!this.itemFieldTpl || !this.itemField) {
                return;
            }
            
            this.itemFieldTpl.overwrite(this.itemField, this.data || []);
            this.itemField.setDisplayed((this.data || []).length > 0);
            
            this.updateEvents();
            
            if(this.ownerCt && this.ownerCt.updateSize) {
                this.ownerCt.updateSize();
            }
            
            this.onUpdateView();
        },
         
        updateEvents: function() {
        
            var getId = function(el){
                return parseInt(el.getAttribute("href").split('#').last());
            };
            
            this.itemField.select("a.x-remove").on("click", function(e, t) {
                Event.stop(e);
                
                var index = getId(t);
                this.remove(index);
                this.updateView();
            }.bind(this));
            
            this.itemField.select("a.x-edit").on("click", function(e, t) {
                Event.stop(e);
                
                var index = getId(t);
                this.startEditing(index);
            }.bind(this));
        },
        
        remove: function(index) {
            delete this.data[index];
            this.data = this.data.compact();
        },
         
        onStartEdit: Ext.emptyFn,
         
        startEditing: function(index) {
            this.editing = index;
            
            var el = this.itemField.query(".y-filter-combo-list")[index];
            Ext.fly(el).addClass("x-editing");
            
            var value = this.data[index].first();
            var rawValue = this.data[index].last();
            
            this.currentValue = [value, rawValue];
            
            this.setValue(value);
            this.setRawValue(rawValue);
            
            window.setTimeout(this.focus.bind(this), 10);
            
            this.onStartEdit();             
        },
         
        onStopEdit: Ext.emptyFn,
         
        stopEditing: function() {
            if(this.editing === undefined) {
                return;
            }  
            
            var el = this.itemField.query(".y-filter-combo-list")[this.editing];
            Ext.fly(el).removeClass("x-editing");
            
            delete this.editing;
            
            this.setRawValue("");
            this.onStopEdit();
        },
        
        cancelEdit: function(remainVisible) {
            if(this.editing) {
                if(!remainVisible) {
                    this.hide();
                }
            }
        },
         
        onSelect: function(record) {
            if(record && !record.get("href")) {
                return;
            }  
            
            var href = record.get("href");
            var rep = record.get("rep");
            
            var title = Signavio.Utils.unescapeHTML(record.get("rep").title||record.get("rep").name||"");
            
            this.setRawValue(title);            
            this.currentValue = [href, title];
            
            Ext.ux.form.GlossaryList.superclass.onSelect.call(this, record);
        },

        getValue: function(){
			return this.data;
		},
        
        setValue: function(value) {
            if(value && value instanceof Array) {
                value.each(function(el) {
                	if (!el){ return; }
                    if(!(el instanceof Array) && "string" == typeof el) {
                        el = ["/glossary/" + this.glossaryId(el), this.glossaryTitle(el)];
                    }
                    
                    if(!this.exists(el)) {
                        this.data.push(el);
                    }
                }.bind(this));

                this.updateView();
            }
        }
         
     });
     
 })();
/**
 * Copyright (c) 2009
 * Signavio GmbH
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 * @author Willi Tscheschner
 * 
 *  Class for remote glossary entry search
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.form){ Ext.ux.form = {} }

new function(){

/**
	 * Class for remote glossary entry search
	 * 
	 * @class
	 * @param attr
	 * @return
	 */
	Ext.ux.form.GlossarySearchFieldBox = function(attr){
		
		// Set paging parameter to offset
		Ext.PagingToolbar.prototype.paramNames.start = "offset";
		
		// Set attr
	    attr = attr || {};
	    
	    var params = {
	    	select: "title",
	    	originId: attr.parentDir,
	    	operator: 'OR',
	    	language: attr.language,
	    	include: "all"
	    };
	    
	    if (attr.categories){
	    	params.category = attr.categories;
	    }
	    	    
		// Set the new store
		attr.store = new Ext.data.Store({
							baseParams: params,
				            proxy: new Ext.data.HttpProxy({
				            	useAjax	: true,
				            	method	: "GET", 
				            	headers	: {accept:"application/json"},
				                url		: '/p/glossary'
				            }),
				            reader: new Signavio.Helper.RecordReader()
				        });
		
		// Set the template
		/*attr.tpl = new Ext.XTemplate(
				            '<tpl for="."><div class="search-item">',
			            	'<tpl for="rep">',
				                '<h3>{title}</h3>',
				                '{[Signavio.Helper.TruncateByWidth(values.description, 500, "...")]}',
			                '</tpl>',
			            '</div></tpl>'
			        );*/
		attr.tpl = new Ext.XTemplate(
				            '<tpl for="."><div class="search-item">',
							'<div class="x-{[(values.rep.category||"").toLowerCase()]} x-glossary-color" style="background-color:{values.rep.color}" title="{values.rep.categoryName}" />',
			            	'<tpl for="rep">{[Signavio.Utils.escapeHTML(this.translate(values)||"")]}</tpl>',
				            '</div></tpl>'
			        	, {
				            	translate: function(values){
									var langs = attr.languages,
										lang  = attr.language,
										key = "title";
									
									// Get the multi languaged title
									if (langs && lang && langs.length > 1){
										[].concat(lang, langs).each(function(l){
											if (values[key+(l==langs.first()?"":"_"+l)]){
												key = (key+(l==langs.first()?"":"_"+l));
												throw $break;
											}
										});
									}
									return values[key];
				            	}
				            });
		// Overwrite some attributes
		attr.style = "";
		attr.cls = "x-glossary-support";
		
		// Define dom element
		this.defaultAutoCreate = {
		        tag: attr.renderAsTextArea ? "textarea" : "input",
		        autocomplete: "off",
		        style:"visibility:hidden;"
		    };
		
		// Set attr
		this.renderAsTextArea = attr.renderAsTextArea;
    	
    	// Custom attributes used when auto-sizing the field.
    	this.growPad = Signavio.Config.GROWING_TEXT_AREA.VERTICAL_PADDING;
    	this.growPadHorizontal = Signavio.Config.GROWING_TEXT_AREA.HORIZONTAL_PADDING;
    	this.growAppend = Signavio.Config.GROWING_TEXT_AREA.GROW_APPEND;
    	
		/* Since the GlossarySearchField does not have a TextArea superclass,
		 * keep track of these TextArea-specific attributes manually. 
		 **/
		attr.growMin = Math.max(attr.growMin || 0);
    	attr.growMinHorizontal = Math.max(attr.growMinHorizontal || 0);
    	attr.growMax = Signavio.Config.GROWING_TEXT_AREA.GROW_MAX;


		this.growHorizontally = attr.growHorizontally;
		
		// Call super
		Ext.ux.form.GlossarySearchFieldBox.superclass.constructor.call(this, attr);
	    
	};
	Ext.extend(Ext.ux.form.GlossarySearchFieldBox, Ext.form.ComboBox, {
        lazyRender		: false,
        listClass 		: 'x-glossary-support',
        listWidth 		: 200,
        displayField	: 'href',
        typeAhead		: false,
        pageSize		: 10,
        lazyInit 		: false,
        queryDelay		: 100,
        minChars		: 2,
        preventScrollbars:true,
        queryParam		: "q",
        hideTrigger		: true,
        resizable 		: true,
        itemSelector	: 'div.search-item',
        onSelect		: function(record){ // override default onSelect to do redirect

        },
        
        initList: function(){
        	Ext.ux.form.GlossarySearchFieldBox.superclass.initList.apply(this, arguments);
			
        	if (this.emptyTextList) {
        		this.view.emptyText = this.emptyTextList;
        	}
        	
        	if (this.view) {
        		this.view.onMouseOut = function(e){
	                if(this.lastItem){
	                	try {
	                		if(!e.within(this.lastItem, true)){
	                			Ext.fly(this.lastItem).removeClass(this.overClass);
	                			delete this.lastItem;
	                		}
	                	} catch(error){ }
	                }
	            }.bind(this.view);
        	}
			
			if (this.pageTb){
				// Remove all items
				var tb = this.pageTb;
				this.pageTb.items.each(function(item){
					if (!(item == tb.first||item == tb.prev||item == tb.next||item == tb.last)){
						item.hide();
					}
				})
				
				// Add text
				var te = tb.addText("");
				var index = 2;
				tb.tr.insertBefore(te.el.parentNode, tb.tr.childNodes[index]);
				tb.items.remove(te);
				tb.items.insert(index, te);
				tb.displayMsg = "{0}/{1}"
				tb.displayEl = Ext.fly(te.el).createChild({cls:'x-paging-info', style:{display:"inline",position:"relative",left:"0",top:"0"}}); // Text will be automatically updated through original class
				
				// Add spacer
				var sp = tb.addFill();
				tb.tr.insertBefore(sp.el.parentNode, tb.tr.childNodes[++index]);
				tb.items.remove(sp);
				tb.items.insert(index, sp);
				
				var count = this.pageSize, me = this;
				tb.updateInfo = function(){
			        if(this.displayEl){
			            var msg = this.store.getTotalCount() <= count ?
			                "" :
			                String.format(
			                    this.displayMsg,
			                    Math.ceil((this.cursor+1)/count), Math.ceil(this.store.getTotalCount()/count)
			                );
			           this.displayEl.update(msg);
					   if (!msg){
						   	me.assetHeight -= !this.hidden ? 23 : 0;
					   		this.hide();
					   } else {
						   	me.assetHeight += this.hidden ? 23 : 0;
					   		this.show();
					   }
					   me.restrictHeight();
        			}
				}

				tb.updateInfo(); // Hide toolbar initially
			}
        	
        	//this.pageSize = 10;
        },
        
        onRender: function(){
        	Ext.ux.form.GlossarySearchFieldBox.superclass.onRender.apply(this, arguments);
    	            	
            if(this.grow){
                this.textSizeEl = Ext.DomHelper.append(document.body, {
                    tag: "pre", cls: "x-form-grow-sizer"
                });
                if(this.preventScrollbars){
                    this.el.setStyle("overflow", "hidden");
                }
                //this.el.setHeight(this.growMin);
            }    
        },
        
        onDestroy : function(){
            if(this.textSizeEl){
                Ext.removeNode(this.textSizeEl);
            }
            
            if (this.view&&this.view.lastItem) {
            	delete this.view.lastItem;
            }
    	    
            Ext.ux.form.GlossarySearchFieldBox.superclass.onDestroy.call(this);
        },

    	
        // private
        onKeyUp : function(e){
        	Ext.ux.form.GlossarySearchFieldBox.superclass.onKeyUp.apply(this, arguments);
        	
        	// IF textarea AND the key code is an ENTER, DELETE, or REMOVE key
            if(this.renderAsTextArea && (e.getKey() == e.ENTER || e.getKey() ==  e.DELETE || e.getKey() == 8 || true)){    
            	// Update textarea size
    			this.autoSize();
            }
        },
        
        // private
        onBlur : function(evt, target){
        	
        	// Workaround for IE9:
        	// If click on the list, the blur event
        	// was raised, which now will be stopped.
        	if ((Ext.isIE9 || Ext.isIE10) && target === this.el.dom){
        		Event.stop(evt.browserEvent);
        		return;
        	}
        	
            this.beforeBlur();
            if(!Ext.isOpera && this.focusClass){ // don't touch in Opera
                this.el.removeClass(this.focusClass);
            }
            this.hasFocus = false;
            if(this.validationEvent !== false && this.validateOnBlur && this.validationEvent != "blur"){
                this.validate();
            }
            var v = this.getValue();
            if(String(v) !== String(this.startValue)){
                this.fireEvent('change', this, v, this.startValue);
            }
            this.fireEvent("blur", this);
        },

        
        onBeforeLoad : function(){
            if(!this.hasFocus){
                return;
            }
            
            if (!this.innerList.child("div.loading-indicator")) {
            	if (this.store.getCount()>0) {
            		this.innerList.createChild({tag: 'div', cls: 'loading-indicator', html: this.loadingText});
            	} else {
            		this.innerList.update(this.loadingText ? '<div class="loading-indicator">'+this.loadingText+'</div>' : '');
            	}
            } 
            if (this.selectedIndex>=0){
            	this.lastSelectedRecord = this.store.getAt(this.selectedIndex);
            } else {
            	delete this.lastSelectedRecord;
            }
            
            this.restrictHeight();
        },

    	/**
    	 * @Overwrite
    	 */
        initQuery : function(){
        	if (this.list)
        		this.doQuery(this.getRawValue());
        },
		
	    getParams : function(q){
	        var p = {};
	        if(this.pageSize){
	            p.offset = 0;
	            p.limit = this.pageSize;
	        }
	        return p;
	    },
		
    	/**
    	 * @Overwrite
    	 */
        doQuery : function(q, forceAll){
        	if(!this.store) {
        		return;
        	}
            if(q === undefined || q === null){
                q = '';
            }
            var qe = {
                query: q,
                forceAll: forceAll,
                combo: this,
                cancel:false
            };
            if(this.fireEvent('beforequery', qe)===false || qe.cancel){
                return false;
            }
            q = qe.query;
            forceAll = qe.forceAll;
            var qq = (q||"").split(/\s+/).findAll(function(r){ return r.length >= this.minChars }.bind(this))
            if(forceAll === true || qq.length > 0){
            	qq = qq.join(" ");
                if(this.lastQuery !== qq){
                    this.lastQuery = qq;
                    if(this.mode == 'local'){
                        this.selectedIndex = -1;
                        if(forceAll){
                            this.store.clearFilter();
                        }else{
                            this.store.filter(this.displayField, q);
                        }
                        this.onLoad();
                    }else{
                        this.store.baseParams[this.queryParam] = qq;
                        this.store.load({
                            params: this.getParams(qq)
                        });
                        this.expand();
                    }
                }else{
                    this.selectedIndex = -1;
                    this.onLoad();
                }
            }
        },
        
    	/**
    	 * @Overwrite
    	 */
        onLoad : function(){
            if(!this.hasFocus){
                return;
            }
            if(this.store.getCount() > 0){
                this.expand();
                this.restrictHeight();
                if(this.lastQuery == this.allQuery){
                    if(this.editable){
                        this.el.dom.select();
                    }
                    /*if(!this.selectByValue(this.value, true)){
                        this.select(0, true);
                    }*/
                }else{
                	
                    //this.selectNext();
                    if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
                        this.taTask.delay(this.typeAheadDelay);
                    }
                }
                
                var index = -1;
                if (this.lastSelectedRecord) {
                	index = this.store.find("href", this.lastSelectedRecord.get("href"));
                }
            	this.select(index, true);
            	
            }else{
                this.onEmptyResults();
            }
            //this.el.focus();
        },
        
        onEmptyResults : function(){
        	this.restrictHeight()
        },

        
    	/**
    	 * @Overwrite
    	 */
        initEvents : function(){
            Ext.form.ComboBox.superclass.initEvents.call(this);

            this.keyNav = new Ext.KeyNav(this.el, {
                "up" : function(e){
            		if (this.selectedIndex == 0) {
            			this.select(-1);
            		} else if (this.selectedIndex > 0) {
	                    this.inKeyMode = true;
	                    this.selectPrev();
            		}
                },

                "down" : function(e){
                	if (this.store.getCount() > 0) {
	                    if(!this.isExpanded()){
	                        this.onTriggerClick();
	                    }else {
	                        this.inKeyMode = true;
	                        this.selectNext();
	                    }
                	}
                },

                "enter" : function(e){
                	if (this.selectedIndex >= 0 && this.isExpanded()) {
	                    this.onViewClick();
	                    this.delayedCheck = true;
	    				this.unsetDelayCheck.defer(10, this);
                	}
                	
                	if (e.ctrlKey || e.metaKey) {
                		this.onBlur();
                	}
                },

                "esc" : function(e){
                	if (this.isExpanded()) {
                		this.collapse();
                	} else {
                		this.onBlur();
                	}
                },

                "tab" : function(e){
                    this.onViewClick(false);
                    return true;
                },

                scope : this,

                doRelay : function(foo, bar, hname){
                    if (hname == 'down' && this.scope.store.getCount() > 0){
                    	return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    } else if (hname == 'down') {
                    	return true;
                    }
                    if (hname == 'up' && this.scope.selectedIndex < 0) {
                    	return true;
                    }
                    if (hname == 'enter' && this.scope.isExpanded() && this.scope.selectedIndex >= 0) {
                        return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    }
                    if (hname == 'esc') {
                        return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    }
                    if (hname != 'enter' && this.scope.isExpanded()) {
                        return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    }
                    return true;
                },

                forceKeyDown : true
            });
            this.queryDelay = Math.max(this.queryDelay || 10,
                    this.mode == 'local' ? 10 : 250);
            this.dqTask = new Ext.util.DelayedTask(this.initQuery, this);
            if(this.typeAhead){
                this.taTask = new Ext.util.DelayedTask(this.onTypeAhead, this);
            }
            if(this.editable !== false){
                this.el.on("keyup", this.onKeyUp, this);
            }
            if(this.forceSelection){
                this.on('blur', this.doForce, this);
            }
            
            // FIXED: Fixed the problem, that the click event was too late
            // processed, so the onChange and onBlur was called before onSelect
            // was called (mainly in Chrome)
            this.list.dom.addEventListener("mousedown", function(e){
            	Event.stop(e)
            }, false);

            this.footer.dom.addEventListener("mousedown", function(e){
            	Event.stop(e)
            }, false);
        },
        
        /**
         * Automatically grows the field to accomodate the height of the text up to the maximum field height allowed.
         * This only takes effect if grow = true, and fires the autosize event if the height changes.
         */
        autoSize : function(){
            if(!this.grow || !this.textSizeEl){
                return;
            }
            var el = this.el;
            var v = el.dom.value;
            var ts = this.textSizeEl;
            if (!ts||!el){ return }
            ts.innerHTML = '';
            ts.appendChild(document.createTextNode(v));
            v = ts.innerHTML;

            if (!this.growHorizontally) {
	            try {
	            	Ext.fly(ts).setWidth(this.el.getWidth());
	            } catch(e) { }
            }
            
            if(v.length < 1){
                v = "&#160;&#160;";
            }else{
                if(Ext.isIE){
                    //v = v.replace(/\n/g, '<p>&#160;</p>');
                }
                v += this.growAppend;
            }
            ts.innerHTML = v;
            var h = Math.min(this.growMax, Math.max(ts.offsetHeight + this.growPad, this.growMin));
            if(h != this.lastHeight){
                this.lastHeight = h;
                this.el.setHeight(h);
                this.fireEvent("autosize", this, h);
                if (this.list) {
                	this.list.alignTo(this.el, this.listAlign);
                }
            }
            
            if (this.growHorizontally) {
                var w = Math.min(this.growMax, Math.max(ts.offsetWidth + this.growPadHorizontal, this.growMinHorizontal));
                if(w != this.lastWidth){
                    this.lastWidth = w;
                    this.el.setWidth(w);
                    if (this.list) {
                    	this.list.alignTo(this.el, this.listAlign);
                    }
                }
            }
        }
    }); 
}();/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

(function() {
    
    Ext.ux.form.LanguageSelector = function(languages, attr) {
        attr.tpl = attr.tpl || this.createTemplate(!attr.suppressGroups);
        attr.store = attr.store || this.createStore(languages);
        attr.cls = attr.cls || "x-language-switch";
        attr.mode = attr.mode || "local";
        
        Ext.ux.form.LanguageSelector.superclass.constructor.call(this, attr);
    };
    
    Ext.extend(Ext.ux.form.LanguageSelector, Ext.ux.form.ComboBox, {
        
        getGroupTemplate: function() {
            return '<tpl for=".">'
            +'<tpl if="group != null && xindex &gt; 1 && parent[xindex-2].group != group">'
                + '<div style="padding:2px; color: silver; border:1px solid white; font-style: italic;">{[this.getGroup(values)]}</div>'
                + '</tpl>'
            
                + '<tpl if="group != null && xindex == 1 && parent[xindex] && parent[xindex].group != group">'
                    + '<div style="padding:2px; color: silver; border:1px solid white; font-style: italic;">{[this.getGroup(values)]}</div>'
                + '</tpl>'
    
                + '<tpl if="group != null">'
                    + '<div class="x-combo-list-item" style="padding-left:15px">'
                        + '<img src="' + Signavio.Utils.getImagePath() + '/flags/{country}.png" /> '
                        + '{[this.getCountry(values)]}'
                    + '</div>'
                + '</tpl>'
                
                + '<tpl if="group == null">'
                    + '<div class="x-combo-list-item">'
                        + '{title}'
                        + ' ('
                            + '<img src="' + Signavio.Utils.getImagePath() + '/flags/{country}.png" /> '
                            + ' '
                            + '{[this.getCountry(values)]}'
                        + ')'
                    + '</div>'
                + '</tpl>'
            + "</tpl>";
        },
        
        getPlainTemplate: function() {
            return '<tpl for=".">'
                + '<div class="x-combo-list-item">'
                    + '{title}'
                    + ' ('
                        + '<img src="' + Signavio.Utils.getImagePath() + '/flags/{country}.png" /> '
                        + ' '
                        + '{[this.getCountry(values)]}'
                    + ')'
                + '</div>'
            + "</tpl>";
        },
        
        createTemplate: function(withGroups) {
            var tpl;
            
            if(withGroups) {
                tpl = this.getGroupTemplate();
            } else {
                tpl = this.getPlainTemplate();
            }
            
            return new Ext.XTemplate(tpl, {
                getGroup: function(values) {
                    return Ext.ux.getI18N('language_' + values.group);
                },
                getCountry: function(values) {
                    return Ext.ux.getI18N('country_' + values.country);
                }
            });
        },
        
        createStore: function(languages) {
            return new Ext.data.SimpleStore({
                fields: ["value", "title", "group", "country", "position", "rel"],
                data: languages.map(function(lang) {
                    if(typeof lang === "object") {
                        lang = lang.rel;
                    }
                    
                    var descriptor = lang.split("_");
                    
                    var language = descriptor.first();
                    var country = descriptor.last();
                    
                    var rel = {
                        rel: lang,
                        position: 0
                    };
                    
                    if(descriptor.length === 2) {
                        return [lang, Ext.ux.getI18N('language_' + language), language, country, null, rel];
                    }
                    
                    return [lang, Ext.ux.getI18N('language_' + language), null, country, null, rel];
                }),
                sortInfo: {
                    field: 'position',
                    direction: 'ASC'
                }
            });
        },
        
        onRender: function(){
            Ext.ux.form.ComboBox.prototype.onRender.apply(this, arguments);
            this.setFlag();
        },
        
        onSelect: function() {
            Ext.ux.form.ComboBox.prototype.onSelect.apply(this, arguments);
            this.setFlag();
        },
        
        setFlag: function(){
            if (!this.flag){
                this.flag = this.wrap.createChild({cls:"x-language-switch-flag"});
            }
            var lang = this.getValue();
            this.flag.setStyle("background-image", "url('"+ Signavio.Utils.getImagePath() + '/flags/' + lang.split("_").last() + '.png' + "')");
        }
    });
    
}());
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.form) {Ext.ux.form = {}; }

(function() {
	
	var Language = Ext.data.Record.create([
        { name: "title", mapping: "title" },
        { name: "value", mapping: "value" }
    ]);
	
	Ext.ux.form.LanguageSwitch = {
	    create: function(attr) {
	        attr = attr || {};
	        
	        if(attr.multi) {
	            return new Ext.ux.form.LanguageSwitchMulti(attr);
	        }
	        
	        return new Ext.ux.form.LanguageSwitchCombo(attr);
	    }
	};
	
	Ext.ux.form.LanguageSwitchMulti = function(attr) {
	    attr = attr || {};
        
        attr.languages = attr.languages || [];
        attr.name = attr.name || "";
        attr.items = this.setupItems(attr.name, attr.languages);
        attr.bodyStyle = attr.bodyStyle || "padding: 0px";
        
        Ext.ux.form.LanguageSwitchMulti.superclass.constructor.call(this, attr); 
	};
	
	Ext.extend(Ext.ux.form.LanguageSwitchMulti, Ext.Panel, {
	    setupItems: function(group, languages) {
            return languages.sort(this.sortFn)
                            .map(this.mapFn)
                            .compact()
                            .map(function(language) {
                
                var parts = language.split("_");
                
                var lang = parts.first();
                var country = parts.last();
                
                var title = Ext.ux.getI18N('multilanguage.language.' + lang);
                title += " (" + Ext.ux.getI18N('multilanguage.country.' + country) + ")";
                
                return new Ext.form.Checkbox({
                    boxLabel: "<img src='" + Signavio.Config.IMAGE_PATH + '/flags/' + country + ".png' /> " + title,
                    checked: true,
                    name: group,
                    value: language
                });
            });
        },
    
        sortFn: function(a, b) {
            if("undefined" !== typeof a.position) {
                return a.position - b.position;
            }
            
            return 0;
        },
        
        mapFn: function(language) {
            if("string" === typeof language) {
                return language;
            }
            
            if("object" === typeof language) {
                return language.rel;
            }
            
            return null;
        },
        
        check: function(language) {
            this.items.each(function(checkbox) {
                if(checkbox.value === language) {
                    checkbox.setValue(true);
                }
            });
        },
        
        enableAll: function() {
            this.items.each(function(checkbox) {
                checkbox.enable();
            });
        },
        
        disable: function(language) {
            this.items.each(function(checkbox) {
                if(checkbox.value === language) {
                    checkbox.disable();
                }
            });
        },
        
        getRemainder: function() {
            var result = [];
            
            this.items.each(function(checkbox) {
                if(checkbox.getValue() && !checkbox.disabled) {
                    result.push(checkbox.value);
                }
            });
            
            return result;
        }
	});
	
	Ext.ux.form.LanguageSwitchCombo = function(attr) {
		attr = attr || {};
		
		this.setup(attr);
		this.__class__ = Ext.ux.form.LanguageSwitchCombo;
		
		Ext.ux.form.LanguageSwitchCombo.superclass.constructor.call(this, attr);
	};
	
	Ext.extend(Ext.ux.form.LanguageSwitchCombo, Ext.ux.form.ComboBox, {
		
		setup: function(attr) {
			attr.languages = this.parseLanguages(attr.languages || []);
			attr.store = this.createStore(attr);
			attr.value = attr.value || attr.languages.first() || "";
			attr.cls = (attr.cls || "") + " x-language-switch";
			attr.ctCls = attr.ctCls || "x-language-switch-ct",
			attr.mode = attr.mode || "local";
			attr.fieldLabel = Ext.ux.getI18N("multilanguage.label");

			if(attr.languages.length === 0) {
				attr.disabled = true;
				attr.tpl = '<tpl for=".">'
								+ '<div class="x-combo-list-item">'
									+ "Keine Sprachen verfügbar"
								+ '</div>'
							+'</tpl>';
			} else {
				attr.tpl = 	'<tpl for=".">'
								+ '<div class="x-combo-list-item">'
									+ '<img src="' + Signavio.Config.IMAGE_PATH + '/flags/{[values.value.split("_").last()]}.png" style="width: 16px; height: 11px;"/> '
									+ '{title}'
								+ '</div>'
							+'</tpl>';
			}
		},
		
		parseLanguages: function(languages) {
		    return languages.sort(function(a, b) {
		        if("undefined" !== typeof a.position) {
		            return a.position - b.position;
		        }
		        
		        return 0;
		    }).map(function(language) {
		        if("string" === typeof language) {
		            return language;
		        }
		        
		        if("object" === typeof language) {
		            return language.rel;
		        }
		        
		        return null;
		    }).compact();		    
		},
		
		onRender: function(){
			this.__class__.superclass.onRender.apply(this, arguments);
			this.setFlag();
		},
		
		setFlag: function(){
			if (!this.flag){
				this.flag = this.wrap.createChild({cls:"x-language-switch-flag"});
			}
			var lang = this.getValue();
			this.flag.setStyle("background-image", "url('"+ Signavio.Config.IMAGE_PATH + '/flags/' + lang.split("_").last() + '.png' + "')");
		},
		
		onSelect: function(rec){
			this.__class__.superclass.onSelect.apply(this, arguments);
			this.setFlag();
		},
		
		createStore: function(attr) {
			return new Ext.data.SimpleStore({
				fields: this.createFields(),
				data: this.generateData(attr.languages),
				reader: this.createReader()
			});
		},
		
		createFields: function() {
			return [{ name: "value" }, { name: "title" }];
		},
		
		createReader: function() {
			return new Ext.data.ArrayReader({}, Language);
		},
		
		generateData: function(languages) {
			return languages.map(function(language) {
				var parts = language.split("_");
				
				var lang = parts.first();
				var country = parts.last();
				
				var title = Ext.ux.getI18N('multilanguage.language.' + lang);
				title += " (" + Ext.ux.getI18N('multilanguage.country.' + country) + ")";
				
				return [language, title];
			});
		}
		
	});
	
}());
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.form) {Ext.ux.form = {}; }

(function() {
	
	var PREVIEW_WIDTH = 450;
	
	Ext.ux.form.TranslationField = function(attr) {
		attr.field.translation = this;
		this.origin = this.createInfo(attr.field, attr.editing);
		this.target = this.wrap(attr.field, this.origin, attr.editing);
		
		this.setup(attr);
		
		attr.items = [this.origin, this.target].compact();

		Ext.ux.form.TranslationField.superclass.constructor.call(this, attr);
	};
	
	Ext.extend(Ext.ux.form.TranslationField, Ext.Panel, {
		isFormField: true,
		
		setup: function(attr) {
			attr.layout = attr.layout || "column";
			attr.border = typeof attr.border !== "undefined" ? attr.border : false;
		},
		
		hideOrigin: function(){
			if (this.origin){
				this.remove(this.origin);
			}
			if (this.target){
				this.target.columnWidth = 1;
				if (this.field.multilanguage !== true){
					this.target.el.setStyle("margin-left", "0");
				}
			}
		},
		
		createInfo: function(field, editing) {
			if(!editing || field.multilanguage !== true) {
				// If we are currently not editing a field value
				// the info panel isn't necessary
				
				return null;
			}
			
			var me = this;
			
			return new Ext.Panel({
				columnWidth: 0.5,
				border: false,
				html: "",
				cls: "y-translation-info " + this.computeClasses(field),
				style: "margin-right: 10px;",
				afterRender: function(){ // Update view
					Ext.Panel.prototype.afterRender.apply(this, arguments);
					me.setOrigin(me.ownerCt.languages.first());
				}
			});
		},
		
		processValue: function(value, field) {			
			if((field || this.field) instanceof Ext.ux.form.UrlLinkFieldList) {
				if (value instanceof Array && value.length){
					value = value.map(function(link) {
						var rep = link instanceof Ext.data.Record ? link.get("rep") : link;
						
						return "<a href='" + rep.url + "' target='_blank'>" + (rep.label||rep.url) + "</a>";
					});
					return "<div class='x-url-link-field-list'><ol><li>"+value.join("</li><li>")+"</li></ol></div>";
				}
				return "<div class='x-url-link-field-list-empty'>Keine Verlinkungen definiert.</div>";
			} else if((field || this.field) instanceof Ext.ux.form.TextFieldList) {
				if (value instanceof Array && value.length){
					return "<div class='x-form-textfield-list'><ol><li>"+value.join("</li><li>")+"</li></ol></div>";
				}
				return "<div class='x-url-link-field-list-empty'>Keine Einträge definiert.</div>";
			}
			return value;
		},
		
		computeClasses: function(field) {
			if(field instanceof Ext.ux.form.RichtextEditor) {
				return "y-translation-richtext";
			}

			if(field instanceof Ext.form.TextArea) {
				return "y-translation-textarea";
			}
			
			if(field instanceof Ext.ux.form.TextFieldList){
				return "y-translation-list";
			}

			if(field instanceof Ext.form.TextField) {
				return "y-translation-text";
			}
			
			return "";
		},
		
		wrap: function(field, info, editing) {
			field.anchor = "100%";
			this.fakeField(field, info, editing);
			
			return new Ext.Panel({
				columnWidth: info ? 0.5 : 1,
				style 	: editing && field.multilanguage !== true ? "margin-left: 50%;": "",
				layout	: "anchor",
				border	: false,
				items	: field,
				cls		: "y-translation-field"
			});
		},
		
		fakeField: function(field, info, editing) {
			this.fieldLabel = field.fieldLabel;
			this.hideLabel = field.hideLabel || false;
			if ("undefined" != typeof field.labelSeparator){ this.labelSeparator = field.labelSeparator; }

			this.getValue = field.getValue.bind(field);
			this.setValue = field.setValue.bind(field);
			this.focus = field.focus.bind(field);
			
			// Update dirty flag
			field.on("blur", this.updateDirtyFlag, this);
			
			// Update view on render
			var me = this;
			field.render = field.render.createSequence(function(v){ 
				var lang = me.language;
				me.language = me.ownerCt.languages.first(); // Use the old language for caching the current value
				me.setTarget(lang);
				return this;
			});
			
//			var setSize = field.setSize.bind(field);
//			field.setSize = function(width, height) {
//				var padding = editing ? PREVIEW_WIDTH : 0;
//				
//				width = width - padding;
//				
//				setSize(width, height);
//				
//				if(info) {
//					info.setSize(padding, height);
//				}
//			};
		},
		
		setOrigin: function(lang) {
			if (!this.origin){ return; }
			var value = this.field.values || {};
			this.origin.body.update(this.processValue(value[lang]||""));
		},
		
		setTarget: function(lang) {
			
			if (lang && this.field){ // Set language to the field (some fields are using those language information, like GlossaryField)
				this.field.language = lang; 
			}
			
			if (this.field.multilanguage !== true){ return; }
			
			if (!this.values) {
				this.values = Ext.apply({}, this.field.values||{}); 
			} else {
				var oldLanguage = this.language;
				if (oldLanguage){
					var value = this.getValue();
					
					if (value && this.field instanceof Ext.ux.form.RichtextEditor){
						value = Ext.ux.Richtext.decode(this.field.body).text;
					}
					
					if (value != false && (!(value instanceof Array) || value.length > 0)){
						this.values[oldLanguage] = this.getValue();
					} else {
						delete this.values[oldLanguage];
					}
				}
			}
			this.language = lang;
			
			if (this.field instanceof Ext.ux.form.TextFieldList){
				if (this.values[lang] instanceof Array && this.values[lang].length > 0){
					this.field.data = [].concat(this.values[lang].map(function(r){
											return r instanceof Ext.data.Record ? 
													r.data.rep : 
													r;
										}));
				} else {
					this.field.data = [];
				}
				if (this.field.el){
					this.field.setRawValue("");
				}
				this.field.updateView();
			} else {
				this.setValue(this.values[lang]||"");
			}	
			
			this.updateDirtyFlag();
		},
		
		updateDirtyFlag: function(){
			if (this.field && (this.field.wrap || this.field.el)){
				var el = this.field.wrap || this.field.el,
					value = this.getValue(), boo = {};
				
				if (this.field instanceof Ext.ux.form.RichtextEditor) {
					boo = this.field.body;
				}
				
				// Find any existing values in any language
				if($H(this.values).values()
						// Without the current language
						.without(this.values[this.language]).flatten()
						// Without empty line breaks (initial value)
						.find(function(v) {
							if ("string" == typeof v)
								return (v||"").trim();
							return v;
						}) && value == false) {
							el.addClass("x-dirty");
							boo.className = "x-no-background";
				} else {
					el.removeClass("x-dirty");
					boo.className = "";
				}
			}
		}
		
	});
	
}());/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.form) {Ext.ux.form = {}; }

(function() {
	
	Ext.ux.form.TranslationForm = function(attr) {
		attr = attr || {};
		
		this.setup(attr);
		
		this.listeners = attr.listeners;

		var fields = this.createFields(attr.items, attr.editing, attr.language);
		var switches = this.createLanguageSwitches(attr.languages, attr.language, fields, attr.editing);
		
		attr.items = [this.getLabel(), switches].concat(fields);
		
		Ext.ux.form.TranslationForm.superclass.constructor.call(this, attr);
	};
	
	Ext.extend(Ext.ux.form.TranslationForm, Ext.form.FormPanel, {
		
		setup: function(attr) {
			// Ext component configuration
			attr.border = Ext.isDefined(attr.border) ? attr.border : false;
			attr.labelAlign = attr.labelAlign || "right";
			attr.labelWidth = attr.labelWidth || 150;
			attr.autoWidth = Ext.isDefined(attr.autoWidth) ? attr.autoWidth : true;
			attr.cls = "y-translation-form " + (attr.cls || "");
			attr.listeners = attr.listeners || {};
			
			// Translation component configuration
			attr.languages = attr.languages || [];
		},
		
		updateSize: function(){
			var win = this.ownerCt,
				bodyWidth = win.getInnerWidth() - win.body.getPadding("lr"),
				width = bodyWidth - win.labelWidth - 25;
			
			this.items.each(function(item){
				if (item.initialConfig.html){ // <-- Set width of label 
					item.setWidth(bodyWidth-50);
				} else {
					item.setWidth(width);
				}
			});
		},
		
		createSwitch: function(languages, onSelect, language) {
			return Ext.ux.form.LanguageSwitch.create({
				languages: languages,
				mode: "local",
				anchor: "100%",
				value: language,
				listeners: {
					select: onSelect
				}
			});
		},

		createHelpers: function() {
			var that = this;

			var remove = new Ext.LinkButton({
				text: Ext.ux.getI18N("glossary.multilanguage.remove_origin_column"),
				cls	: 'x-remove-column-link',
				click: function() {
					// Remove the left column
					that.removeOriginColumn();
				}
			});

			var copy = new Ext.LinkButton({
				text: Ext.ux.getI18N("glossary.multilanguage.copy_link_title"),
				cls: 'x-copy-content-link',
				click: function() {
					that.copyContentToLeftSide();
				}
			});

			this.origin.add(remove);
			this.origin.add(copy);

			this.origin.getRemoveButton = function() {
				return remove;
			};

			this.origin.getCopyButton = function() {
				return copy;
			};
		},

		resizeHelpers: function(remove, copy, languageSwitch) {
			if(!remove.rendered || !copy.rendered || !languageSwitch.rendered) {
				return;
			}

			var availableWidth = this.origin.getSize().width - languageSwitch.getSize().width;
			var padding = 10;
			var width = availableWidth / 2 - padding;

			var removeText = Ext.ux.getI18N("glossary.multilanguage.remove_origin_column");

			// set new link text
			remove.el.dom.textContent = Signavio.Helper.TruncateByWidth(removeText, width, "…");
			//IE7/IE6
			remove.el.dom.innerText = Signavio.Helper.TruncateByWidth(removeText, width, "…");
			remove.el.dom.title = removeText;

			var copyText = Ext.ux.getI18N("glossary.multilanguage.copy_link_title");

			copy.el.dom.textContent = Signavio.Helper.TruncateByWidth(copyText, width, "…");
			//IE7/IE6	
			copy.el.dom.innerText = Signavio.Helper.TruncateByWidth(copyText, width, "…");
			copy.el.dom.title = copyText + ". " + Ext.ux.getI18N("glossary.multilanguage.copy_link_tt");
		},

		copyContentToLeftSide: function(){
			
			if (!Ext.isDefined(this.originData)) {
				return;
			};
			
			// proove which lanugage was selected
			var originLanguage = this.origin.getValue();
			var targetLanguage = this.target.getValue();
			// is selected language the standard-langauge
			var isOriginDefault = (originLanguage === this.languages.first());			
			
			var fields = [];
			// find all field items
			this.items.each(function(item){
				if (item.isFormField && item.isFormField){
					fields.push(item);
				}
			});
			// iterate over all fields and get the value and copy it to the target field
			fields.each(function(field){
				// it is a true field
				if (!field.field){
					return;
				}

				var fieldId = field.field.dataField;
				var originValue = "";
				var searchKey = isOriginDefault ? fieldId : fieldId + "_" + originLanguage;
				// search current value for this field
				if (fieldId.startsWith("metaDataValues.")){
					// search in metadatainfos
					searchKey = searchKey.replace("metaDataValues." , "");
					originValue = this.originData.metaDataValues[searchKey];
					
				}else{
					// search in globaldata
					originValue = this.originData[searchKey] || "";
				}
				
				// special case url-link-list 
				if (originValue && field.field instanceof Ext.ux.form.UrlLinkFieldList){
					// delete all ids from new url-links
					var values = [];
					// delete id to force a new server-sided creation for this link
					originValue.each(function(value){
						var newValue =  Object.clone(value);
						
						if (newValue.id && newValue.url){	
							delete newValue.id;
						}

						values.push(newValue);
					});
					
					originValue = values;
				}
				
				// special case richtexteditor
				if (originValue && field.field instanceof Ext.ux.form.RichtextEditor){
					var originValueFormats = this.originData.formats[searchKey] || {};
					
					originValue = Ext.ux.Richtext.encode(originValue, originValueFormats) || "";
				}
				
				// set value to the specific-lanugage target
				try {
					delete field.language // hack: set lanugage to undefined to set the new target value 
					
					field.values[targetLanguage] = originValue;						
					field.setTarget(targetLanguage);						
				}catch(e) {
					return;
				}				
			}.bind(this));	
		},
		
		createLanguageSwitches: function(languages, language, fields, editing) {
			var origin;
			var that = this;
			
			if(editing) {
				origin = this.createSwitch(languages, function(me, record) {
					var value = record.get("value");
					
					fields.each(function(field) {
						field.setOrigin(value);
					});
				});

				this.origin = this.wrap(origin, {
					columnWidth: 0.5
				});

				origin.on("render", function() {
					var remove = that.origin.getRemoveButton();
					var copy = that.origin.getCopyButton();

					that.origin.on("resize", function() {
						that.resizeHelpers(remove, copy, origin);
					});

					Signavio.Utils.defer(function() {
						that.resizeHelpers(remove, copy, origin);
					});
				});

				this.createHelpers(origin);
			}
			
			var target = this.createSwitch(languages, function(me, record) {
				var value = record.get("value");
				
				fields.each(function(field) {
					field.setTarget(value);
				});
			}, language);
			
			this.target = this.wrap(target, {
				columnWidth: origin ? 0.5 : 1
			});
			
			return new Ext.Panel({
				border: false,
				layout: "column",
				fieldLabel: Ext.ux.getI18N("glossary.new.languageswitch"),
				isFormField: true,
				items: [this.origin, this.target].compact()
			});
		},
		
		removeOriginColumn : function() {

			// Get all items
			this.items.each(function(item){
				if (item.hideOrigin){
					item.hideOrigin();
				}
			});
			
			if (this.origin){
				this.origin.ownerCt.remove(this.origin);
				
				if (this.target) {
					this.target.columnWidth = 1;
				}
			}

			// Update the translation form
			this.ownerCt.doLayout();
			this.updateSize();
		},
		
		wrap: function(field, attr) {
			return new Ext.Panel(Ext.apply({
				items: field,
				border: false,
				getValue: function() {
					return field.getValue();
				}
			}, attr || {}));
		},
		
		createFields: function(items, editing, language) {
			return (items || []).map(function(item) {
				return new Ext.ux.form.TranslationField({
					field: item,
					editing: editing,
					language: language || undefined,
					anchor: "100%"
				});
			}.bind(this));
		},
		
		getLabel: function(){
			return new Ext.Panel({
				html: Ext.ux.getI18N("glossary.form.description"),
				border: false,
				cls: "y-translation-hint"
			});
		}
		
	});
	
}());
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Christian Wiggert
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" == typeof window.Ext){ window.Ext = {}; }
if ("undefined" == typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" == typeof Ext.ux.form){ Ext.ux.form = {}; }

new function(){
    /**
     * This form element encapsulates a list of check boxes or radio buttons.
     * The different entries are submitted in a store with 'title' and 'value'.
     * Add the config option 'multiSelect: false' to use radio buttons instead of 
     * check boxes.
     * @class
     * @param attr
     * @return
     */
    Ext.ux.form.RadioGroup = function(attr) {
        this.multiSelect = attr.multiSelect || false;
        this.store = attr.store || new Ext.data.SimpleStore({
            fields: ['title', 'value'],
            data: []
        });
        this.groupName = Math.ceil(Math.random() * 100000);
        this.values = attr.values || [];
        attr.border = attr.border || false;
        attr.layout = attr.layout || 'form';
        attr.baseCls = attr.baseCls || 'x-form-item';
        attr.cls = 'y-form-radiogroup ' + (attr.cls || '');
        attr.autoWidth = typeof attr.autoWidth !== 'undefined' ? attr.autoWidth : false;
        attr.autoHeight = typeof attr.autoHeight !== 'undefined' ? attr.autoHeight : false;
        attr.fieldLabel = attr.fieldLabel || '';
        attr.items = this.store.data.items.length > 0 ? [] : [new Ext.form.Label()];
        var first = true;
        this.store.each(function(entry) {
            var config = {};
            if (first && !attr.hideLabel) {
                config.fieldLabel = attr.fieldLabel;
                first = false;
            } else {
                config.labelSeparator = '';
            }
            config.boxLabel = entry.get('title');
            config.value = entry.get('value');
            config.name = this.groupName;
            config.checked = this.values.indexOf(entry.get('value')) > -1;
            var item;
            if (this.multiSelect) {
                item = new Ext.form.Checkbox(config);
            } else {
                item = new Ext.form.Radio(config);
            }
            attr.items.push(item);
            item.on('check', function(box, checked) {
                if (checked) {
                    this.addValue(box.value);
                } else {
                    this.removeValue(box.value);
                }
            }.bind(this));
        }.bind(this));
        Ext.ux.form.RadioGroup.superclass.constructor.call(this, attr);
    };

    Ext.extend(Ext.ux.form.RadioGroup, Ext.Panel, {

        getValue : function() {
            return this.values;
        },

        addValue : function(value) {
            if (this.values.indexOf(value) === -1) {
                if (!this.multiSelect) {
                    this.values.clear();
                }
                this.values.push(value);
            }
        },

        removeValue : function(value) {
            if (this.values.indexOf(value) > -1) {
                this.values.remove(value);
            }
        },

        check : function(value) {
            var field = this.items.items.find(function(field) { return field.value === value; });
            if (Ext.isDefined(field)) {
                field.setValue(true);
            }
        },

        disable : function(value) {
            var field = this.items.items.find(function(field) { return field.value === value; });
            if (Ext.isDefined(field)) {
                field.disable();
            }
        },

        enable : function(value) {
            var field = this.items.items.find(function(field) { return field.value === value; });
            if (Ext.isDefined(field)) {
                field.enable();
            }
        }

    });

    /**
     * This is a simple store extension that can be used with the RadioGroup above.
     */
    Ext.ux.form.ChoiceStore = function(attr) {
        var choices = attr.choices ? attr.choices : [];
        attr.fields = ['title', 'value'];
        attr.data = [];
        choices.each(function(c) {
            if (typeof c === "object" && c.length > 1) {
                attr.data.push([c[0], c[1]]);
            } else {
                attr.data.push([c, c]);
            }
        });
        Ext.ux.form.ChoiceStore.superclass.constructor.call(this, attr);
    };

    Ext.extend(Ext.ux.form.ChoiceStore, Ext.data.SimpleStore, {});
}();/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Philipp Giese, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */



//var getStartContainer = function(range){
//    return range.startContainer;
//}
//
//var getEndContainer = function(range){
//    return range.endContainer;
//}
//
//var removeContainer = function(container){
//    if (container && container.nodeType == 1){
//        var index = $A(container.parentNode.childNodes).indexOf(container);
//        var parent = container.parentNode;
//        parent.removeChild(container);
//        parent.insertBefore(document.createTextNode(container.textContent), parent.childNodes[index])
//    }
//}
//
//var getAllParents = function(node){
//    var parents = [];
//    while(node && (node.nodeType != 1 || node.tagName.toLowerCase() != "body")){
//        parents.push(node);
//        node = node.parentNode;
//    }
//    return parents.reverse();
//}
//
//var getMostCommonAncestor = function(range){
//    var parentsStart = getAllParents(range.startContainer), 
//        parentsEnd = getAllParents(range.endContainer),
//        startC;
//
//    while(startC = parentsStart.shift() && parentsEnd.include(startC)){}
//
//    return startC || window.frames[0].document.body;
//}
//
//var getCommonStartIndex = function(root, start){
//    var cn = $A(root.childNodes);
//    while(start && start !== root){
//        if (cn.include(start)){
//            return cn.indexOf(start);
//        }
//        start = start.parentNode;
//    }
//    return -1;
//}
//
//var selectCommonNodes = function(range, root){
//    var start = range.startContainer, end = range.endContainer;
//    if (true || start.nodeType == 3 && range.startOffset == 0){
//        while(start && start.parentNode && start !== root){
//            if (start.parentNode.childNodes[0] != start || start.parentNode.childNodes.length != 1){ break; }
//            start = start.parentNode;
//        }
//    }
//    if (true || end.nodeType == 3 && range.endOffset == end.textContent.length){
//        while(end && end.parentNode && end !== root){
//            if (end.parentNode.childNodes[end.parentNode.childNodes.length-1] != end){ break; }
//            end = end.parentNode;
//        }
//    }
//    console.log(start, end);
//    if (start.nodeType == 3) range.setStart(start, 0); 
//    else range.setStart(start.parentNode, $A(start.parentNode.childNodes).indexOf(start)); 
//
//
//    if (end.nodeType == 3) range.setEnd(end, 0); 
//    else range.setEnd(end.parentNode, $A(end.parentNode.childNodes).indexOf(end)+1); 
//    console.log(range, range.startContainer, range.startOffset, range.endContainer, range.endOffset);
//}
//
//var getChildTextNode = function(node){
//    while(node && node.nodeType != 3){
//        node = node.firstChild;
//    }
//    return node || null;
//}
//
//var getNextTextNode = function(node){
//    while(node){
//        var child = getChildTextNode(node.nextSibling);
//        if (child){ return child; }
//        node = node.parentNode;
//    }
//    return null;
//}
//
//var getText = function(range, root){
//    var text = "",
//        start = getChildTextNode(range.startContainer),
//        end = getChildTextNode(range.endContainer);
//
//    while(start){
//        text += start.textContent;
//        if (start == end){ break; }
//        start = getNextTextNode(start);
//    }
//    return text;
//}
//
//var selection = window.frames[0].getSelection(), range = selection.getRangeAt(0);
//
//var start = getStartContainer(range),end = getEndContainer(range);
//
//var root = getMostCommonAncestor(range);
//var index = getCommonStartIndex(root, start);
//
//selectCommonNodes(range, root);
//var text = getText(range, root);
//range.deleteContents();
//console.log(text, root.childNodes[index]);
//root.insertBefore(text, root.childNodes[index]);


if(!window.Ext) { window.Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.form) { Ext.ux.form = {}; }

new function() {
    
    /**
     * Base class for all richtext editors. Provides functions for text editing.
     * 
     * @param {Object} conf Configuration object
     */
	Ext.ux.form.RichtextEditor = function(conf) {
		
		// !REMOVE ATTRIBUTES WHICH OVERWRITES THE CLASS METHODS!
		delete conf.isList;
		
		Ext.ux.form.RichtextEditor.superclass.constructor.call(this, conf);
				
		if(conf.enableGlossaryLink !== undefined) this.enableGlossaryLink = conf.enableGlossaryLink;
		if(conf.enableParagraph !== undefined) this.enableParagraph = conf.enableParagraph;
		if(conf.enableHeadings !== undefined) this.enableHeadings = conf.enableHeadings;
		if(conf.enableProcessLinks !== undefined) this.enableProcessLinks = conf.enableProcessLinks;
		if(conf.enableFontSize !== undefined) this.enableFontSize = conf.enableFontSize;
		if(conf.enableRemoveFormat !== undefined) this.enableRemoveFormat = conf.enableRemoveFormat;
        if(conf.enableHorizontalRule !== undefined) this.enableHorizontalRule = conf.enableHorizontalRule;
        //if(conf.enableCodeBlock !== undefined) this.enableCodeBlock = conf.enableCodeBlock;
        if(conf.enableUndoRedo !== undefined) this.enableUndoRedo = conf.enableUndoRedo;
        if(conf.hideToolbar !== undefined) this.hideToolbar = conf.hideToolbar;
        if(conf.enableUnderline !== undefined) this.enableUnderline = conf.enableUnderline;
        if(conf.tbar !== undefined) this.additionalToolbarButtons = conf.tbar;
	};    
	
	Ext.extend(Ext.ux.form.RichtextEditor, Ext.form.HtmlEditor, {
		
        hideToolbar: false,
        	
		enableGlossaryLink: true,
		enableParagraph: true,
		enableHeadings: true,
		enableProcessLinks: true,
		enableFont: false,
		enableFontSize: true,
		enableRemoveFormat: true,
        enableHorizontalRule: true,
        enableCodeBlock : false,
        enableUndoRedo: true,
        enableUnderline: true,
        
        undoStack: [],
        redoStack: [],
        timeout: undefined,
        oldHTML: undefined,
        oldBreadcrump: undefined,
        oldOffset: undefined,
        keyCount: 0,
        
        additionalToolbarButtons : [],
		
		// key, value pairs
		// key is used as attribute for the font-tag
		// value is shown to the user
		defaultFontSizes: [[1,6],[2,8],[3,10],[4,12],[5,14],[6,16],[7,18]],
		defaultFontSize: 2,
		fontSizeApprox: {"10px": 1,
		                 "12px": 2,
		                 "16px": 3,
		                 "18px": 4,
		                 "24px": 5,
		                 "32px": 6,
		                 "48px": 7
		},
		
		/**
		 * Get the explorer path - wrapper for different config files
		 * narf
		 * @returns
		 */
		explorerPath : '/explorer',
		
         /**
          * The following functions are convenience wrappers for the functionality of the
          * editor. If this component is used these functions serve as an API. All other functions
          * are considered to be private. 
          */
                         
        /**
         * Toggle font-weight of selected text
         */
        bold: function() {
        	this.forceSelection();
            this.logCmd('bold');
        },
        
        /**
         * Toggle font-style of selected text
         */
        italic: function() {
        	this.forceSelection();
            this.logCmd('italic');
        },
        
        /**
         * Toggle underlining of selected text
         */
        underline: function() {
        	this.forceSelection();
            this.logCmd('underline');
        },
        
        /**
         * Toggle h1
         */
        h1: function() {
        	this.logCmd(this.toggleHeading.bind(this, '1'));
        },
        
        /**
         * Toggle h2
         */
        h2: function() {
        	this.logCmd(this.toggleHeading.bind(this, '2'));
        },
        
        /**
         * Toggle h3
         */
        h3: function() {
        	this.logCmd(this.toggleHeading.bind(this, '3'));
        },
        
        /**
         * Change the background color of the selected text
         * @param {Hex} color
         */
        background: function(color) {
        	this.forceSelection();
            if(Ext.isGecko){
                this.logCmd('styleWithCSS', false);
                this.logCmd('hilitecolor', color);
                this.logCmd('styleWithCSS', true);
                this.deferFocus();
            } else {
                this.logCmd(Ext.isOpera ? 'hilitecolor' : 'backcolor', Ext.isSafari || Ext.isIE ? '#'+color : color);
                this.deferFocus();
            }
        },
        
        /**
         * Change the color of the selected text
         * @param {Hex} color
         */
        color: function(color) {
        	this.forceSelection();
            this.logCmd('forecolor', Ext.isSafari || Ext.isIE ? '#'+color : color);
        },
        
        /**
         * Change the font of the selected text
         * @param {String} font
         */
        font: function(font) {
        	this.forceSelection();
            this.logCmd('fontname', font);
        },
        
        /**
         * Change the size of the selected text
         * @param {Integer} size
         */
        size: function(size) {
        	this.forceSelection();
            this.logCmd('fontsize', this.fontSizeApprox(size + "px"));
        },
        
        /**
         * Insert an horizontal rule
         */
        hr: function() {
        	
        	var range = this.getSelection().getRangeAt(0), node = range.startContainer;
        	
        	if (1 === node.nodeType){
    			node = node.childNodes[range.startOffset];
    		}
        	
            this.logCmd('inserthorizontalrule');
            
            // Workaround for problems when placing the hr at the end of the body.
            //this.insertAtCursor("<br/>");
            
            if (this.isSingleCursorSelection(range)){
            	
            	var hr = node.previousSibling.nodeType == 1 && node.previousSibling.tagName.toLowerCase() == "hr" ? node.previousSibling :
            			 node.nextSibling.nodeType == 1 && node.nextSibling.tagName.toLowerCase() == "hr" ? node.nextSibling : undefined ;
            	
            	// Remove previous or next linebreak
            	if (hr){
            		// Previous
            		if (hr.previousSibling && 1 === hr.previousSibling.nodeType && "br" == hr.previousSibling.tagName.toLowerCase()){
        				hr.parentNode.removeChild(hr.previousSibling);
        			}
            		// Next
            		if (hr.nextSibling && 1 === hr.nextSibling.nodeType && "br" == hr.nextSibling.tagName.toLowerCase()){
        				hr.parentNode.removeChild(hr.nextSibling);
        			}
            		
            		// Add line break, if hr is the last child
                	var isLastChild = !node.nextSibling;
                	while (isLastChild && node && (node.nodeType != 1 || node.tagName.toLowerCase() !== "body")){
                		isLastChild = !node.nextSibling;
                		node = node.parentNode;
                	}
                	if (isLastChild){
                		this.insertAtCursor("<br/>");
                	}
            	}
        	}
        },
        
        insertCodeBlock : function() {
        	this.toggleCodeBlock();
        },
        
        /**
         * Insert an unordered list
         */
        ul: function() {
        	if (Ext.isSafari){
        		if (this.isSelectionContainedInTag("ul", "ol")){
            		this.logCmd('outdent');	
            		return;
        		}
        	}
    		this.logCmd('insertunorderedlist');
        },
        
        /**
         * Insert an ordered list
         */
        ol: function() {
        	if (Ext.isSafari){
        		if (this.isSelectionContainedInTag("ol", "ul")){
            		this.logCmd('outdent');	
            		return;
        		}
        	}
    		this.logCmd('insertorderedlist');
        },
        
        /**
         * Create a link of the selected text
         */
        link: function() {
        	this.forceSelection();
            this.logCmd(this.createLink.bind(this));
        },
        
        /**
         * Remove link from the selected text
         */
        unlink: function() {
            this.logCmd(this.removeLink.bind(this));
        },
        
        removeAllFormat: function(){
        	var body = this.win.document.body;
        	
        	var content = Ext.ux.Richtext.decode(body);
        	var plain = content.text;
        	
        	body.innerHTML = plain.replace(/\n/ig, "<br>");
        	
//        	var content = body.innerHTML;
//        	content = content.replace(/<br.{0,1}>/ig, "\n")
//        					 .replace(/(<\/(div|li|h1|h2|h3|p)>)/ig, "$1\n")
//        					 .stripTags()
//        					 .replace(/\n/g, "<br/>");
//        	body.innerHTML = content;
        },
        
        removeFormat : function() {
        	
        	// If the whole text is selected, remove all tags
        	if (String(this.win.document.body.textContent) == String(this.getRange())){
        		this.removeAllFormat();
        		return;
        	}
        	
        	var selection = this.getSelection(), 
        		range = this.getRange(selection).cloneRange();
        	
	        var root = this.getMostCommonAncestor(range);
        	
        	// Reset alignment
        	//this.relayCmd('justifyleft');
        	// Remove all formats
        	this.logCmd('removeformat');
        	
        	if (String(range).length){
	        	selection.removeAllRanges();
	        	selection.addRange(range);
        	}
        	// Outdent
//        	this.relayCmd("styleWithCSS", true);
//        	this.relayCmd("outdent");
//			this.relayCmd("styleWithCSS", false);
			
			// ATTENTION: THIS MUST BE TESTED VERY CAREFULLY
			// Remove formated containers
	        var selection = this.getSelection(), 
	        	range = this.getRange(selection);

	        this.forceSelection();
	        //this.selectCommonNodes(range, root);
	        this.iterateOverTextElements(range, root);
        },
 
        /**
         * Returns all parents of 
         * the node (exclude the body tag)
         * @param node
         * @returns
         */
        getAllParents: function(node){
            var parents = [];
            while(node && (node.nodeType != 1 || node.tagName.toLowerCase() != "body")){
                parents.push(node);
                node = node.parentNode;
            }
            return parents.reverse();
        },

        /**
         * Returns the container where the start
         * and end container is contained.
         * @param range
         * @returns {HTMLElement}
         */
       	getMostCommonAncestor: function(range){
            var parentsStart = this.getAllParents(range.startContainer), 
                parentsEnd = this.getAllParents(range.endContainer),
                startC = parentsStart.shift(), lastC;

            while(startC && parentsEnd.include(startC) && startC.nodeType == 1){
            	lastC = startC;
            	startC = parentsStart.shift();
            }
            
            if (lastC && !["ol", "ul"].include(lastC.tagName.toLowerCase())){
            	lastC = lastC.parentNode;
            }

            return lastC || this.win.document.body;
        },
        
        /**
         * Returns the first child text node which is a child of the node
         * @param node
         * @returns {Boolean}
         */
        getChildTextNode: function(onode, offset){
        	if (onode && onode.nodeType == 3){
        		return onode;
        	}
        	
        	if (onode && onode.nodeType != 3){
        		onode = onode.childNodes[offset];
        	}
        	var node = onode;
            while(node && node.nodeType != 3){
                node = node.firstChild;
            }
            
            return node || onode || null;
        },

//        /**
//         * Returns the next sibling text node 
//         * of the given node, independent from the 
//         * level.
//         * @param node
//         * @returns
//         */
//        getNextTextNode: function(node, root){
//            while(node){
//                if (node.nextSibling){
//                    if (node.nextSibling.childNodes.length == 0){
//                        node = node.nextSibling;
//                        continue;
//                    } else if (node.nextSibling.nodeType == 3){
//                        return node.nextSibling;
//                    }
//                }
//                var child = this.getChildTextNode(node.nextSibling);
//                if (child){ return child; }
//                
//                if (node == root || node.tagName.toLowerCase() == "body"){
//                	break;
//                }
//                
//                node = node.parentNode;
//            }
//            return null;
//        },
//        
//
//        /**
//         * Returns the next sibling text node 
//         * of the given node, independent from the 
//         * level.
//         * @param node
//         * @returns
//         */
//        getPreviousTextNode: function(node, root){
//            while(node){
//                if (node.previousSibling){
//                    if (node.previousSibling.childNodes.length == 0){
//                        node = node.previousSibling;
//                        continue;
//                    } else if (node.previousSibling.nodeType == 3){
//                        return node.previousSibling;
//                    }
//                }
//                var child = this.getChildTextNode(node.previousSibling);
//                if (child){ return child; }
//                
//                if (node == root || node.tagName.toLowerCase() == "body"){
//                	break;
//                }
//                
//                node = node.parentNode;
//            }
//            return null;
//        },
//        
        isNodePartOfSelection: function(node){
        	var range = this.getRange();
        	if (!range){
        		return false;
        	} else if ("function" != range.isPointInRange){
        		return true;
        	}
        	return range.isPointInRange(node, 0) || range.startContainer == node || range.endContainer == node || false;
        },
        

        selectCommonNodes : function(range, root) {
        	var start = range.startContainer, end = range.endContainer;
        	
        	if (start && start.nodeType == 3){
        		var nstart;
        		while(nstart = this.getPreviousTextNode(start, start.parentNode)){
        			start = nstart;
        		}
        	}
        	
        	if (end && end.nodeType == 3){
        		var nend;
        		while(nend = this.getNextTextNode(end, end.parentNode)){
        			end = nend;
        		}
        	}
        	
        	if (start !== range.startContainer){
        		range.setStart(start, 0);
        	}
        	
        	if (end !== range.endContainer){
        		range.setEnd(end, end.textContent.length);
        	}
        	
//			var start = range.startContainer, end = range.endContainer;
//			if (true || start.nodeType == 3 && range.startOffset == 0) {
//				while (start && start.parentNode && start.parentNode !== root) {
//					if (start.parentNode.childNodes[0] != start || start.parentNode.childNodes.length != 1) {
//						break;
//					}
//					start = start.parentNode;
//				}
//			}
//			if (true || end.nodeType == 3 && range.endOffset == end.textContent.length) {
//				while (end && end.parentNode && end.parentNode !== root) {
//					if (end.parentNode.childNodes[end.parentNode.childNodes.length - 1] != end || end.parentNode.childNodes.length != 1) {
//						break;
//					}
//					end = end.parentNode;
//				}
//			}
//			if (start.nodeType == 3) range.setStart(start, 0);
//			else range.setStart(start.parentNode, $A(start.parentNode.childNodes).indexOf(start));
//
//			if (end.nodeType == 3) range.setEnd(end, 0);
//			else range.setEnd(end.parentNode, $A(end.parentNode.childNodes).indexOf(end) + 1);
		},

        /**
         * Helper to remove the direct 
         * container of the given node.
         * Used to remove formations.
         * @param node
         */
        removeFormatedContainer: function(node, root){
            var pnode = node.parentNode;
            if (pnode.tagName.toLowerCase() == "body" || pnode == root){ return; }
            

            // Cache all preceeding newlines
            var brs = [];
            while(node.nextSibling && node.nextSibling.nodeType == 1 && node.nextSibling.tagName.toLowerCase() == "br"){
            	brs.push(node.parentNode.removeChild(node.nextSibling));
            }
            
            pnode.removeChild(node);
            pnode.parentNode.insertBefore(node, pnode);
            
            // Add all cached newlines to the new parent (except it 
            // was only one newline at the end of a container)
            if (brs.length != 1 || pnode.childNodes.length != 0){
	            brs.each(function(br){
	                pnode.parentNode.insertBefore(br, pnode);
	            });
            }

            if (pnode.childNodes.length == 0){
                if (["li", "h1", "h2", "h3", "div", "ul", "ol"].include(pnode.tagName.toLowerCase()) && String(node.textContent).trim().length){
                    pnode.parentNode.insertBefore(document.createElement("br"), pnode);
                }
            	pnode.parentNode.removeChild(pnode);
            }
            
            if (node.parentNode && this.isNodePartOfSelection(node.parentNode) && 
            		!(["ul", "ol"].include(node.parentNode.tagName.toLowerCase()) && $A(node.parentNode.childNodes).indexOf(node))){
            	this.removeFormatedContainer(node, root);
            }
        },

        /**
         * Returns the start text node of the 
         * given dom range
         * @param range
         * @returns
         */
        getStartTextNode: function(range, root){
        	var start = this.getChildTextNode(range.startContainer, range.startOffset);
        	 // If the offset is at the end of the given start text node, use next one
            if (start && (range.startContainer == start && range.startOffset && range.startOffset == start.textContent.length) ||
            			(start.nodeType != 3)){
            	start = this.getNextTextNode(start, root);
            }
            
//            if (start && start.nodeType == 3){
//        		var nstart;
//        		while(nstart = this.getPreviousTextNode(start, start.parentNode)){
//        			start = nstart;
//        		}
//        	}
            return start;
        },

        /**
         * Returns the last/end text node of the 
         * given dom range
         * @param range
         * @returns
         */
        getEndTextNode: function(range, root){
        	var end = this.getChildTextNode(range.endContainer, range.endOffset);
        	// If the offset is at the beginning of the given end text node, use previous one
            if (end && (range.endContainer == end && range.endOffset === 0)||
            		(end.nodeType != 3)){
            	end = this.getPreviousTextNode(end, root);
            }
            
//            if (end && end.nodeType == 3){
//        		var nend;
//        		while(nend = this.getNextTextNode(end, end.parentNode)){
//        			end = nend;
//        		}
//        	}
            return end;
        },
        
        /**
         * Iterates over all element starting from 
         * the start container to the end container and removes
         * @param range
         * @param root
         * @returns {String}
         */
        iterateOverTextElements: function(range, root){
            var text = "", start, cstart, end, cend, cparent, firstNodeIsIncluded;
            start = cstart = this.getStartTextNode(range, root);
            end = cend = this.getEndTextNode(range, root);
            
            while(start && end){
            	if (cparent != start.parentNode){
            		cparent = start.parentNode;
            		firstNodeIsIncluded = $A(cparent.childNodes).indexOf(start) == 0;
            	}
            	
            	if (firstNodeIsIncluded){
            		this.removeFormatedContainer(start, root);
            	}
                if (start == end){ break; }
                start = this.getNextTextNode(start, root);
            }

            if (cstart && cend){
	            range.setStart(cstart, 0);
	            range.setEnd(cend, cend.textContent.length);
            }
        },
        
        /**
         * 
         * @param listType
         * @returns {Boolean}
         */
        isSelectionContainedInTag: function(tagName, stopAtTagNames){
        	var selection = this.getSelection();
        	if(selection && "string" == typeof tagName && selection.rangeCount > 0 && selection.getRangeAt){
        		var range = selection.getRangeAt(0);
        		if (range){
        			var node = range.commonAncestorContainer;
        			tagName = tagName.toLowerCase();
        			stopAtTagNames = [].concat(stopAtTagNames || undefined).compact().invoke("toLowerCase");
        			while (node && (node.nodeType !== 1 || node.tagName.toLowerCase() !== "body")){
        				if (node.nodeType === 1){
            				var tag = node.tagName.toLowerCase();
        					if (tag === tagName){
        						return true;
        					} else if (stopAtTagNames.include(tag)){
        						return false;
        					}
        				}
        				node = node.parentNode;
        			}
        		}
        	}
        	return false;
        },
        
        /**
         * Toggle alignment of text
         * @param {String} align left | center | right
         */
        align: function(align) {
            switch(align) {
                case 'left':
                    this.logCmd('justifyleft');
                    break;
                case 'center':
                    this.logCmd('justifycenter');
                    break;
                case 'right':
                    this.logCmd('justifyright');
                    break;
            }  
        },
        
        /**
         * Removes all formatting from the current selection or 
         * if singleCursorSelection is active removes all formatting
         * from the current paragraph. 
         */
        /*
	    removeFormat: function() {		
	    	var selection = this.getSelection();	    	
	    	var range = selection.getRangeAt(0);
	    	var singleCursorSelection = this.isSingleCursorSelection(range);
	    	var commonAncestor = this.getAncestor(selection , singleCursorSelection);
	    	var bounds = undefined;
	    	
	    	if(Ext.isSafari) {
	    		bounds = this.findHighestSiblings(range.startContainer, range.endContainer);
                
                if(this.isStyleElement(commonAncestor) && 
                    commonAncestor.firstChild === bounds.left &&
                    commonAncestor.lastChild === bounds.right) {
                    
                    // this fixes a bug where all the content of an style elment was selected
                    // but remove format would not recognize the element itself and thus
                    // would not remove any formatting
                    bounds.left = commonAncestor;
                    bounds.right = commonAncestor;
                }
                
	    		this.removeFormatAndPreserveLists(bounds.left, bounds.right);
	    	} else {
		    	// remove everything like bold, italic, etc.
		    	this.relayCmd('removeformat');
		    	this.relayCmd('justifyleft');
		    	
		    	// standard relayCmd does not work if nothing is selected
		    	// this will remove all formatting inside the commonAncestor
		    	if(singleCursorSelection) {
		    		bounds = this.computeHighestBounds({
		    				left: range.commonAncestorContainer,
		    				right: range.commonAncestorContainer
		    		});
		    		
		    		this.selectBetween(bounds.left, bounds.right);
		    		this.relayCmd('removeformat');
		    	} 
	    	}	    	
	    	
	    	//if(this.isMultiLineSelection(selection)) {
			this.removeHeadings(range.startContainer, range.endContainer);
    		//}
	    	
	    	// containers will only be removed if all of their children are selected
	    	// _OR_ if the cursor is placed inside the element and nothing is selected
	    	if(this.isContainer(commonAncestor) && 
	    	   (this.allChildrenSelected(commonAncestor)	|| 
	    		singleCursorSelection)) {
	    		
	    		this.removeContainer(commonAncestor, true);	    		
	    	} 	    	
	    },
        */
        
        doUndo: function() {
            var lastCommand = this.undoStack.pop();
            
            while(!lastCommand && this.undoStack.length > 0) {lastCommand = this.undoStack.pop();}
            
            if(lastCommand) {
                this.redoStack.push(lastCommand);
                lastCommand.rollback();
                
                // Fix for leading whitespace and blinking cursor over the height of the iframe
                if (this.body.innerHTML === '') {
                	this.body.innerHTML = '<br/>'; 
                }
            }
            
            this.updateToolbar();
            this.win.focus();
        },
        
        doRedo: function() {
            var nextCommand = this.redoStack.pop();
            
            while(!nextCommand && this.redoStack.length > 0) {nextCommand = this.redoStack.pop();} 
            
            if(nextCommand) {
                this.undoStack.push(nextCommand);
                nextCommand.execute();
                
                // Fix for leading whitespace and blinking cursor over the height of the iframe
                if (this.body.innerHTML === '') {
                	this.body.innerHTML = '<br/>'; 
                }
            }  
            
            this.updateToolbar();
            this.win.focus();
        },
        
        // END OF CONVENIENCE WRAPPERS

        /**
         * @Override
         */
        pushValue : function(){
          if(this.initialized){
              var v = this.el.dom.value;
              // removed the part where an empty value was set to '&nbsp;'
              // if(!this.activated && v.length < 1){
              //     v = '&nbsp;';
              // }
              if(this.fireEvent('beforepush', this, v) !== false){
                  this.getEditorBody().innerHTML = v;
                  this.fireEvent('push', this, v);
              }
          }
        },
		   
        getDocMarkup : function(){
        	var style = 'body{border:0;margin:0;padding:3px;height:98%;cursor:text;word-wrap:break-word;}\n';//padding: ((Ext.isIE9 || Ext.isIE10) ? '0' : '3')
        	style += 'body{font-family: tahoma,arial,helvetica,sans-serif;font-size:12px;}\n';
        	style += 'a{color:#ad0f5b !important;}\n';
        	style += 'a font, a span{color:#AD0F5B !important;}\n';
        	style += 'i{padding-right:1px;}\n';
        	style += 'p{margin:0px;}\n';
        	style += 'blockquote{padding:0;margin:0;border:none;background:none !important;}';
        	style += 'ul,ol{padding-left:0px;}\n';
        	style += 'ul ul,ul ol,ol ul,ol ol{padding-left:30px;}\n';
        	style += 'li{margin-left:40px;}\n';
        	style += '.x-no-background{background:none !important;}\n';
        	
        	if (Ext.isIE){
        		style += 'ul,ol{margin:'+((Ext.isIE9 || Ext.isIE10) ? '0' : '-8')+'px 0px 6px 0px;}';
        		style += 'hr {margin:-8px 0px 6px 0px;}';
        		style += 'html {overflow: auto !important;}';
        		style += 'body {height: 100% !important;overflow: auto !important;}';
        	}
        	return '<html><head><style type="text/css">'+style+'</style></head><body></body></html>';
        },

		/**
		 * @override
		 */
		onRender: function() {
			Ext.ux.form.RichtextEditor.superclass.onRender.apply(this, arguments);
            
			this.win = this.iframe.contentWindow;
            this.body = this.doc.body; 
            this.undoStack = [];
            this.redoStack = [];
            
            Event.observe(this.doc, 'keyup', this.handleKeyUp.bind(this)); 
            Event.observe(this.doc, 'keydown', this.initializeOldValues.bind(this));
            Event.observe(this.doc, 'mouseup', this.initializeOldValues.bind(this));
            Event.observe(this.doc, 'click', this.handleLinkClick.bind(this));
            Event.observe(this.win, 'blur', this.handleBlur.bind(this));    
            
            this.on("push", this.updateTitleOnLinks.bind(this));
            
//            Event.observe(this.doc, 'paste', this.handlePaste.bind(this));
            
            if(this.hideToolbar) {
                $(this.tb).hide();
            }
		},
		
		/**
		 * Handles the blur event of the iframe
		 */
		handleBlur : function() {
			// Suppose the target has changed
			this.iframeChanged = true;
			
			// The iframe has regained the focus
			var fn = function() {
				this.iframeChanged = false;	
			}.bind(this);
			
			// If already a blur timeout exists, clear it
			if (this.blurTimeout) {
				window.clearTimeout(this.blurTimeout);
				if (document.removeEventListener instanceof Function) {
					document.removeEventListener("focus", fn, true);					
				} else {
					document.detachEvent("onFocus", fn);
				}
				
			}
			
			// Wait for the iframe to being targeted again
			if (document.addEventListener instanceof Function) {
				document.addEventListener("focus", fn, true);
			} else {
				document.attachEvent("onFocus", fn);
			}
			
			// Set the timeout to wait for being targetted again
			this.blurTimeout = window.setTimeout(function(iframe) {
				if (document.removeEventListener instanceof Function) {
					document.removeEventListener("focus", fn, true);
				} else {
					document.detachEvent("onFocus", fn);
				}
				// If the iframe has changed, discard the timeouts of the previous iframe
				// TODO: save contents
				if (this.iframeChanged) {
					window.clearTimeout(this.timeout);
				}
				
				this.fireEvent("blur", this);
			}.bind(this), 10, this);
		},
		
		/**
		 * When a link is clicked with pressed crtl-key, open the link in a new tab/window
		 * @param event
		 */
		handleLinkClick : function(event) {
			if (event.ctrlKey) {
				// Get the target and check if it's a link
				var target = (event.target||{});
				if ((target.nodeName||"").toLowerCase() === "a") {
					window.open(target.href);
					Event.stop(event);
				}	
			}
			
		},
		
        initializeOldValues: function() {
            if(!this.oldHTML) {
                var selection = this.getSelection();
                
                if(selection.rangeCount === 0) {
                  return;
                }

                // Get the range
                if (selection.getRangeAt) {
                	var range = selection.getRangeAt(0);
                } else {
                	var range = document.createRange ? document.createRange() : selection.createRange();
                    // Create a range exactly like the user selection
                	range.setStart(selection.anchorNode, selection.anchorOffset);
                    range.setEnd(selection.focusNode, selection.focusOffset);
                }

                
                this.oldHTML = this.originalValue;
                this.oldBreadcrump = this.getBreadcrump(range.endContainer);
                this.oldOffset = range.endOffset;
            }
        },
                
        handleKeyUp: function(e) {            

        	if(this.timeout) {
                window.clearTimeout(this.timeout);
            }
                
            var k = e.keyCode;
            
            if (k === Ext.EventObject.ENTER) {     
                this.logKeys();
            } else if(k === Ext.EventObject.BACKSPACE || k === Ext.EventObject.DELETE) {
                if(Math.abs(this.oldHTML.length - this.body.innerHTML.length) >= 2) {
                    this.logKeys();
                }
            } else if (!e.ctrlKey) {
                this.keyCount++;
                
                if (this.keyCount >= 60) {
                    // heavy typing going on. log every 60 characters
                    this.logKeys();
                } else if(this.keyCount > 5){
                    // If more than 5 letters are typed, log them (fast)
                    this.timeout = window.setTimeout(this.logKeys.bind(this), 500);
                } else if(this.keyCount <= 5){
                    // If less than 5 letters are typed, wait longer (2s)
                    this.timeout = window.setTimeout(this.logKeys.bind(this), 2000);
                }
            }
        },
        
        // XXX
        handlePaste : function(event) {
        	if (this.timeout) {
        		window.clearTimeout(this.timeout);
        	}
//    		this.container.mask("Inhalt wird überprüft");
//        	Ext.fly(this.body).hide();
    		var wait = 50;
        	this.timeout = window.setTimeout(function(context) {
        		var decoded = Ext.ux.Richtext.decode(context.body);
        		var reencoded = Ext.ux.Richtext.encode(decoded.text, decoded.format);
        		context.body.innerHTML = reencoded;
//    			var decoded = Ext.ux.Richtext.decode(me.body);
//    			console.log(decoded.text);
//    			var reencoded = Ext.ux.Richtext.encode(decoded.text, decoded.format);
//    			me.body.innerHTML = reencoded||decoded.text;
//    			Ext.fly(me.body).show();
//        		console.log(context.body);
//    			context.container.unmask();
    		}, wait, this);
        },
        
        /**
         * Retrieves the position of a node in the dom according
         * to the its in index in its parentnode's childNodes array
         * 
         * @param {Object} node
         * @return {Array} An array containing all indices starting at the body element
         */
        getBreadcrump: function(node) {
            var parentIndicies = [];
            
            while(!this.isNotEditable(node.parentNode)){
                parentIndicies.push($A(node.parentNode.childNodes).indexOf(node));
                node = node.parentNode;
            }

            return parentIndicies.reverse();  
        },
        
        /**
         * Logs changes that were made only by typing text
         */
        logKeys: function() {
            if (this.win) {
                // if shapes are edited and you are quick clicking outside the
                // editor it is possible that the component is being destroyed 
                // before the keys could be logged
                var innerHTML = this.oldHTML;
                
                // Get the selection
                var selection = this.getSelection();
                
                if (!selection) {
                	return;
                }
                
                // Get the range
                if (selection.getRangeAt) {
                	var range = selection.getRangeAt(0);
                } else {
                	var range = document.createRange ? document.createRange() : selection.createRange();
                    // Create a range exactly like the user selection
                	range.setStart(selection.anchorNode, selection.anchorOffset);
                    range.setEnd(selection.focusNode, selection.focusOffset);
                }

                var offset = range.endOffset;
                var breadcrump = this.getBreadcrump(range.endContainer);
                
                var conf = {
                    oldBreadcrump: this.oldBreadcrump,
                    oldOffset: this.oldOffset,
                    oldHTML: this.oldHTML,
                    newBreadcrump: breadcrump,
                    newOffset: offset,
                    newHTML: this.body.innerHTML
                };
                
                this.executeCommand(new Ext.ux.Command(this, conf));
                
                this.keyCount = 0;
                this.oldHTML = this.body.innerHTML;
                this.oldOffset = offset;
                this.oldBreadcrump = breadcrump;
            }       
        },
                                        
		/**
		 * @override
		 */
        
        applyCommand: function(e) {				
        	var c = e.getCharCode();
			if (c > 0) {
				c = String.fromCharCode(c).toLowerCase();
			}
            
        	if(e.getKey() === e.TAB && this.enableParagraph) {
        		if ((!this.undoStack||!this.undoStack.length) &&
        			(!this.redoStack||!this.redoStack.length)){
        			return;
        		}
				e.stopEvent();
            				
				// If the cursor is inside a code block, handle tab press differently
	    		if(this.enableCodeBlock && this.isInsideCodeBlock()) {
	    			this.handleTabInsideCodeBlock(e);
	    		} else if(e.shiftKey) {
	    			this.outdent();
				} else {
					this.indent();
				}				
			} else if(e.ctrlKey && ['b', 'i', 'u', 'z'].include(c)) {                
                e.stopEvent();
                var cmd;
                switch (c) {
                    case 'b':
                        cmd = 'bold';
                        break;
                    case 'i':
                        cmd = 'italic';
                        break;
                    case 'u':
                        if (this.enableUnderline) {
                            cmd = 'underline';
                        }
                        break;
                    case 'z':
                        if (e.shiftKey) {
                            this.doRedo();
                            this.win.focus();
                        }
                        else {
                            this.doUndo();
                            this.win.focus();
                        }
                        break;
                    case 'y':
                        this.doRedo();
                    	this.win.focus();
                        break;
                }
                
                if(cmd){
                    this.logCmd(cmd);
                }            
            }
		},
        
		/**
		 * @override
		 */
		fixKeys: function(e) {
			return function(e) {
				var c = e.getCharCode();
				if (c > 0) {
					c = String.fromCharCode(c).toLowerCase();
				}
				
				// If a paragraph or a code block is selected, use tab and shift+tab to indent or outdent it
				if(e.getKey() === e.TAB && this.enableParagraph) {
                	e.stopEvent();
                	e.preventDefault();

                	// If the cursor is inside a code block, handle tab press differently
    	    		if(this.enableCodeBlock && this.isInsideCodeBlock()) {
    	    			this.handleTabInsideCodeBlock(e);
    	    		} else if(e.shiftKey) {
    	    			this.outdent();
    				} else {
    					this.indent();
    				}
                }
				
				// If ctrl is pressed, check if it a richtext command or a general command
				else if(e.ctrlKey && ['b', 'i', 'u', 'z', 'y'].include(c)) {
                    e.stopEvent();
                    var cmd;                    
                    switch (c) {
                        case 'b':
                            cmd = 'bold';
                            break;
                        case 'i':
                            cmd = 'italic';
                            break;
                        case 'u':
                            if (this.enableUnderline) {
                                cmd = 'underline';
                            }
                            break;
                        case 'z':
                            if (e.shiftKey) {
                                this.doRedo();
                                this.win.focus();
                            }
                            else {
                                this.doUndo();
                                this.win.focus();
                            }
                            
                            break;
                        case 'y':
                            this.doRedo();
                        	this.win.focus();
                            break;
                    }
                    
                    if(cmd){
                        this.logCmd(cmd);
                    }                       
                }
			};
	    }(),
		
	    /**
	     * Checks if the cursor is inside a code block
	     * @returns
	     */
	    isInsideCodeBlock : function() {
			if (this.enableCodeBlock) {
				var selection = this.getSelection();
	    		
	    		if(selection.rangeCount !== 0) {
	                // Get the range
	                if (selection.getRangeAt) {
	                	var range = selection.getRangeAt(0);
	                } else {
	                	var range = document.createRange ? document.createRange() : selection.createRange();
	                    // Create a range exactly like the user selection
	                	range.setStart(selection.anchorNode, selection.anchorOffset);
	                    range.setEnd(selection.focusNode, selection.focusOffset);
	                }
	            
		    		var ancestor = this.getAncestor(selection, this.isSingleCursorSelection(range));
		    		
		    		var codeBlock = this.searchCodeBlock(ancestor);
		    		
		    		return !!codeBlock;
	    		}
			} else {
				return false;
			}
	    	
	    },
	    
	    /**
	     * Handles pressing the tab key while the cursor is inside a code block
	     * @param e
	     */
	    handleTabInsideCodeBlock : function(e) {
	    	var selection = this.getSelection();
			if (e.shiftKey && this.enableCodeBlock) {
				if (selection.anchorOffset >= 4) {
					var cc = range.cloneContents();
					if (cc.childNodes.length === 0) {
						range.setStart(selection.anchorNode, selection.anchorOffset - 4);
						if (range.cloneContents().childNodes.length === 1 &&
							range.cloneContents().textContent.trim().length === 0) {
							this.logCmd("delete");
						} else {
							this.logCmd("outdent");
						}
					} else if (cc.lastChild.nodeName === "BR") {
						this.logCmd("outdent");
					}
				} else {
					this.logCmd("outdent");
				}
			} else {
				this.indent();
			}
	    },
	    
		/**
		 * @override
		 */
		createToolbar: function(editor) {            
            
			/**
			 * Creates a new Button for the toolbar.
			 * @param {String} id
			 * @param {Boolean} toggle
			 * @param {Function} handler
			 * @param {String} cls
			 * @param {String} icon
			 * @param {String} customId
			 * @returns Ext.Button
			 */
			function createButton(id, toggle, handler, cls, icon, customId) {
				return {
					itemId			: customId || id,
					cls				: "x-btn-icon y-horizontal-menu-button " + (cls ? cls : ''),
					enableToggle	: toggle !== false,
					scope			: editor,
					icon			: icon || '',
					handler			: handler || editor.relayBtnCmd,
					tabIndex		: -1,
					tooltip			: {
						title: Ext.ux.getI18N("richtext.title." + (customId || id).toLowerCase()),
	                	text: Ext.ux.getI18N("richtext.text." + (customId || id).toLowerCase())
					}
				};
			}

	        // build the toolbar
	        var tb = new Ext.Toolbar({
	            renderTo:this.wrap.dom.firstChild
	        });

	        // stop form submits
	        tb.el.on('click', function(e){
	            e.preventDefault();
	        });
	        
	        if (this.additionalToolbarButtons) {
	        	this.additionalToolbarButtons.each(function(btn) {
	        		tb.add(btn);
	        	}.bind(this));
	        }
	        
            // TODO implement!!!	        
	        if(this.enableUndoRedo) {
	        	tb.add(
	        		createButton('undo', false, this.doUndo.bind(this), 'x-edit-undo', Ext.IMAGE_URL + "/famfamfam"+ (Ext.isIPad ? '/32x32' : '') + "/arrow_undo.png", 'undo'),
	        		createButton('redo', false, this.doRedo.bind(this), 'x-edit-redo', Ext.IMAGE_URL + "/famfamfam"+ (Ext.isIPad ? '/32x32' : '') + "/arrow_redo.png", 'redo'),
	        		'-'
	        	);
	        }
				        
//	        if(this.enableFont){
//	            this.fontSelect = tb.el.createChild({
//	                tag:'select',
//	                cls:'x-font-select',
//	                html: this.createFontOptions()
//	            });
//                
//                new Ext.ToolTip({
//                    target: this.fontSelect,
//                    title: Ext.ux.getI18N("richtext.title.fontselect"),
//                    html: Ext.ux.getI18N("richtext.text.fontselect")
//                });
//                
//	            this.fontSelect.on('change', function(){
//	                var font = this.fontSelect.dom.value;
//	                this.logCmd('fontname', font);
//	                this.deferFocus();
//	            }, this);
//                
//	            tb.add(
//	                this.fontSelect.dom,
//	                '-'
//	            );
//	        }
	        
	        if(this.enableFontSize) {
	        	var me = this;
	        	this.fontSizeComboBox = new Ext.form.ComboBox({
	        		displayField	: 'display',
	        		valueField		: 'value',
	        		itemId			: 'fontsize',
	        		forceSelection	: true,
	        		mode			: 'local',
	        		triggerAction	: 'all',
	        		width			: 40,
	        		emptyText		: '12',
	        		store			: new Ext.data.SimpleStore({
	        			autoDestroy	: true,
	        			fields		: ['value', 'display'],
	        			data		: [[1, 10], [2, 12], [3, 16], [4, 18], [5, 24], [6, 32], [7, 48]]
	        		}),
	        		
	        		editable		: false,
	        		selectOnFocus	: false,
	        		disableKeyFilter: true,
	        		
	        		tabIndex		: -1,
	        		height			: 18,
	        		listWidth		: 25,
	        		iconCls			: 'no-icon',
		        	cls				: Ext.isChrome ? 'y-richtext-combobox-chrome' : 'y-richtext-combobox',
		        	ctCls			: ((Ext.isIE9 || Ext.isIE10) ? 'y-richtext-combobox-ct-ie9' : 'y-richtext-combobox-ct') + ' y-richtext-toolbar-button',
	        		listeners		: {
	 									"select" : function(combo, rec) {
	 										this.forceSelection();
	 										
	 										if (Ext.isIE9 || Ext.isIE10) {
	 											var selection = this.userSelection;
	 								        	var range = this.userRange;
	 											selection.removeAllRanges();
	 											selection.addRange(range);
	 											this.logCmd("fontsize", rec.get("value"));
	 										} else {
	 											/*
	 											var cont = this.getSelection().getRangeAt(0).commonAncestorContainer; 
	 											if (cont) {
	 												var parentNode = cont.parentNode;
	 												if (parentNode.nodeName === "SPAN") {
	 													this.logCmd(this.setStyle.bind(this, parentNode, "font-size", rec.get("display")+"px;"));
	 												} else {
		 												this.logCmd('fontsize', rec.get("value"));	
		 											} 
	 											} else {
	 											*/
	 												this.logCmd('fontsize', rec.get("value"));	
	 											//}
	 										}
	 										
	 										// If the size of text changes, update the highlightcolor if it's set
	 										if (Ext.isGecko) {
	 											// If no common ancestor container exists, there can be no background color set
	 											var cont = this.getSelection().getRangeAt(0).commonAncestorContainer;
	 											if (!cont || !cont.style || !cont.style.backgroundColor) {
	 												return;
	 											} 
	 											var color = this.getSelection().getRangeAt(0).commonAncestorContainer.style.backgroundColor;
	 											// If a backgroundcolor exists, update it to fit the text
	 											if (color) {
	 												this.relayCmd('useCSS', false);
		 					        				this.relayCmd('hilitecolor', color);
		 					        				this.relayCmd('useCSS', true);
		 					        				this.deferFocus();	
	 											}
	 										} else {
 												var range = (Ext.isIE9 || Ext.isIE10) ? (this.userRange || this.getSelection().getRangeAt(0)) : this.getSelection().getRangeAt(0);
 												var color = this.getSelection().getRangeAt(0).commonAncestorContainer.style && this.getSelection().getRangeAt(0).commonAncestorContainer.style['backgroundColor'] || undefined;
 												// If a color exists, refresh it
 												if (typeof color !== 'undefined') {
	 												this.relayCmd(Ext.isOpera || Ext.isChrome? 'hilitecolor' : 'backcolor', color);
	 					        				}
 					        					this.deferFocus();
	 					        			}
	 						        		combo.reset();
	 									}.bind(this)
	        		},
					onFocus			: function() {
	 	        		me.userSelection = me.getSelection();
	 	        		me.userRange = me.getSelection().getRangeAt(0);
	 	        		
	 	        		Ext.form.TriggerField.superclass.onFocus.call(this);
	 	        		if(!this.mimicing){
	 	        			this.wrap.addClass('x-trigger-wrap-focus');
	 	        			this.mimicing = true;
	 	        			Ext.get(Ext.isIE ? document.body : document).on("mousedown", this.mimicBlur, this, {delay: 10});
	 	        			if(this.monitorTab){
	 	        				this.el.on("keydown", this.checkTab, this);
	 	        			}
	 	        		}
	 	        	}
	        	});
	        	
	        	tb.add(this.fontSizeComboBox, '-');
	        	
	        }
	        
	        // BOLD/ITALIC/UNDERLINE
	        if(this.enableFormat){
	        	tb.add(
	        		createButton('bold', true, this.bold.bind(this), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-bold.png", 'bold'),
	        		createButton('italic', true, this.italic.bind(this), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-italic.png", 'italic')
	        	);
                
                if(this.enableUnderline) {
                    // underline currently not supported for svg graphics in FF
                    tb.add(
                    		createButton('underline', true, this.underline.bind(this), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-underline.png", 'underline')	
                    );
                }
	        }
	        
	        // FONT-COLOR/BACKGROUND
	        if(this.enableColors){
	            
	        	tb.add(
	        			'-', 
	        			createButton('color', false, this.changeColor.bind(this, 'color'), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-color.png", 'color'),
	        			createButton('markUpColor', false, this.changeColor.bind(this, 'markUpColor'), undefined, Ext.IMAGE_URL + "/fugue/icons" + (Ext.isIPad ? '/32x32' : '') + "/highlighter-text.png", 'markUpColor')
	        	);
	        	
	        	
	        	// Graft the color hint boxes
        		this.fontColorHint = ("undefined" !== typeof ORYX&&ORYX.Editor||Signavio&&Signavio.Core).graft("http://www.w3.org/1999/xhtml", undefined, this.getColorHint());
        		this.fontColorHint.style.background = 'none repeat scroll 0 0 #000000';
        		
        		// Correct the position of the hint
        		if (Ext.isFF) {
        			this.fontColorHint.style.top -= 2;
        		}

        		tb.items.map.color.el.dom.appendChild(this.fontColorHint);
	        }
	        
	        // HEADING
	        if(this.enableHeadings) {
            	tb.add(
            		'-',
            		createButton('heading', true, this.h1.bind(this), undefined, Ext.IMAGE_URL + "/famfamfam/text_heading_1.png", "h1"),
            		createButton('heading', true, this.h2.bind(this), undefined, Ext.IMAGE_URL + "/famfamfam/text_heading_2.png", "h2"),
            		createButton('heading', true, this.h3.bind(this), undefined, Ext.IMAGE_URL + "/famfamfam/text_heading_3.png", "h3")
            	);
            }
            
     
	        if(this.enableAlignments){
	            tb.add(
	                '-',
	                createButton('justifyleft', true, this.align.bind(this, 'left'), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + "/edit-alignment.png", 'justifyleft'),
	                createButton('justifycenter', true, this.align.bind(this, 'center'), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + "/edit-alignment-center.png", 'justifycenter'),
	                createButton('justifyright', true, this.align.bind(this, 'right'), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + "/edit-alignment-right.png", 'justifyright')
	            );
	        }	        
            
	        if(this.enableLists){
                tb.add(
                    '-',
                    createButton('insertorderedlist', true, this.ol.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + '/edit-list-order.png', 'insertorderedlist'),
                    createButton('insertunorderedlist', true, this.ul.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + '/edit-list.png', 'insertunorderedlist')
                );
            }
	        
	        if(this.enableParagraph) {
	        	tb.add(
	        		'-',
	        		createButton('outdent', false, this.outdent.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons' + (Ext.isIPad ? '32x32' : '') + '/edit-outdent.png', 'outdent'),
	        		createButton('indent', false, this.indent.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons' + (Ext.isIPad ? '32x32' : '') + '/edit-indent.png', 'indent')
	        		
	        	);
	        }
	        
            if(this.enableLinks){
                tb.add(
                    '-',
                    createButton('createlink', false, this.link.bind(this), undefined, Ext.IMAGE_URL + '/famfamfam' + (Ext.isIPad ? '32x32' : '') + '/world_link.png', 'createlink'),
                    createButton('unlink', false, this.unlink.bind(this), undefined, Ext.IMAGE_URL + '/famfamfam' + (Ext.isIPad ? '32x32' : '') + '/link_break.png', 'unlink')
                );
            }
            
            
            if(this.enableHorizontalRule) {
                tb.add(
                    '-',
                    createButton('inserthorizontalrule', false, this.hr.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons/edit-rule.png', 'inserthorizontalrule')
                );
            }
            
            if(this.enableCodeBlock) {
            	tb.add(
        			createButton('insertcodeblock', false, this.insertCodeBlock.bind(this), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-color.png", "insertcodeblock")
            	);
            }
            
            
            if(this.enableRemoveFormat) {
            	tb.add(
                	'->',
            		createButton('removeformat', false, this.removeFormat.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + '/eraser.png', 'removeformat')
            	);
            }
           	        
	        this.tb = tb;            
	    },
	    
        executeCommand: function(cmd) {
            this.undoStack.push(cmd);
            this.redoStack = [];
            
            this.updateToolbar();
            this.win.focus();
        },
        
        /*
        setStyle : function(node, key, value) {
        	if (node.hasAttribute("style")) {
        		var styles = node.getAttribute("style");
        		if (styles.include(key)) {
        			styles = styles.replace(new RegExp(""+key+":[^;]+;", "gi"), key+":"+(value.endsWith(";") ? value : value+";"));
        		} else {
        			styles += (key+":"+(value.endsWith(";") ? value : value+";"));
        		}
        	} else {
        		styles = (key+":"+(value.endsWith(";") ? value : value+";"));
        	}
        	node.setAttribute("style", styles);
        },
        */
        
        /**
         * Returns a range object for the current selection
         * @param {DOMSelection} selection (optional)
         * @returns {DOMRange}
         */
        getRange: function(selection){
        	// Get the selection
        	selection = selection || this.getSelection();
            
            // Get the range
        	if (selection.rangeCount == 0) {
            	return this.win.document.createRange ? this.win.document.createRange() : selection.createRange();
            
        	} else if ("function" == typeof selection.getRangeAt) {
            	return selection.getRangeAt(0);
            	
            } else {
            	var range = this.win.document.createRange ? this.win.document.createRange() : selection.createRange();
                // Create a range exactly like the user selection
            	range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
                return range;
            }
        },
        
        /** 
         * Logs a command
         * 
         * @param {String | Function} cmd
         * @param {Object} value
         * @param {Function} clb
         */
        logCmd: function(cmd, value, clb) {
            
        	var selection = this.getSelection(),
        		range = this.getRange(selection);
            
            if("function" == typeof cmd) {
                cmd();
            } else {
                this.relayCmd(cmd, value);                
            }
            
            selection = this.getSelection();
            if (selection.rangeCount <= 0){
            	return;
            }
            range = selection.getRangeAt(0);
            
            var offset = range.endOffset;
            var breadcrump = this.getBreadcrump(range.endContainer);
            
            var conf = {
                oldHTML: this.oldHTML,
                oldOffset: this.oldOffset,
                oldBreadcrump: this.oldBreadcrump,
                newHTML: this.body.innerHTML,
                newOffset: offset,
                newBreadcrump: breadcrump
            };
            
            // only log if something has changed.
            if (this.oldHTML !== this.body.innerHTML) {
                this.executeCommand(new Ext.ux.Command(this, conf));
                
                this.oldHTML = this.body.innerHTML;
                this.oldOffset = offset;
                this.oldBreadcrump = breadcrump;
            }  
            
            if (clb instanceof Function) {
            	clb();
            }
        },   
        
	    /**
	     * @override
	     */
        onFocus : function() {
        	if (!this.activated) {
        		this.onFirstFocus();
        		return;
        	}
        },
        
        /**
	     * @override
	     */
        updateToolbar: function() {
            if(!this.activated){
                this.onFirstFocus();
                return;
            }
            // The toolbar buttons
	    	var buttons = this.tb.items.map;
	    	// The document
	    	var doc = this.doc;
	    	
	    	
//	    	if (this.isInsideCodeBlock()) {
//	    		var buttonNames = "";
//	    		buttonNames += (this.enableLists ? "insertorderedlist insertunorderedlist " : "");
//	    		buttonNames += (this.enableFormat ? "bold italic " : "");
//	    		buttonNames += (this.enableUnderline ? "underline " : "");
//	    		buttonNames += (this.enableAlignments ? "justifyleft justifycenter justifyright " : "");
//	    		buttonNames += (this.enableHeadings ? "h1 h2 h3 " : "");
//	    		buttonNames += "createlink insertcodeblock inserthorizontalrule markUpColor removeformat unlink color";
//	    		
//	    		var btns = $w(buttonNames);
//	    		btns.each(function(name) {
//	    			buttons[name].disable();
//	    		});
//	    		if (this.fontSizeComboBox) {
//	    			this.fontSizeComboBox.disable();
//	    		}
//	    		Ext.menu.MenuMgr.hideAll();
//		    	this.syncValue();
//	    		return;
//	    	} else if (this.enableCodeBlock) {
//	    		var buttonNames = "";
//	    		buttonNames += (this.enableLists ? "insertorderedlist insertunorderedlist " : "");
//	    		buttonNames += (this.enableFormat ? "bold italic " : "");
//	    		buttonNames += (this.enableUnderline ? "underline " : "");
//	    		buttonNames += (this.enableAlignments ? "justifyleft justifycenter justifyright " : "");
//	    		buttonNames += (this.enableHeadings ? "h1 h2 h3 " : "");
//	    		buttonNames += "createlink insertcodeblock inserthorizontalrule markUpColor removeformat unlink color";
//	    		
//	    		var btns = $w(buttonNames);
//	    		btns.each(function(name) {
//	    			buttons[name].enable();
//	    		});
//	    		if (this.fontSizeComboBox) {
//	    			this.fontSizeComboBox.enable();
//	    		}
//
//	    	}
	    	
	    	if (this.enableColors) {
	    		if (this.getSelection instanceof Function && this.getSelection() && this.getSelection().getRangeAt(0)) {
	    			var textColor = this.getSelection().getRangeAt(0).commonAncestorContainer.parentNode.color;
	    		}
	    		// If the text has a color != black
    			if (textColor) {
    				// If the font color hint exists, set the new color
    				if (this.fontColorHint && this.fontColorHint.style) {
    					this.fontColorHint.style.background = "none repeat scroll 0% 0% "+textColor;
    				}
    				// If the color hint is not rendered yet, append it to the color button
    				if (this.fontColorHint && !this.fontColorHint.parentNode) {
    					buttons.color.el.dom.appendChild(this.fontColorHint);
    				}
    			// If no color is set, remove the color hint box
	    		} else if (this.fontColorHint && this.fontColorHint.parentNode) {
	    			this.fontColorHint.parentNode.removeChild(this.fontColorHint);
	    		}
	    	}
	    	
	    	// Toggle list buttons
	    	if(this.enableLists) {
	    		buttons.insertorderedlist.toggle(doc.queryCommandState('insertorderedlist'));
	    		buttons.insertunorderedlist.toggle(doc.queryCommandState('insertunorderedlist'));
	    	}
	    	
            
	    	// Toggle font format buttons
            if(this.enableFormat){
                buttons.bold.toggle(doc.queryCommandState('bold'));
                buttons.italic.toggle(doc.queryCommandState('italic'));
                
                if (this.enableUnderline) {
                    buttons.underline.toggle(doc.queryCommandState('underline'));
                }
            }
            
            // Toggle the alignment button
            if(this.enableAlignments){
            	var jc = doc.queryCommandState('justifycenter'), jr = doc.queryCommandState('justifyright');
                buttons.justifyleft.toggle(!jc && !jr);
                buttons.justifycenter.toggle(jc);
                buttons.justifyright.toggle(jr);
            }
            
            /*
            if(this.enableFont && !Ext.isSafari){
                var name = (this.doc.queryCommandValue('FontName')||this.defaultFont).toLowerCase();
                if(name != this.fontSelect.dom.value){
                    this.fontSelect.dom.value = name;
                }
            }
            */
            /*
	    	if((Ext.isSafari || Ext.isOpera) && this.enableFont) {
	    		var name = (doc.queryCommandValue('FontName') || this.defaultFont).toLowerCase()
	    																		  .split(",")[0]
	    																		  .replace(/"|'/g, "");
	    		var value = $(this.fontSelect.dom).getValue();
	    		
	    		if(name != value) {	    			
	    			if(Ext.isOpera) {
	    				// Opera is just a bitch!
	    				document.getElementById(this.fontSelect.dom.id).value = name;
	    			} else {
	    				this.fontSelect.dom.value = name;
	    			}
	    		}
	    	}
	    	*/
            
            // Set the font size combo box value
	    	if(this.enableFontSize) {
	    		var size = doc.queryCommandValue('FontSize');
	    		this.fontSizeComboBox.setValue(size);
	    	}
            
	    	// Enable/Disable Undo/Redo buttons
            if(this.enableUndoRedo) {
                this.undoStack.length === 0 ? buttons.undo.disable() : buttons.undo.enable();
                this.redoStack.length === 0 ? buttons.redo.disable() : buttons.redo.enable();
            }
	    	
            // Toggle Headline buttons
	    	if(this.enableHeadings) {
	    		var selection = this.getSelection();
	    		var type = undefined;
	    		
	    		if(selection.rangeCount !== 0) {
	                // Get the range
	                if (selection.getRangeAt) {
	                	var range = selection.getRangeAt(0);
	                } else {
	                	var range = document.createRange ? document.createRange() : selection.createRange();
	                    // Create a range exactly like the user selection
	                	range.setStart(selection.anchorNode, selection.anchorOffset);
	                    range.setEnd(selection.focusNode, selection.focusOffset);
	                }
	            
		    		var ancestor = this.getAncestor(selection, this.isSingleCursorSelection(range));
		    		
		    		var heading = this.searchHeading(ancestor);
		    		
		    		if(heading) {
		    			type = heading.nodeName.toLowerCase();	
		    		} 
	    		}
	    		
	    		buttons.h1.toggle((type ? type === 'h1' : false));
    			buttons.h2.toggle((type ? type === 'h2' : false));
    			buttons.h3.toggle((type ? type === 'h3' : false));
	    	}
	    	
	    	Ext.menu.MenuMgr.hideAll();
	    	
	    	this.syncValue();
	    },
	    
	    /**
	     * @override
	     */
	    createLink: function() {
	    	var selection = this.getSelection();	    	
            
            // Get the range
            if (selection.getRangeAt) {
            	var range = selection.getRangeAt(0);
            } else {
            	var range = document.createRange ? document.createRange() : selection.createRange();
                // Create a range exactly like the user selection
            	range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
            }
        
	    	var link = undefined;
	    	
	    	if(this.isSingleCursorSelection(range)) {
	    		link = this.findLink(range.commonAncestorContainer);
	    	} else {
	    		link = this.findLink(range.startContainer, range.endContainer);
	    	}
	    	
	    	/*
	    	 * Show the input box for the link to set
	    	 * If no link exists in the selected text, create a new one
	    	 */
    		var prompt = Ext.Msg.show({
    			   title		: this.createLinkText,
    			   msg			: Ext.ux.getI18N('richtext.link.address'),
    			   buttons		: Ext.Msg.OKCANCEL,
    			   icon			: Ext.MessageBox.QUESTION,
    			   // Show the existing value
    			   value		: link ? link.getAttribute("href") : 'http://',
    			   prompt		: true,
    			   fn			: function(btn, value) {
    				   if (btn === 'ok' && value.length > 0) {
    					   // Allow a set of protocols
    					   if (!["http", "https", "ftp", "file", "mailto"].include((value.split(":").first()||"").toLowerCase())) {
    						   value = Signavio.Utils.evaluateLocalURL(value);
    						   
    						   if (!value.startsWith("file")) {
    							   value = "http://" + value;
    						   }
    					   }
    					   
    					   if (link) {
    						   // Update the link
    						   link.setAttributeNS(null, 'href', value.stripTags());
    						   link.setAttributeNS(null, "title", value.stripTags() + ", " + Ext.ux.getI18N('richtext.link.tooltip'));
//    						   link.setAttributeNS(null, 'title', value.stripTags() + ", öffnen mit Strg+Klick.");   
//    						   link.setAttributeNS(null, 'alt', value.stripTags() + ", öffnen mit Strg+Klick.");
    					   } else {
    						   // Create a new link
    						   selection.removeAllRanges();
    						   selection.addRange(range);
    						   this.logCmd("createlink", value.stripTags(), function() {
    							   this.updateTitleOnLinks();
    						   }.bind(this));
    						   
    					   }
    					   
    				   }
    			   }.bind(this)
    		});
    		
    		prompt.getDialog().on("render", function() {
    			this.el.dom.getElementsByTagName("input")[0].focus();
    		});
//    		if (prompt.getDialog().rendered) {
//    			prompt.getDialog().el.dom.getElementsByTagName("input")[0].focus();
//    		}
	    },  
	    
	    removeLink: function() {
	    	var selection = this.getSelection();
            
            // Get the range
            if (selection.getRangeAt) {
            	var range = selection.getRangeAt(0);
            } else {
            	var range = document.createRange ? document.createRange() : selection.createRange();
                // Create a range exactly like the user selection
            	range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
            }
        
	    	var link = undefined;
	    	
	    	if(this.isSingleCursorSelection(range)) {
	    		link = this.findLink(range.commonAncestorContainer);
	    		if (!link && // If the cursor is a the begining of an anchor
	    				range.commonAncestorContainer.nodeType == 3 &&
	    				range.commonAncestorContainer.textContent.length == range.endOffset &&
	    				range.commonAncestorContainer.nextSibling){
	    			link = this.findLink(range.commonAncestorContainer.nextSibling);
	    		}
	    	} 
	    	
	    	if(link) {
	    		this.selectBetween(link, link);	    		
	    	}
	    	
	    	this.logCmd('unlink');
	    },
	    
	    findLink: function(l, r) {
	    	if(!r) {
	    		if(this.isLink(l)) {
	    			return l;
	    		} else if(l.parentNode &&
	    				 !this.isBody(l.parentNode)) {
	    			
	    			return this.findLink(l.parentNode);
	    		}
	    		
	    		return null;
	    	}
	    	
	    	var leftLink = this.findLink(l);
	    	var rightLink = this.findLink(r);
	    	
	    	if(leftLink === rightLink) {
	    		return leftLink;
	    	}
	    	
	    	return null;
	    },
	    
	    /**
	     * Iterates over all links inside the body and adds a tooltip if none is set
	     */
	    updateTitleOnLinks : function() {
	    	var links = Ext.DomQuery.select("a:not([title])", this.body);
	    	links.each(function(link) {
	    		var title = link.href + ", " + Ext.ux.getI18N("richtext.link.tooltip");
	    		link.setAttribute("title", title);
	    	});
	    },
	    
		/**
		 * Due to a misshapen implementation of the midas commands 'indent' and 'outdent' in Ext 2.0.2, a blockquote is generated
		 * instead of a div with margin-left. Using the command styleWithCSS fixes the problem. Be careful to switch off the command
		 * after using to prevent undefined behaviour of other commands. The command useCSS is deprecated. 
		 */
	    indent : function() {
	    	this.relayCmd("styleWithCSS", true);
			this.logCmd("indent");
			this.relayCmd("styleWithCSS", false);
	    },
	    
	    /**
		 * Due to a misshapen implementation of the midas commands 'indent' and 'outdent' in Ext 2.0.2, a blockquote is generated
		 * instead of a div with margin-left. Using the command styleWithCSS fixes the problem. Be careful to switch off the command
		 * after using to prevent undefined behaviour of other commands. The command useCSS is deprecated. 
		 */
	    outdent : function() {
	    	this.relayCmd("styleWithCSS", true);
			this.logCmd("outdent");
			this.relayCmd("styleWithCSS", false);
		},
	    
	    /**
	      * Displays a color picker menu to determine the color to set.
	      * @param button
	      */
	     changeColor : function(colortype, button, event) {
	    	 // delete any other previous opened color menu
	    	 if (this.colorMenu) {
	    		 this.colorMenu.destroy();
	    		 delete this.colorMenu;
	    	 }
	    	 var defaultColor = (colortype === 'color' ? '#000000' : '#FFFFFF');
	    	 
	    	 // Get the div to display the automatic color picker
    		 var colorDiv = ("undefined" !== typeof ORYX&&ORYX.Editor||Signavio&&Signavio.Core).graft('http://www.w3.org/1999/xhtml', undefined, this.getColorBox(defaultColor));	 
	    	 
	    	 // Define the color menu
	    	 this.colorMenu = new Ext.menu.ColorMenu({
	    		 allowOtherMenus	: false,
	    		 focus				: Ext.emptyFn,
	    		 plain				: true,
	    		 allowReselect		: true,
	             scope				: this,
	             listeners			: {
	            	 'itemclick'	: function (item, event) {
	    	    		 var color = (item.component ? "#"+item.component.value : defaultColor);
	    	    		 this.forceSelection();
	        			 if (colortype === 'color') {
	        				 // Set the color of the hint box
	        				 if (this.fontColorHint) this.fontColorHint.style.background = 'none repeat scroll 0 0 ' + color;
	        				 // Apply the font color
	        				 this.logCmd('forecolor', color);
	        				 this.deferFocus();
	        			 } else if (Ext.isGecko) {
	        				 // Set the highlight color
	        				 this.logCmd('useCSS', false);
	        				 this.logCmd('hilitecolor', color);
	        				 this.logCmd('useCSS', true);
	        				 this.deferFocus();
	        			 } else {
	        				 // Set the highlight color
	        				 this.logCmd(Ext.isOpera ? 'hilitecolor' : 'backcolor', color);
	        				 this.deferFocus();
	        			 }
	        		 }.bind(this)
	             },
	    		 items				: [{
	    			 text		: Ext.ux.getI18N("richtext.colormenu.defaultcolor"),
	    			 listeners	: {
	    				 'render'	: function(btn, event) {
	    					 if (colorDiv) {
	    						 btn.el.dom.appendChild(colorDiv);
	    					 }
	    				 }.bind(this)
	    			 }
	    		 }, '-']
	    	 });
		    	 
	    	 this.colorMenu.show(button.el, 'tl-bl?');
	     },
	    
	     /**
	      * Returns a div representing the default color
	      * @param {String} color
	      * @returns {Array} the raw Array to graft a new div container
	      */
	     getColorBox : function(color) {
	    	 return ['div', {
	    		 'class'	: 'y-richtext-color-box',
	    		 style		: 'background: none repeat scroll 0 0' + color + ';'
	    	 }];
	     },
	     
         /**
          * Returns a div container for the color hint
          * @returns {Array} the raw Array to graft a new div container
          */
	     getColorHint : function() {
	    	 
	    	 var cls = Ext.isIPad ? 'y-richtext2-color-hint y-richtext2-color-hint-ipad' :
	    		 		Ext.isFF3 ? 'y-richtext2-color-hint y-richtext2-color-hint-ff3' :
	    		 		Ext.isFF ? 'y-richtext2-color-hint y-richtext2-color-hint-ff' :
	    		 		Ext.isOpera ? 'y-richtext2-color-hint y-richtext2-color-hint-opera' :
	    		 		Ext.isChrome ? 'y-richtext2-color-hint y-richtext2-color-hint-chrome' :
	    		 		Ext.isIE ? 'y-richtext2-color-hint y-richtext2-color-hint-ie' :
	    		 			'y-richtext2-color-hint';
	    	 
	    	 return ['div', {
	    		'class'	: cls
	    	 }];
	     },
        
	    getTextNodeAtPosition: function(node, offset){
	    	if (node && node.nodeType === 3){
	    		return node;
	    	}
	    	if (node && node.nodeType === 1){
	    		if (node.childNodes.length == 0){
	    			return this.getTextNodeAtPosition(offset == -1 ? node.previousSibling : node.nextSibling, offset == -1 ? -1 : 0);
	    		} else {
	    			return this.getTextNodeAtPosition(offset == -1 ? $A(node.childNodes).last() : node.childNodes[offset], offset == -1 ? -1 : 0);
	    		}
	    	}
	    	return null;
	    },
	    
	    /**
	     * Returns the next text node of the given node
	     * 
	     */
	    getNextTextNode: function(node, root){
	    	var pnode = node, tnode;
	    	while(pnode && (pnode.nodeType != 1 || (pnode.tagName.toLowerCase() != "body" && (!root || pnode != root)))){
	    		if (tnode = this.getTextNodeAtPosition(pnode.nextSibling, 0)){
	    			return tnode;
	    		}
	    		pnode = pnode.parentNode;
	    	}
	    	return null;
	    },

	    /**
	     * Returns the previous text node of the given node
	     * 
	     */
	    getPreviousTextNode: function(node, root){
	    	var pnode = node, tnode;
	    	while(pnode && (pnode.nodeType != 1 || (pnode.tagName.toLowerCase() != "body" && (!root || pnode != root)))){
	    		if (tnode = this.getTextNodeAtPosition(pnode.previousSibling, -1)){
	    			return tnode;
	    		}
	    		pnode = pnode.parentNode;
	    	}
	    	return null;
	    },
	    
	    forceSelection: function(){
	    	var selection = this.getSelection(),
	    		range = this.getRange(selection);
	    	
	    	
	    	if (selection && range && this.isSingleCursorSelection(range)){
	    		
		    	var set = function(node, offset){
		    		var startOffset = offset, 
		    			list = node.textContent.match(/([^a-zäöüß0-9]+|[a-zäöüß0-9]+)/ig);
		    		
		    		var word = list.find(function(text){
		    			offset -= text.length;
		    			return (offset < 0) || (offset == 0 && text.trim());
			    	});
		    		
		    		if (word && word.replace(/[^a-zäöüß0-9]+/gi, "")){
		    			
		    			// Get the index of the word
		    			var from = startOffset - word.length - offset,
		    				to = startOffset - word.length - offset + word.length;
		    			
		    			// Set the selection to the word
		    			range.setStart(node, from);
		    			range.setEnd(node, to);
		    			selection.removeAllRanges();
		    			selection.addRange(range);
		    			return true;
		    		}
		    		return false;
	    		};

	    		var offset = range.endOffset,
	    			node = this.getTextNodeAtPosition(range.endContainer, offset);
	    		
	    		if (!node || !set(node, offset)){
	    			if (!node){
	    				if (offset > 0){
	    					node = this.getTextNodeAtPosition(range.endContainer.childNodes[offset-1], -1);
	    				}
	    			} else {
	    				if (offset == 0){
	    					node = this.getPreviousTextNode(node);
	    				} else {
	    					node = this.getNextTextNode(node);
	    				}
	    			}
	    			if (node){
	    				set(node, node.textContent.length);
	    			}
	    		}	    		
	    	}

	    	
	    	
	    },
	     
        /**
         * Due to the fact that chrome will remove lists as it recognizes them
         * as style elements we block this behaviour and parse the range 
         * between l and r ourselves and remove all formatting while still
         * keeping the lists and paragraphs.
         * 
         * @param {DOMNode} l
         * @param {DOMNode} r
         */
	    removeFormatAndPreserveLists: function(l, r) {
	    	if(!l || (l === r && !l.childNodes) ||
	    	   r.nextSibling === l) {
	    		return;
	    	}
	    	
	    	var sibling = l.nextSibling;
	    	var firstChild = l.firstChild;	
	    	var lastChild = l.lastChild;
	    	
	    	if(this.isStyleElement(l)) {	    		
	    		this.removeContainer(l);
	    	}
	    	
	    	if(firstChild) {
	    		this.removeFormatAndPreserveLists(firstChild, lastChild);
	    		return this.removeFormatAndPreserveLists(sibling, r);
	    	}
	    		    	
	    	return this.removeFormatAndPreserveLists(sibling, r);
	    },
	    
	    /**
	     * Removes a container node and moves all of 
	     * its contents one level up in the dom. 
	     * 
	     * @param 	container	The containing node
	     * @param	appendBR	True to append a BR Element after all childNodes
	     * 
	     * @returns	Object		Object containing the parent of the container
	     * 						and all children in an Array
	     */
	    removeContainer: function(container, appendBR) {    	
	    	var parent = container.parentNode;
	    	var br = this.doc.createElement('br');
	    	
	    	if(Ext.isGecko) {
	    		var selection = this.getSelection();
	            
	            // Get the range
	            if (selection.getRangeAt) {
	            	var range = selection.getRangeAt(0);
	            } else {
	            	var range = document.createRange ? document.createRange() : selection.createRange();
	                // Create a range exactly like the user selection
	            	range.setStart(selection.anchorNode, selection.anchorOffset);
	                range.setEnd(selection.focusNode, selection.focusOffset);
	            }
	        
	    		var fragment = range.createContextualFragment(container.innerHTML);
	    		
	    		if(appendBR &&
	    			!this.isBreak(fragment.lastChild) &&
	    			!this.isBreak(container.nextSibling)) {
	    			
	    			fragment.appendChild(br);
	    		}
	    		
	    		parent.replaceChild(fragment, container);
	    		return {
	    			parent: parent,
	    			children: null
	    		};
	    	} else if(Ext.isSafari || Ext.isOpera || Ext.isIE9 || Ext.isIE10) {
	    		// the createContextualFragment command is only supported by Firefox
	    		// PLUS Opera will not fire an erorr because they implemented the method
	    		// but it only return nonsense	    		
	    		
	    		var children = $A(container.childNodes);	    		
	    		var newNodes = [];
	    		
	    		if(Ext.isOpera) {
	    			var sel = this.getSelection();
	    			sel.removeAllRanges();
	    		}
	    		
	    		if(appendBR &&
	    			!this.isBreak(container.nextSibling) &&
	    			!this.isBreak(container.lastChild) &&
	    			!this.isBlockquote(container.lastChild)) {
	    			
	    			children.push(br);
	    		}
	    		
	    		children.reverse().each(function(child) {	    			
	    			newNodes.push(parent.insertBefore(child, container.nextSibling));
	    		}.bind(this));
	    			    			    		
	    		newNodes = $A(newNodes).reverse();
	    			    			    		
	    		parent.removeChild(container);	
	    		return {
	    			parent: parent,
	    			children: newNodes
	    		};
	    	}
	    },	
	    
        /**
         * Creates a selection around all children of a node
         * 
         * @param {DOMNode} node
         * @return {Selection}
         */
	    selectAllChildren: function(node) {
	    	var selection = this.getSelection();
	    	
	    	if(Ext.isGecko || Ext.isSafari || Ext.isIE9 || Ext.isIE10) {
	    		selection.selectAllChildren(node);
	    	} else if(Ext.isOpera) {
	    		// Since Opera does not implement the Selection object correctly
	    		// we utilize some mashup between IE syntax and Opera stuff
	    		// to get a Selection
	    		
	    		if (document.selection && document.selection.createRange) {
	    			var textRange = this.win.document.selection.createRange();
	    			
	    			textRange.moveToElementText(node);
	    			textRange.select();
	    		} else if (window.getSelection) {
	    		    
	                // Get the range
	                if (selection.getRangeAt) {
	                	var range = selection.getRangeAt(0);
	                } else {
	                	var range = document.createRange ? document.createRange() : selection.createRange();
	                    // Create a range exactly like the user selection
	                	range.setStart(selection.anchorNode, selection.anchorOffset);
	                    range.setEnd(selection.focusNode, selection.focusOffset);
	                }
	            
	    			range.setStartBefore(node.firstChild);
	    			range.setEndAfter(node.lastChild);
	    			
	    			selection.removeAllRanges();
	    			selection.addRange(range);
	    		}
	    	}
	    	
	    	return selection;
	    },
	    
	    getAncestor: function(selection, singleCursorSelection) {
	    	if(Ext.isGecko || Ext.isSafari || Ext.isOpera || Ext.isIE9 || Ext.isIE10) {
	            
	            // Get the range
	            if (selection.getRangeAt) {
	            	var range = selection.getRangeAt(0);
	            } else {
	            	var range = document.createRange ? document.createRange() : selection.createRange();
	                // Create a range exactly like the user selection
	            	range.setStart(selection.anchorNode, selection.anchorOffset);
	                range.setEnd(selection.focusNode, selection.focusOffset);
	            }
	        
	    		
	    		if(singleCursorSelection) {
	    			return this.findContainer(range.commonAncestorContainer);
	    		}	    		
	    		
	    		// if text is not formatted then the text node itself is the common
	    		// ancestor. to get the real parent, we have to look up the parent node
	    		// of the text node
	    		if(range.startContainer === range.endContainer && 
	    		   range.commonAncestorContainer === range.startContainer) {
	    			
	    			return range.commonAncestorContainer.parentNode;
	    		} else {
	    			return range.commonAncestorContainer;
	    		}
	    	}
	    	
	    	return null;
	    },
	   
	    findContainer: function(node) {
	    	if(this.isContainer(node) ||
	    	   this.isBody(node)) {
	    		return node;
	    	}
	    	
	    	if(node.parentNode) {
	    		return this.findContainer(node.parentNode);
	    	}
	    	
	    	return null;
	    },	    
	    
	    allChildrenSelected: function(parent) {
	    	var selection = this.getSelection();
	    	
	    	if(selection.rangeCount === 0) {
	    		// nothing selected
	    		return false;
	    	}
	    	
	    	// if the selection range is longer than one
	    	// line headings must be removed even if they are not completely 
	    	// selected -> therefore we stop here and return true
	    	if(this.isMultiLineSelection(selection)) {
	    		return true;
	    	}
	    	
    		if(Ext.isGecko || Ext.isSafari || Ext.isOpera || Ext.isIE9 || Ext.isIE10) {
    			$A(parent.childNodes).each(function(child) {
	    			if(!selection.containsNode(child, false)) {
		    			return false;
		    		}	    			
	    		});
    			
    		    
                // Get the range
                if (selection.getRangeAt) {
                	var range = selection.getRangeAt(0);
                } else {
                	var range = document.createRange ? document.createRange() : selection.createRange();
                    // Create a range exactly like the user selection
                	range.setStart(selection.anchorNode, selection.anchorOffset);
                    range.setEnd(selection.focusNode, selection.focusOffset);
                }
            
    			var textLength = range.commonAncestorContainer.textContent.length;
    			var rangeLength = range.cloneContents().textContent.length;
    			    			    			
    			// |-------RANGE-------|
    			// |___|  |_____|  |___|
    			// all snippets are not the complete text range
    			// thus the container will not be removed	    			
    			if(!(range.startOffset === 0 && textLength === rangeLength)) {
    				return false;
    			}
	    	}
	    	
	    	return true;
	    },
	    
	    getContainers: function() {
	    	
	    	// Collect all possible container tags
	    	var h1 = $A(this.win.document.getElementsByTagName("h1"));
	    	var h2 = $A(this.win.document.getElementsByTagName("h2"));
	    	var h3 = $A(this.win.document.getElementsByTagName("h3"));	    	
	    	
	    	var font = $A(this.win.document.getElementsByTagName("font"));
	    	
	    	var blockQuotes = $A(this.win.document.getElementsByTagName("blockquote"));
	    	
	    	var containers = h1.concat(h2, h3, font, blockQuotes);
	    	
	    	return containers;
	    },   
	    	    
	    selectBetween: function(l,r, excludeLeft, excludeRight) {
	    	if(Ext.isOpera) {
	    		return this.selectBetweenOpera(l, r, excludeLeft, excludeRight);
	    	}
	    	
	    	if(Ext.isSafari){
	    		return this.selectBetweenSafari(l, r, excludeLeft, excludeRight);
	    	}
	    	
	    	var selection = this.getSelection();
	    	
            // Get the range
            if (selection.getRangeAt) {
            	var range = selection.getRangeAt(0);
            } else {
            	var range = document.createRange ? document.createRange() : selection.createRange();
                // Create a range exactly like the user selection
            	range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
            }
            		    	
	    		    	
	    	if(l === r) {
	    		range.selectNodeContents(l);
	    	} else {	    	
		    	if(excludeLeft) {		    		
		    		range.setStart(l,0);
		    	} else {
		    		range.setStart(l,0);
		    	}
		    	
		    	var length = 0;
		    	
				if(this.isTextNode(r)) {
					length = r.textContent.length;
				} else {
					length = $A(r.childNodes).length;
				}
		    	
		    	if(excludeRight) {
		    		range.setEnd(r,0);
		    	} else {
		    		range.setEnd(r,length);		    		
		    	}
	    	}
	    	
	    	selection.removeAllRanges();
	    	selection.addRange(range);
	    	
	    	return {
	    		selection: selection,
	    		range: selection.getRangeAt(0)
	    	};
	    },
	    
	    selectBetweenSafari: function(l, r, excludeLeft, excludeRight){

	    	var selection = this.getSelection(), range;
	    	
	    	if (selection.rangeCount === 0){
		    	range = this.win.document.createRange ? this.win.document.createRange() : selection.createRange(); 
            } else if (selection.getRangeAt) {
                // Get first range
            	range = selection.getRangeAt(0);
            } else {
                // Create a range exactly like the user selection
            	range = this.win.document.createRange ? this.win.document.createRange() : selection.createRange();
            	range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
            }
	    	
	    	if(l === r) {
	    		range.selectNodeContents(l);
	    	} else {	    	
	    		if (excludeLeft){
			    	range.setStartAfter(l);
		    	} else {
			    	range.setStartBefore(l);
		    	}
		    	if (excludeRight){
			    	range.setEndBefore(r);
		    	} else {
			    	range.setEndAfter(r);
		    	}
	    	}
	    	
	    	selection.removeAllRanges();
	    	selection.addRange(range);
	    	
	    	return {
	    		selection: selection,
	    		range: selection.getRangeAt(0)
	    	};
	    	
	    },
	    
	    selectBetweenOpera: function(l, r, excludeLeft, excludeRight) {
	    	var selection = this.getSelection();
            
            // Get the range
            if (selection.getRangeAt) {
            	var range = selection.getRangeAt(0);
            } else {
            	var range = document.createRange ? document.createRange() : selection.createRange();
                // Create a range exactly like the user selection
            	range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
            }
        	    	
	    	if(!l.parentNode || !r.parentNode) {
	    		// opera sometimes does not update references to nodes
	    		// in this case it replaces them with textNodes without
	    		// parent or siblings
	    		// --> we need to stop here in order to avoid errors
	    		return {
	    			selection: selection,
	    			range: selection.getRangeAt(0)
	    		};
	    	}	    	
	    		    	
	    	if(excludeLeft || !l.previousSibling || 
	    		(l.previousSibling && this.isBlockingElement(l.previousSibling))) {
	    		
	    		range.setStart(l,0);
	    	} else {
	    		range.setStartBefore(l);
	    	}
	    	
	    	var length = 0;
	    	
			if(this.isTextNode(r)) {
				length = r.textContent.length;
			} else {
				length = $A(r.childNodes).length;
			}
	    		    	
	    	if(excludeRight) {
	    		range.setEnd(r,length);
	    	} else {
	    		if(!r.nextSibling || 
	    		   this.isBlockingElement(r.nextSibling) ||
	    		   		(r.nextSibling && r.nextSibling.textContent.blank())) {
	    			
	    			// otherwise Opera would create a _NEW_ empty
	    			// Text object that messes up everything   			
	    			range.setEnd(r, length);
	    		} else {
	    			range.setEndAfter(r);
	    		}
		    }	    	
	    	
	    	selection.removeAllRanges();
	    	selection.addRange(range);
	    	
	    	return {
	    		selection: selection,
	    		range: range
	    	};
	    },
        
        /**
         * Handle clicks on the heading buttons.
         * @param {Integer} size The desired size of the heading
         */
	    toggleHeading: function(size) {
	    	var selection = this.getSelection();
            
            // Get the range
            if (selection.getRangeAt) {
            	var range = selection.getRangeAt(0);
            } else {
            	var range = document.createRange ? document.createRange() : selection.createRange();
                // Create a range exactly like the user selection
            	range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
            }
            var ancestor = this.getAncestor(selection, this.isSingleCursorSelection(range));
    		
    		// searches the DOM upwards
    		var heading = this.searchHeading(ancestor);
    		
    		if(heading) { 
    			var node = this.removeContainer(heading, true);    			
    			
    			if(node.children) {
    				// this is kind of a browser switch
    				// the nodes array will only be filled if the client
    				// browses with chrome or opera
    				//
    				// in these browser we need to restore the selection 
    				// after we deleted the old container
    				selection = this.selectBetween(node.children.first(), node.children.last());
    			}
    			
    			// switched to another size for the heading with the 
    			// current heading selected
    			if(heading.nodeName.toLowerCase() !== 'h' + size) {
    	        	this.relayCmd('removeformat');
    				this.createHeading(size, selection);
    			}
    		} else {
            	this.relayCmd('removeformat');
    			this.createHeading(size, selection);
    		}            
	    },
	    
	    toggleCodeBlock: function(size) {
	    	var selection = this.getSelection();
            
            // Get the range
            if (selection.getRangeAt) {
            	var range = selection.getRangeAt(0);
            } else {
            	var range = document.createRange ? document.createRange() : selection.createRange();
                // Create a range exactly like the user selection
            	range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
            }
            var ancestor = this.getAncestor(selection, this.isSingleCursorSelection(range));
    		
    		// searches the DOM upwards
    		var codeBlock = this.searchCodeBlock(ancestor);
    		
    		if(codeBlock) { 
    			var node = this.removeContainer(codeBlock, true);    			
    			
    			if(node.children) {
    				// this is kind of a browser switch
    				// the nodes array will only be filled if the client
    				// browses with chrome or opera
    				//
    				// in these browser we need to restore the selection 
    				// after we deleted the old container
    				selection = this.selectBetween(node.children.first(), node.children.last());
    			}
    		} else {
    			this.createCodeBlock(selection);
    		}            
	    },
	    
	    createCodeBlock : function(selection) {
	    	if (selection && selection.selection && selection.range) {
	    		var range = selection.range;
	    		selection = selection.selection;
	    	} else {
	    		var range;
	    	}
	    	
	    	this.logCmd("formatblock", "BLOCKQUOTE");
	    	this.updateToolbar();
	    },
	    
	    /**
	     * Creates a new Heading from a selected text fragment
	     * @param {Number} size The desired size of the heading
	     * @param {Object} selection The selection
	     * @param {Boolean} modifying
	     * @param bounds
	     */
	    createHeading: function(size, selection, modifying, bounds) {
	    	if (selection && selection.selection && selection.range) {
	    		var range = selection.range;
	    		selection = selection.selection;
	    	} else {
	    		var range;
	    	}
	    	
	    	if (!size) { return;}
	    	
    		// If browser is firefox
    		if(Ext.isGecko) {
    			this.logCmd('heading', '<h' + size + '>');
    		} else {
    			if (!selection) {
    				/*
    				 * To get the right selection, we have to ensure
    				 * that the window has focus
    				 */
    				this.win.focus();
    				selection = this.getSelection(); 
    			}
    			
				// Get the range
    			if (!range) {
        			if (selection.getRangeAt) {
                    	range = selection.getRangeAt(0);
                    } else {
                    	range = document.createRange ? document.createRange() : selection.createRange();
                        // Create a range exactly like the user selection
                    	range.setStart(selection.anchorNode, selection.anchorOffset);
                        range.setEnd(selection.focusNode, selection.focusOffset);
                    }
    			}

    			var commonAncestor = range.commonAncestorContainer;

    			if(!bounds) {
	    			if(!this.isSingleCursorSelection(range)) {
	    				var start = range.startContainer, end = range.endContainer;
	    				if (start.nodeType == 1 && start.childNodes[Math.max(range.startOffset-1, 0)]){
	    					start = start.childNodes[Math.max(range.startOffset-1, 0)];
	    				}
	    				var bounds = this.findHighestSiblings(start, start);	    				
	    			} else {
	    				if (commonAncestor.nodeType == 1 && commonAncestor.childNodes[Math.max(range.startOffset-1, 0)]){
	    					commonAncestor = commonAncestor.childNodes[Math.max(range.startOffset-1, 0)];
	    				}
	    				var bounds = {
    						left	: commonAncestor,
    						right	: commonAncestor
	    				};
	    			}
	    			
	    			// the current bounds only referr to the selected elements
	    			// the paragraph itself might have its bounds in a higher
	    			// node of the dom tree
	    			bounds = this.computeHighestBounds(bounds);	    			
    			}	    			
					    			
				var container = bounds.left.parentNode;
				
				// remove all headings that currently exist inside the selection
				this.removeHeadings(bounds.left, bounds.right, bounds);
				
				// search for headings in higher nodes
				// if the contents are already surrounded with a h-tag
				// the existing h-tag will be replaced with the one
				// chosen now
				var heading = this.searchHeading(container);
				// The new heading
				var h = this.doc.createElement('h' + size);	    			
    			
				if(heading) {   					
					if(!modifying) {
						// this is a standard call from the ui
						this.selectAllChildren(heading);       						
						
						// Replace the old heading with the new one
						heading.parentNode.replaceChild(h, heading);
						// Append the old contents
						h.appendChild(range.extractContents());
					} else {
						// some routine is calling
						this.removeContainer(heading);     						
						this.appendHeading(h, size, bounds);
					}    					
				} else if(!this.isNotEditable(container)){
					if(this.isList(container)) {
						this.transformListElements(container.childNodes, size, false, bounds.left, bounds.right);
					} else {	  
						this.appendHeading(h, size, bounds);
					}
				}
			
				if(!bounds.right.namespaceURI || !bounds.left.namespaceURI) {
					// wrong reference outside the document
					// -> get some selection to collapse
					// TODO: this can be done better
					selection.selection = this.getSelection();
				} else {
					selection = this.selectBetween(bounds.left, bounds.right);
				}
				
				// to get the same look and feel and due to a bug in
				// opera where the new selection would contain a false
				// text node after the heading the selection is collapsed
				// to the end.
				//
				// now switching between headings is also enabled due
				// to the possibility of singleCursorSelection.
				selection.selection.collapseToEnd();
				
				this.win.focus();
    		}
    		this.updateToolbar();
	    },
	    
	    /**
	     * This method will create a new heading around a selection
	     * of the size bounds.left -> bounds.right. All elements
	     * that are falsely turned into heading elements will be
	     * restored.
	     * 
	     * @param {DOMNode} h The new heading element
	     * @param {Integer} size The size of the new heading
	     * @param {Object} bounds The bounds of the selection
	     */
	    appendHeading: function(h, size, bounds) {
	    	this.selectBetween(bounds.left, bounds.right);					
			
			this.surroundContents(h, Object.clone(bounds));	    						    					
			this.removeFalseBR(h);
			this.removeEmptyLists(h);

			// sometimes text is placed in div-tags to emulate br
			// but divs in h-tags tell the editor to continue in h
			// even after the user has pushed enter
			// --> we remove the div-tags and replace them with br
			// this preserves the layout and does not influence the
			// editing
			this.selectAllChildren(h);
			this.removeDirt(h, true);			
			
			// we might have surrounded list items with the h tag
			this.restoreBlockElements(h, size, h.firstChild, h.lastChild);
			//this.restoreLists(h, size, h.firstChild, h.lastChild);
			//this.restoreParagraphs(h, size, h.firstChild, h.lastChild);
	    },
	    
	    /**
	     * Surround all elements that live between bounds.left and
	     * bounds.right with a new container.
	     * 
	     * @param	{DOMNode}    container	The container to surround the elements
	     * @param	{Object}     bounds		Left and right border
	     */
	    surroundContents: function(container, bounds) {
	    	var nextSibling = bounds.right.nextSibling;
	    	var parent = bounds.left.parentNode;
	    	
	    	var left = bounds.left, right;
	    	
	    	while(left && left !== nextSibling) {
	    		if(left) {	    				    			
		    		var sibling = left.nextSibling;
		    		
		    		container.appendChild(left);	    		
		    		
		    		left = sibling;	    			
	    		}
	    	}
	    		    	
	    	if(nextSibling) {
	    		parent.insertBefore(container, nextSibling);
	    	} else {
	    		parent.appendChild(container);
	    		
	    		// fixing bounds object
				if(left === bounds.right) {
					bounds.left = bounds.right = container;
				}
	    	}	    	
	    },
	    
	    /**
    	* when contents are extracted from a 
    	* list it might occur that an empty list object
    	* remains after the h tag. this object is
    	* now being removed.
    	* 
    	* @param 	{DOMNode}    node	The H Element
      	**/
	    removeEmptyLists: function(node) {
	    	if(node.nextSibling && this.isList(node.nextSibling)) {
	    		if(this.isEmpty(node.nextSibling)) {
	    			node.parentNode.removeChild(node.nextSibling);
	    		}
	    	}
	    },
	    
	    /**
	     * Restores block elements e.g. text nodes.
	     * @param container The parent container
	     * @param size The size of a heading to create
	     * @param leftBounds the left boundaries
	     * @param rightBounds the right boundaries
	     */
	    restoreBlockElements: function(container, size, leftBounds, rightBounds) {
	    	var foundBlock = false;
	    	var children = $A(container.childNodes);
	    	var parent = container.parentNode;
	    	
	    	children.each(function(child) {
	    		if(!foundBlock && (this.isBlockquote(child) || this.isList(child) || this.isHorizontalRule(child))) {
	    			foundBlock = true;
	    			var selection;
	    			
	    			// change h tag to close before block
	    			if(children.indexOf(leftBounds) < children.indexOf(child)) {
	    				var modLeft = true;
	    				
	    				selection = this.selectBetween(leftBounds, child.previousSibling, false, true);
	    				
	    				if(!this.isSingleCursorSelection(selection.range)) {
	    					// maybe an empty text node has been selected. this would result
	        				// in singleCursorSelection and thus the createheading method
	        				// would seaech for new boundaries. These new boundaries would
	        				// then include nodes that are not intended to be turned into 
	        				// headings
	    					this.createHeading(size, selection, true, {
	    						left: leftBounds,
	    						right: child.previousSibling
	    					});
	    				}
	    			}
	    			
	    			// change h tag to start after list
	    			if(children.indexOf(rightBounds) > children.indexOf(child)) {
	    				var modRight = true;
	    				
	    				selection = this.selectBetween(child.nextSibling, rightBounds, true, false);
	    				
	    				if(!this.isSingleCursorSelection(selection.range)) {
	    					// for explanation see above
	    					this.createHeading(size, selection, true, {
	    						left: child.nextSibling,
	    						right: rightBounds
	    					});
	    				}
	    			}
	    			
	    			if(modRight || modLeft) {
	    				if(this.isList(child)) {
	    					// now transform all list elements
							this.transformListElements(child.childNodes, size, true);
	    				} else if(this.isBlockquote(child)) {
	    					// blockquotes can also contain regular text PLUS
	    					// other blockquotes, though we parse them
	    					selection = this.selectBetween(child, child);
		    				
		    				if(!this.isSingleCursorSelection(selection.range)) {
		    					this.transformBlockElements(child.childNodes, size, true);
		    				}
	    				} 
	    			}
	    		}
	    	}.bind(this));
	    },
	    
	    /**
	     * This searches for the highest dimensions of a heading.
	     * It stops when the body is reached or if there a tags that
	     * block a heading such as br, div or other headings.
	     * 
	     * @param	{Object}    bounds		Object containing the current left
	     * 						            and right boundaries.
	     * 
	     * @return  {Object}				And object with the highest dimenstions
	     */
	    computeHighestBounds: function(bounds) {
	    	var leftBoundary = this.findBoundary(bounds.left, 'left');
	    	var rightBoundary = this.findBoundary(bounds.right, 'right');
	    	
	    	if(!leftBoundary.previousSibling && 
	    	   !rightBoundary.nextSibling && 
               !(this.isNotEditable(leftBoundary) || this.isNotEditable(rightBoundary)) &&
	    	   !this.isBlockingElement(leftBoundary.parentNode)	&& 
	    	   !this.isBlockingElement(leftBoundary) &&
	    	   !this.isBlockingElement(rightBoundary) &&
	    	   !this.isBody(leftBoundary.parentNode) &&
	    	   !this.isBody(leftBoundary) &&
	    	   !this.isBody(rightBoundary)) {
	    		
	    		return this.computeHighestBounds({
	    			left: leftBoundary.parentNode,
	    			right: leftBoundary.parentNode
	    		});
	    	}	    	
	    	
    		return {
    			left: leftBoundary,
    			right: rightBoundary
    		};
	    },
	    
	    /**
	     * Removes div and p elements inside an Element.
	     * This is useful to prevent breaklines in an
	     * h element for example.
	     * 
	     * @param	{DOMNode}    el			The element the will be looked through
	     * @param	{Boolean}    forceBR	whether a br tag shall be included after
	     * 						            the end of the old node
	     */
	    removeDirt: function(el, forceBR) {
	    	$A(el.childNodes).each(function(node) {
	    		if(node.childNodes) {		    			
	    			this.removeDirt(node);	    			
	    		}
	    		
		    	if(this.isDirt(node)) {		    		
		    		this.removeContainer(node, forceBR);
		    	}
	    	}.bind(this));
	    },
	    
	    /**
	     * Looks up blockquote elements and turns their contents into 
	     * headings of the specified size
	     * 
	     * @param	{NodeList}   nodes			NodeList of nodes to look up
	     * @param 	{Integer}    size			Size of the heading that will be created
	     * @param	{Boolean}    force			I have no idea
	     * @param	{DOMNode}    leftBoundary	OPTIONAL: possible starting point in NodeList
	     * @param	{DOMNode}    rightBoundary	OPTIONAL: possible end point in NodeList
	     */
	    transformBlockElements: function(nodes, size, force, leftBoundary, rightBoundary) {
	    	var nodes = $A(nodes);
	    	
	    	nodes.each(function(node) {
	    		if((nodes.indexOf(node) < nodes.indexOf(leftBoundary) || 
	    		   nodes.indexOf(node) > nodes.indexOf(rightBoundary)) && 
	    		   !force){
	    			
	    			return;
	    		}
	    		
	    		if(this.isBlockquote(node)) {
	    			this.transformBlockElements(node.childNodes || [], size, true);
	    		} else {	    			
	    			var h = this.doc.createElement('h' + size);
	    			
	    			this.appendHeading(h, size, {
	    				left: node,
	    				right: node
	    			});  			
	    		}
	    	}.bind(this));
	    },
	    
	    /**
	     * Transforms the content of list-items into heading elements
	     * of the specified size.
	     * 
	     * @param	{NodeList}   nodes			NodeList of nodes to look up
	     * @param	{Integer}    size			Size of the heading that will be created
	     * @param	{Boolean}    force			No idea...
	     * @param	{DOMNode}    leftBoundary	OPTIONAL: possible starting point in NodeList
	     * @param	{DOMNode}    rightBoundary	OPTIONAL: possible end point in NodeList
	     */
	    transformListElements: function(nodes, size, force, leftBoundary, rightBoundary) {
	    	var nodes = $A(nodes);
	    	
	    	nodes.each(function(node) {
	    		if((nodes.indexOf(node) < nodes.indexOf(leftBoundary) || 
	    		   nodes.indexOf(node) > nodes.indexOf(rightBoundary)) && 
	    		   !force){
	    			
	    			return;
	    		}
	    		
	    		if(this.isList(node)) {
	    			this.transformListElements(node.childNodes || [], elementName, true);
	    		} else {	    			
	    			var h = this.doc.createElement('h' + size)
	    			
	    			this.surroundContents(h, {
	    				left: node.firstChild,
	    				right: node.lastChild
	    			});	    		
	    			 			
	    		}
	    	}.bind(this));
	    },	  
	    
	    /**
	     * When creating headings existing br elements that follow
	     * the h element have to be removed because a h tag itself 
	     * forces a linebreak. 
	     * 
	     * The other use case is that empty Elements that are created
	     * by opera will be removed because they would destroy the
	     * layout
	     * 
	     * @param	{DOMNode}    el		The Element to look though
	     */
	    removeFalseBR: function(el) {
	    	if(Ext.isOpera) {
	    		// opera adds some empty non-standard text
				// objects after the newly created h element
				// these force line-breaks that change the layout
				// thus we remove them
	    		if(el.nextSibling && el.nextSibling.textContent.blank()) {	    			
	    			el.parentNode.removeChild(el.nextSibling);
	    		}
	    	} 
	    	
	    	// A H Element forces a newline and thus an existing BR
	    	// has to be removed	    	
	    	if(this.isHeading(el)) {
		    	if(this.isBreak(el.nextSibling)) {
		    		el.parentNode.removeChild(el.nextSibling);
		    	} else if(this.isBreak(el.lastChild)) {
		    		el.removeChild(el.lastChild);
		    	}
		    	
		    	// move all other BRs to the outside of the H
		    	// Element
		    	this.moveBR(el);
	    	}	    	
	    },
	    
	    /**
	     * Moves all br elements at the end and at the end of an element
	     * outside the element.
	     * 
	     * @param 	{DOMNode}    el		The element to look through
	     */
	    moveBR: function(el) {
	    	while(this.isBreak(el.firstChild)) {
	    		el.parentNode.insertBefore(el.firstChild, el);
	    	}
	    	
	    	while(this.isBreak(el.lastChild)) {	    		
	    		if(el.nextSibling) {
	    			el.parentNode.insertBefore(el.lastChild, el.nextSibling);
	    		} else {
	    			el.parentNode.appendChild(el.lastChild);
	    		}
	    	}
	    },
	    
	    searchCodeBlock : function(node) {
	    	if (this.isCodeBlock(node)) {
	    		return node;
	    	}
	    	
	    	if (!node) return null;
	    	
	    	if (node.parentNode && !this.isBody(node)) {
	    		return this.searchCodeBlock(node.parentNode);
	    	}
	    	
	    	return null;
	    },
	    
	    /**
	     * Searches for headings in all higher dom nodes of node.
	     * 
	     * @param	{DOMNode}    node	Starting point of the search
	     * 
	     * @return  {DOMNode}    		A h element if one was found, null otherwise
	     */
	    searchHeading: function(node) {    	
	    	if(this.isHeading(node)) {
	    		return node;
	    	}
	    	
	    	if (!node) {
	    		return null;
	    	}
	    	
	    	
	    	if(node.parentNode && !this.isBody(node)) {
	    		return this.searchHeading(node.parentNode);
	    	}	    
	    	
	    	return null;
	    },
	    
	    /**
	     * Looks for the outermost non-blocking element on the same
	     * dom level as start. 
	     * 
	     * @param	{DOMNode}   start		The node to start the search
	     * @param	{String}    direction	Direction of the search
	     */
	    findBoundary: function(start, direction) {
	    	if(direction === 'left') {
	    		var sibling = start.previousSibling;	    		
	    	} else {
	    		var sibling = start.nextSibling;
	    	}
	    	
            if(sibling) {    			
    			if(this.isBlockingElement(start) || this.isBlockingElement(sibling)) {
    				return start;
    			} else {
    				return this.findBoundary(sibling, direction);
    			}
    		}

	    	return start;
	    },
		   
	    /**
	     * Removes all h elements between the borders l and r.
	     * 
	     * @param	{DOMNode}   l		Left border
	     * @param	{DOMNode}   r		Right border
	     * @param	{Object}    bounds	OPTIONAL: bounds object that will be updated
	     * @param	{Boolean}   jump	PRIVATE: Is used to indicate that the next node
	     * 					            of the higher level shall be looked up. You should not 
	     * 					            set this by yourself.
	     * 
	     * @return  {Boolean}			true if r has been reached, false otherwise
	     */
	    removeHeadings: function(l, r, bounds, jump) {
	    	if(!l || (l === r && !l.firstChild) ||
	    		r.nextSibling === l) {
	    		// while parsing containers it is possible
	    		// that l runs over r. the last condition
	    		// checks for that and prevents further removal
	    		// of headings
	    		return true;
	    	}
	    	
	    	var sibling = l.nextSibling;
	    	var parent = l.parentNode;
	    	var contained = this.contains(l, r);
	    	var isBody = this.isBody(parent);
	    	var stop = false;
	    	
	    	if(this.isHeading(l)) {
	    		if(bounds) {
		    		// if the bounds start or end in a heading
		    		// and we then remove these headings we render
		    		// the bounds object useless, thus we have to 
		    		// update the references to the first/last child 
		    		// of the heading because these are the new 
		    		// outermost elements after the heading is removed
		    		// from the dom
		    		if(l !== r && bounds.left === l) {
		    			bounds.left = l.firstChild;
		    		} else if(l === r && bounds.right === r) {
		    			bounds.right = r.lastChild;
		    		}
	    		}
	    		
	    		this.removeContainer(l, !this.isListItem(parent));
	    	} else if(l.firstChild && !jump) {
	    		stop = this.removeHeadings(l.firstChild, r, bounds, false);
	    		
	    		if(stop || contained) {
	    			return true;
	    		}
	    		
	    		return this.removeHeadings(sibling, r, bounds, false);
	    	} 
	    	
	    	if(contained) {
	    		return true;
	    	}
	    	
	    	if(!sibling && !isBody) {
	    		return this.removeHeadings(parent, r, bounds, true);
	    	}

	    	return this.removeHeadings(sibling, r, bounds, false);

	    },
	    
	    /**
	     * Checks if one Element is contained in another one.
	     * 
	     * @param	{DOMNode}    container	The element that might contain the other
	     * @param	{DOMNode}    el			The possibly contained element
	     * 
	     * @return  {Boolean}				true if the element is contained,
	     * 						            false otherwise
	     */
	    contains: function(container, el) {
	    	if(container === el) {
	    		return true;
	    	}
	    	
	    	var children = $A(container.childNodes);	    	
	    	
	    	if(children.indexOf(el) !== -1) {
	    		return true;
	    	}
	    	
	    	var isChild = false;
	    	
	    	children.each(function(child) {
	    		if(isChild) {
	    			return;
	    		}
	    		
	    		isChild = this.contains(child, el);	    		
	    	}.bind(this));
	    	
	    	return isChild;
	    },
	    	
	    /**
	     * Calculates the depth of an element inside the dom tree.
	     * 
	     * @param	{DOMNode}    node	The node inside the tree
	     * @param 	{Integer}    count	PRIVATE: This stores the depth
	     * 
	     * @return	{Integer}    		The depth as an integer
	     */
	    getDepth: function(node, count) {
	    	if(node.parentNode) {
	    		return this.getDepth(node.parentNode, (count || 0) + 1);
	    	}
	    	
	    	return count || 0;
	    },
	    
	    /**
	     * Finds the highest parents of two nodes in the dom tree that
	     * are siblings.
	     * 
	     * @param	{DOMNode}    start	
	     * @param	{DOMNode}    end
	     * @param	{Integer}    depthStart	PRIVATE: used inside the method, do not set
	     * @param 	{Integer}    depthEnd	PRIVATE: used inside the method, do not set
	     * 
	     * @return	{Object}	    		An object containing the ancestors of the nodes
	     * 						            that are also divided into left and right.
	     */
	    findHighestSiblings: function(start, end, depthStart, depthEnd) {	    	
	    	
	    	// first we need to check which node is deeper in the tree  	    	
	    	if(!depthStart) {
	    		depthStart = this.getDepth(start);
	    	}
	    	
	    	if(!depthEnd) {
	    		depthEnd = this.getDepth(end);
	    	}
	    	
	    	if(depthStart > depthEnd && start.parentNode) {
	    		// start is deeper in the tree
	    		// -> we check whether the parent of start has the same depth as end
	    		return this.findHighestSiblings(start.parentNode, end, undefined, depthEnd);
	    	} else if (depthStart < depthEnd && end.parentNode) {
	    		// end is deeper in the tree
	    		// -> we check whether the parent of end has the same depth as start
	    		return this.findHighestSiblings(start, end.parentNode, depthStart);
	    	} else {	    
	    		// both nodes have the same depth but are wrapped in containers
	    		if(start.parentNode && end.parentNode && 
	    		   start.parentNode !== end.parentNode) {    			
	    			
	    			var gpStart = start.parentNode.parentNode;
	    			var children = $A(gpStart.childNodes);
	    			
	    			if(gpStart) {
	    				if(children.indexOf(end.parentNode) === -1) {
	    					// the wrapping can be multilevel
	    					return this.findHighestSiblings(start.parentNode, end.parentNode, depthStart, depthEnd);
	    				}	    			
	    				
	    				// now we have the same parent and determine which of the elements 
	    				// is the left and which is the right one
	    				// we need this for the previousSibling-/ nextSibling-search
	    				if(children.indexOf(start.parentNode) < children.indexOf(end.parentNode)) {    					
	    					return {
	    						left: start.parentNode,
	    						right: end.parentNode
	    					};
	    				} else {
	    					return {
	    						left: end.parentNode,
	    						right: start.parentNode
	    					};
	    				}
	    			}	    			
	    		}
	    		
	    		var sParent = start.parentNode;   	
	    		var children = $A(sParent.childNodes);
	    		
	    		if(children.indexOf(start) < children.indexOf(end)) {
	    			return {
	    				left: start,
	    				right: end
	    			};
	    		} else {
	    			return {
	    				left: end,
	    				right: start
	    			};
	    		}
	    	}
	    },	    
	    
	    createFontSizeOptions: function() {
	    	var buf = [];
	    	
	    	 this.defaultFontSizes.each(function(fs) {
	    		 buf.push(
	    			'<option value="' + fs[0] + 'pt" ',
	    				(this.defaultFontSize === fs[0] ? 'selected="true">' : '>'),
	    				fs[1],
	    			'</option>');
	    	 }.bind(this));
	    	 
	    	 return buf.join('');
	    },
	    
	    getSelection: function() {
	    	// Mozilla
			if (this.win.getSelection) {
				return this.win.getSelection();
			}
			
			// Safari + Chrome
			if (this.win.document.getSelection) {
				return this.win.document.getSelection();
			} 
			
			// IE
			if (this.win.document.selection) {
				return this.win.document.selection;//.createRange().text;
			}
	    },
	    
	    isHeading: function(node) {
	    	return node ? ['h1', 'h2', 'h3'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
	    },
	    
	    isCodeBlock: function(node) {
	    	return node ? ['blockquote'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
	    },
	    
	    isList: function(node) {
	    	return node ? ['ul', 'ol'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
	    },
	    
	    isLink: function(node) {
	    	return node ? node.nodeName.toLowerCase() === 'a' : false;
	    },
	    
	    isBody: function(node) {
	    	return node ? node.nodeName.toLowerCase() ===  'body' : false;
	    },
	    
	    isBreak: function(node) {
	    	return node ? node.nodeName.toLowerCase() === 'br' : false;
	    },
	    
	    isBlockingElement: function(node) {
	    	return node ? ['ul', 'ol', 'li', 'h1', 'h2', 'h3', 'div', 'br', 'p', 'blockquote'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
	    },
	    
	    isListItem: function(node) {
	    	return node ? node.nodeName.toLowerCase() === 'li' : false;
	    },
	    
	    isTextNode: function(node) {
	    	return node ? node.nodeType === 3 : false;
	    },
	    
	    isStyleElement: function(node) {
	    	return node ? ['b', 'i', 'u', 'font', 'span'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
	    },
        
        isNotEditable: function(node) {
            return node ? ['head', 'html'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
        },
	    
	    isDirt: function(node) {
	    	return node ? ['div', 'p'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
	    },
	    
	    isBlockquote: function(node) {
	    	return node ? ['blockquote'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
	    },
        
        isHorizontalRule: function(node) {
            return node ? node.nodeName.toLowerCase() === 'hr' : false;  
        },
	    
	    isContainer: function(node) {
	    	var containers = this.getContainers()
	    	
	    	if(containers.indexOf(node) === -1) {
	    		return false;
	    	}
	    	
	    	return true;
	    },
	    
	    /**
	     * Checks whether a selection is collapsed or
	     * not. Normally this is also possible via the
	     * _collapsed_ attribute of the Selection object. 
	     * But this seems to be not implemented corretly 
	     * in all browsers.
	     * 
	     * @param	{Range}    range	The Range object of a selection
	     * @returns	{Boolean}    		True if the selection is collapsed,
	     * 					            false otherwise
	     */
	    isSingleCursorSelection: function(range) {
	    	var selection = this.getSelection();
	    	
	    	return range && selection 
	    			&& selection.rangeCount == 1
	    			&& selection.toString().length == 0
	    			&& range.startContainer === range.endContainer
	    			&& range.startOffset === range.endOffset;
	    	
	    },
	    
	    isMultiLineSelection: function(selection) {
	    	var ancestor = this.getAncestor(selection);
	    	var blockingCount = 0;	    	
	    	
	    	$A(ancestor.childNodes).each(function(node) {
	    		if(this.isBlockingElement(node)) {
	    			blockingCount++;	    			
	    		}
	    	}.bind(this));
	    	
	    	if(blockingCount > 1) {
	    		return true;
	    	}
	    	
	    	return false;
	    },
	    
	    /**
	     * Checks whether a given list contains no content. 
	     * This is useful because sometimes empty lists remain
	     * after an heading has been created. 
	     * 
	     * @param 	{DOMNode}    list	List-Element (OL/ UL)
	     * @return	{Boolean}    		True if the list is empty, false otherwise 	
	     */
	    isEmpty: function(list) {
	    	var isEmpty = true;
	    	
	    	$A(list.childNodes).each(function(li) {
	    		if(this.isList(li)) {
	    			isEmpty = this.isEmpty(li);
	    		}
	    		
                // only continue if the list is still empty
                if (isEmtpy) {
                    if (li.childNodes) {
                        $A(li.childNodes).each(function(child) {
                            if (this.isHeading(child) ||
                            !child.textContent.blank()) {
                            
                                isEmpty = false;
                            }
                        }.bind(this));
                    }
                }
	    	}.bind(this));
	    	
	    	return isEmpty;
	    },
	    
	    /**
	     * 
	     * @overwrite
	     * @param text
	     */
	    insertAtCursor : function(text){
	        if(!this.activated){
	            return;
	        }
	        if(Ext.isIE){
	            this.win.focus();
	            var r = this.doc.selection.createRange();
	            if(r){
	                r.collapse(true);
	                r.pasteHTML(text);
	                this.syncValue();
	                this.deferFocus();
	            }
	        }else if(Ext.isGecko || Ext.isOpera){
	            this.win.focus();
	            this.execCmd('InsertHTML', text);
	            this.deferFocus();
	        }else if(Ext.isSafari){
	            this.execCmd('InsertHTML', text);
	            this.deferFocus();
	        }
	    }
	});	 
    
    // Create an Richtext Textarea
    Ext.ux.form.RichTextArea = function() {
        Ext.ux.form.RichTextArea.superclass.constructor.apply(this, arguments);
    };
    
    Ext.extend(Ext.ux.form.RichTextArea, Ext.form.TextArea);
    Ext.extend(Ext.ux.form.RichTextArea, Ext.ux.form.RichtextEditor, {
        onRender: function() {
            Ext.ux.form.RichTextArea.superclass.onRender.apply(this, arguments);
            
            this.wrap.setStyle({
                marginLeft: this.x + "px",
                marginTop: this.y + "px"
            });
        }
    });  
    
    // Create and Richtext Glossary Field
    Ext.ux.form.RichtextGlossary = function() {
        Ext.ux.form.RichtextGlossary.superclass.constructor.apply(this, arguments);
    };    
    
    Ext.extend(Ext.ux.form.RichtextGlossary, Ext.ux.form.GlossaryField);
    Ext.extend(Ext.ux.form.RichtextGlossary, Ext.ux.form.RichtextEditor);
  
        
    /**
     * Command object for the RichtextEditor
     * @class
     * 
     * @param {Object} context
     * @param {Object} conf
     */
    Ext.ux.Command = function(context, conf) {
        this.context = context;
        this.body = this.context.body;
        this.oldHTML = conf.oldHTML;
        this.oldBreadcrump = conf.oldBreadcrump;
        this.oldOffset = conf.oldOffset;
        this.newHTML = conf.newHTML;
        this.newBreadcrump = conf.newBreadcrump;
        this.newOffset = conf.newOffset;
                
        var moveCursor = function(breadcrump, offset) {
            var start = this.body;
            
            breadcrump.each(function(index) {
                start = start.childNodes[index] || start;
            });
            
            // Get the selection
            var selection = this.context.getSelection();
            
            // Get the range
            if (selection.getRangeAt) {
            	var range = selection.getRangeAt(0);
            } else {
            	var range = document.createRange ? document.createRange() : selection.createRange();
                // Create a range exactly like the user selection
            	range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
            }

            if (!range) {return;}
            
            selection.removeAllRanges();
            selection.addRange(range);   
            // If the current 'start' node is not a text node, collapse to 0
            selection.collapse(start, Math.min(start.length || 0, offset));
        };
        
        this.execute = function() {
            if (this.body.innerHTML === this.newHTML) return;
            
        	this.body.innerHTML = this.newHTML;
            
            // TODO
            // Vom Command aus die Umgebung beeinflussen ist irgendwie
            // nich wirklich schön gelöst. Vllt kann man das noch gut 
            // refactoren. 
            this.context.oldHTML = this.newHTML;
            this.context.oldOffset = this.newOffset;
            this.context.oldBreadcrump = this.newBreadcrump;
            
            moveCursor.call(this, this.newBreadcrump, this.newOffset);                  
        };
        
        this.rollback = function() {
        	if (this.body.innerHTML === this.oldHTML) return;
        	
        	this.body.innerHTML = this.oldHTML;
            
            this.context.oldHTML = this.oldHTML;
            this.context.oldOffset = this.oldOffset;
            this.context.oldBreadcrump = this.oldBreadcrump;
                        
            moveCursor.call(this, this.oldBreadcrump, this.oldOffset);
        };                
    };
}();
ns("ux.form");

(function() {

	Signavio.ux.form.Spacer = function(attrs) {
		attrs = attrs || {};

		attrs.cls = "x-form-spacer";

		Signavio.ux.form.Spacer.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.form.Spacer, Ext.form.Label);

}());
/** 
 *  (c) 2013 Signavio GmbH
 *   
 *  @author Thomas Zimmermann
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.form){ Ext.ux.form = {} }

new function(){
	
	Ext.ux.form.TextAreaGrowing = function(attr) {
		
		/* Default attributes present in  Ext.form.TextArea */
		attr.growPad = Signavio.Config.GROWING_TEXT_AREA.VERTICAL_PADDING;
    	attr.growPadHorizontal = Signavio.Config.GROWING_TEXT_AREA.HORIZONTAL_PADDING;
    	attr.growMax = Signavio.Config.GROWING_TEXT_AREA.GROW_MAX;
    	attr.growMin = Math.max(attr.growMin || 0);
    	attr.growMinHorizontal = Math.max(attr.growMinHorizontal || 0);

    	/* Custom attributes */
    	this.growAppend = Signavio.Config.GROWING_TEXT_AREA.GROW_APPEND;
    	
    	/* TextArea's property to set overflow to hidden */
    	attr.preventScrollbars = true;
    	
		
		Ext.ux.form.TextAreaGrowing.superclass.constructor.call(this, attr);
	};

	Ext.extend(Ext.ux.form.TextAreaGrowing, Ext.form.TextArea, {
		
        /**
         * Automatically grows the field to accomodate the height of the text up to the maximum field height allowed.
         * This only takes effect if grow = true, and fires the autosize event if the height changes.
         */
        autoSize : function(){
            if(!this.grow || !this.textSizeEl){
                return;
            }
            var el = this.el;
            var v = el.dom.value;
            var ts = this.textSizeEl;
            if (!ts||!el){ return }
            ts.innerHTML = '';
            ts.appendChild(document.createTextNode(v));
            v = ts.innerHTML;

            if (!this.growHorizontally) {
	            try {
	            	Ext.fly(ts).setWidth(this.el.getWidth());
	            } catch(e) { }
            }
            
            if(v.length < 1){
                v = "&#160;&#160;";
            }else{
                if(Ext.isIE){
                    //v = v.replace(/\n/g, '<p>&#160;</p>');
                }
                v += this.growAppend;
            }
            ts.innerHTML = v;
            var h = Math.min(this.growMax, Math.max(ts.offsetHeight + this.growPad, this.growMin));
            if(h != this.lastHeight){
                this.lastHeight = h;
                this.el.setHeight(h);
                this.fireEvent("autosize", this, h);
                if (this.list) {
                	this.list.alignTo(this.el, this.listAlign);
                }
            }
            
            if (this.growHorizontally) {
                var w = Math.min(this.growMax, Math.max(ts.offsetWidth + this.growPadHorizontal, this.growMinHorizontal));
                if(w != this.lastWidth){
                    this.lastWidth = w;
                    this.el.setWidth(w);
                    if (this.list) {
                    	this.list.alignTo(this.el, this.listAlign);
                    }
                }
            }
        }
	});
	
}();/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *
 *	This code is proprietary software within the 
 * 	company Signavio GmbH.
 *  
 */

new function(){

	/**
	 * BUGFIX for IE7:
	 * ExtJS 2.0.2 doesn't remove multilined emptytext on click, because ie7 recognizes a newline in
	 * the DOM as '\n\r'. Comparison of emptytext with the current content of the DOM node returns
	 * always false, because the predefined emptytext only contains '\n'. Firefox and Safari don't
	 * have this bug. 
	 */
	Ext.override(Ext.form.TextField, {
		preFocus: function(){
			var el = this.el;
			if (this.emptyText) {
				if (this.emptyText.sub("\n", "").sub("\r", "") == el.dom.value.sub("\n", "").sub("\r", "")) {
					this.setRawValue('');
				}
				el.removeClass(this.emptyClass);
			}
			if (this.selectOnFocus) {
				el.dom.select();
			}
		}
	})
};/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.form){ Ext.ux.form = {} }

(function(){
	
	Ext.ux.form.TextFieldList = function(attr){
		
		attr.listeners = Ext.apply({}, {
			specialkey: function(t, e){
				if (e.getKey() === e.ENTER) {
					t.onTriggerClick();
				} else if (e.getKey() === e.ESC) {
					t.stopEdit();
				}
			}
		}, attr.listeners||{})
		
		Ext.ux.form.TextFieldList.superclass.constructor.apply(this, [attr])
	}
	
	Ext.extend(Ext.ux.form.TextFieldList, Ext.form.TriggerField, {
		triggerClass: "x-form-add-trigger",
		ctCls : "x-form-textfield-list",
		listStyle : '',
		emptyListText: '',
		viewEntry: "{[Signavio.Utils.escapeHTML(values)]}",
		enableEmptyAdd: true,
		data: [],
		showSequenceLinks: true,
		onTriggerClick: function(){
			var index = this.editing !== undefined ? this.editing : this.data.length;
			
			var value = this.getRawValue();
			if (!this.enableEmptyAdd&&!value){
				return;
			}
			
			if (this.editing !== undefined) {
				var oldValue = this.data[this.editing];
				this.data[this.editing] = value;
				this.stopEdit();
				if (this.onEdit instanceof Function){
					this.onEdit(index,oldValue,value);
				}
			}
			else {
				var oldData = (this.data instanceof Array) ? this.data.clone() : [];
				this.data.push(value);
				if (this.onAdd instanceof Function){
					this.onAdd(value,oldData);
				}			
				if (Ext.fly(this.container)){Ext.fly(this.container).removeClass("x-empty-textfield-list");}
			}
			this.setRawValue("");
			this.updateView();
			
			var ni = (this.itemField.query('li') || [])[index];
			if (ni && this.ownerCt) 
				Ext.fly(ni).scrollIntoView(this.ownerCt.body);
			
			
			
			window.setTimeout(this.focus.bind(this), 10);
		},
		initValue: function(){
			if (typeof this.value == "string") {
				this.value = this.value ? [this.value] : [];
			}
			if (this.value instanceof Array) {
				this.data = this.value;
				var value = this.value;
				this.value = "";
			}
			Ext.ux.form.TextFieldList.superclass.initValue.apply(this, arguments);
			
			if(value) {
				this.data = value;
				this.updateView();
			}
		},
		setValue: function(value){
			this.value = value;
			this.setRawValue(value);
			if (!value){
				this.data = [];
				this.updateView();
			}
		},
		onStartEdit : Ext.emptyFn,
		onStopEdit : Ext.emptyFn,
		onRemove : Ext.emptyFn,
		onSwap:Ext.emptyFn,
		onAdd: Ext.emptyFn,
		onEdit: Ext.emptyFn,
		startEdit: function(index){
			// Abort previous editing
			if(this.editing !== undefined) {
				this.stopEdit();
			}
			
			this.editing = index;
			var el = this.itemField.query("li")[index];
			Ext.fly(el).addClass("x-editing");
			this.setRawValue(this.data[index]);
			window.setTimeout(this.focus.bind(this), 10);
			this.onStartEdit();
		},
		stopEdit: function(){
			if (this.editing === undefined) {
				return;
			}
			var el = this.itemField.query("li")[this.editing];
			Ext.fly(el).removeClass("x-editing");
			delete this.editing;
			this.setRawValue("");
			this.onStopEdit();
		},
		onRender: function(){
			Ext.ux.form.TextFieldList.superclass.onRender.apply(this, arguments);
			
			if (!this.itemField){
				this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {
					tag: "div",
					style: "margin:1px 0px 4px 0px;" + (!this.emptyListText ? 'display:none;' : '') + '' + this.listStyle
				}));
			}
			
			if (!this.itemFieldTpl){
				if (this.showSequenceLinks === false){
					this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty">'+this.emptyListText+'</span></tpl>',
							'<ol><tpl for="."><li>'+this.viewEntry+' ', '<span class="x-smaller">', '(', '<a href="#{[xindex-1]}" class="x-edit" tabindex="-1">{[(Ext.ux.getI18N("btnEdit"))]}</a>, ', '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>)</span>', '</li></tpl></ol>');
				}else{
					this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty">'+this.emptyListText+'</span></tpl>',
							'<ol><tpl for="."><li>'+this.viewEntry+' ', '<span class="x-smaller">', '(', '<tpl if="xindex != 1">', '<a href="#{[xindex-1]}" class="x-move-up" tabindex="-1">{[(Ext.ux.getI18N("moveUp"))]}</a>, ', '</tpl>', '<tpl if="xindex != xcount">', '<a href="#{[xindex-1]}" class="x-move-down" tabindex="-1">{[(Ext.ux.getI18N("moveDown"))]}</a>, ', '</tpl>', '<a href="#{[xindex-1]}" class="x-edit" tabindex="-1">{[(Ext.ux.getI18N("btnEdit"))]}</a>, ', '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>)</span>', '</li></tpl></ol>');
				}
			}
			
			if ((this.data || []).length > 0){
				if (Ext.fly(this.container)){Ext.fly(this.container).removeClass("x-empty-textfield-list");}
			}else{
				if (Ext.fly(this.container)){Ext.fly(this.container).addClass("x-empty-textfield-list");}
			}
			
			this.updateView();
		},
		onShow: function(){
			Ext.ux.form.TextFieldList.superclass.onShow.apply(this, arguments);
			// Update width
			if (this.width){
				delete this.lastSize;
				this.setWidth(this.width)
			}
		},
		onUpdateView : Ext.emptyFn,
		updateView: function(){		
			
			if (!this.itemFieldTpl||!this.itemField){ return }
			this.itemFieldTpl.overwrite(this.itemField, this.data || []);
			if (!this.emptyListText)
				this.itemField.setDisplayed((this.data || []).length > 0);
			
			this.updateEvents()
			if (this.ownerCt && this.ownerCt.updateSize) {
				this.ownerCt.updateSize();
			}	
			
			this.onUpdateView();
		},
		moveData: function(index, off){
			var a, b;
			a = this.data[index];
			this.data[index] = b = this.data[index + off];
			this.data[index + off] = a;
		},
		
		updateEvents: function(){
			
			this.itemField.select("a.x-move-up").on("click", function(e, t){
				Event.stop(e);
				var index = parseInt(t.getAttribute("href").split("#").last());
				this.onSwap(index,index-1);
				this.moveData(index, -1);
				this.updateView();			
			}.bind(this));
			
			this.itemField.select("a.x-move-down").on("click", function(e, t){
				Event.stop(e);
				var index = parseInt(t.getAttribute("href").split("#").last());
				this.onSwap(index,index+1);
				this.moveData(index, 1);
				this.updateView();			
			}.bind(this));
			
			this.itemField.select("a.x-remove").on("click", function(e, t){
				Event.stop(e);
				var index = parseInt(t.getAttribute("href").split("#").last());
				var oldValue = this.data[index];
				var oldData = this.data.clone();
				delete this.data[index];
				this.data = this.data.compact();
				this.updateView();
				this.onRemove(index,oldValue,oldData);
				// remove css class			
				if (!((this.data || []).length > 0)){
					if (Ext.fly(this.container)){Ext.fly(this.container).addClass("x-empty-textfield-list");}
				}
			}.bind(this));
			
			this.itemField.select("a.x-edit").on("click", function(e, t){
				Event.stop(e);
				var index = parseInt(t.getAttribute("href").split("#").last());
				this.startEdit(index);
			}.bind(this));
			
			var lis = this.itemField.select("li");
			lis.addClassOnOver("x-hover")
			lis.on("mouseover", function(r, t){ Ext.fly(t).addClass("x-hover"); });	
			lis.on("mouseout", function(r, t){  Ext.fly(t).removeClass("x-hover"); });		
					
		},
		getValue: function(){
			if (this.editing !== undefined) {
				var value = this.getRawValue();
				if (value){
					var data = [].concat(this.data||[]);
					data[this.editing] = value;
					return data.compact();
				}
			}
			return [].concat(this.data || [], this.getRawValue().trim() || undefined).compact();
		}
		
	})
	
}());
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.form){ Ext.ux.form = {}; }

(function() {
    Ext.ux.form.TimeSpanField = function(attr) {
                
        this.fromEditor = attr.from;
        this.tillEditor = attr.till || attr.from;
        
        this.timespan = !!attr.till;
        this.lockcounter = 0;
        
        attr.items = [attr.from, attr.till].compact();    
        
        Ext.ux.form.TimeSpanField.superclass.constructor.call(this, attr);
        
        this.fromEditor.on("specialkey", this.onSpecialKey.bind(this));
        this.fromEditor.on("blur", this.handleBlur.bind(this));
        this.fromEditor.on("focus", this.handleFocus.bind(this));
        
        if(attr.till) {
            this.tillEditor.on("specialkey", this.onSpecialKey.bind(this));
            this.tillEditor.on("blur", this.handleBlur.bind(this));
            this.tillEditor.on("focus", this.handleFocus.bind(this));
        }
        
        this.on("resize", this.handleResize.bind(this));
        this.on("show", this.handleShow.bind(this));
    };
    
    Ext.extend(Ext.ux.form.TimeSpanField, Ext.Panel, {
                
        timespan: false,
        
        handleShow: function() {
            this.fromEditor.focus();  
        },
        
        hideEditor: function() {
            if(this.lockcounter === 0) {
                this.fireEvent("blur");
            }
        },
        
        handleBlur: function() {
            this.lockcounter += -1;
            
            window.setTimeout(this.hideEditor.bind(this), 100);
        },
        
        handleFocus: function() {
            this.lockcounter += 1;
        },

        handleResize: function(self, aw, ah, w, h) {
            if(this.initialConfig.till) {
                w = w/2 - 5; // 5px padding
            }
            
            this.fromEditor.setSize(w, h);
            this.tillEditor.setSize(w, h);
        },
    
        onSpecialKey: function(field, e) {
            if(e.getKey() === e.ENTER) {
                if(this.fromEditor.isValid() 
                    && !this.tillEditor.isValid()) {
                                            
                    this.tillEditor.focus();
                } else if(!this.fromEditor.isValid()
                    && this.tillEditor.isValid()) {
                                            
                    this.fromEditor.focus();        
                } else {
                    this.hideEditor(true);
                }
            }
        },
    
        setValue: function(value) {
            if(value instanceof Array) {
                value = (value || []).flatten().map(function(el) {
                    return this.parseDate(el);
                }.bind(this));
                
                var from = value.first();
                var till = value.last();
                
                this.fromEditor.setValue(from);
                this.tillEditor.setValue(till);
            } else if(value instanceof Date) {
                this.fromEditor.setValue(value);
            }
        },
        
        dateFromString: function(value) {
            if(!value) {
                return;
            }
            
            var dateArray = value.split("-");
            dateArray = dateArray[0].split(".");
            
            var day = dateArray[0];
            var month = dateArray[1];
            var year = "20" + dateArray[2];
            
            var date = new Date(month + "/" + day + "/" + year);
            
            if(isNaN(date.getTime())) {
                return;
            }
            
            return date;
        },
        
        parseDate: function(value) {
            if(value instanceof Date) {
                return value;
            }
            
            if(typeof value === "string") {
                return this.dateFromString(value);
            }
            
            if(value instanceof Array) {
                return value.map(function(el) {
                    return this.parseDate(el);
                }.bind(this));
            }
        },
        
        getValue: function() {
            return [this.fromEditor.getValue(), this.tillEditor.getValue()].uniq();
        },
        
        isValid: function() {
            var from = this.fromEditor.getValue();
            var till = this.tillEditor.getValue();
            
            if(!this.timespan) {
                return !!from;
            }
            
            return from && till && from < till;
        }
     
    });
})();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */



new function(){
	
	/**
	 * BUGFIXING:
	 * The width of the wrap and the field for a triggerfield
	 * was calculated also with the border and padding, 
	 * which is wrong for chrome and safari. So the calculation
	 * is adjusted for it.
	 *  
	 * @param {Object} w
	 * @param {Object} h
	 */
//	Ext.form.TriggerField.prototype.onResize = function(w, h){
//        Ext.form.TriggerField.superclass.onResize.call(this, w, h);
//        if(typeof w == 'number'){
//			var nw = w - this.trigger.getWidth();
//			if (this.el.dom.offsetWidth !== undefined && this.el.dom.scrollWidth !== undefined && 
//				this.el.dom.offsetWidth !== this.el.dom.scrollWidth && (this.anchor || "").startsWith("100%")) {
//				 //nw -= this.el.getPadding("lr") + this.el.getBorderWidth("lr");
//			}
//            this.el.setWidth(this.adjustWidth('input', nw));
//        }
//        this.wrap.setWidth(this.el.getWidth()+this.trigger.getWidth());
//    }
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.form){ Ext.ux.form = {}; }

(function(){
	
	
	Ext.ux.form.UrlLinkFieldList = function(attr){
		
		attr.listeners = Ext.apply({}, {
			specialkey: function(t, e){
				if (e.getKey() === e.ENTER) {
					t.onTriggerClick();
				}
				else 
					if (e.getKey() === e.ESC) {
						t.stopEdit();
					}
			}
		}, attr.listeners||{})
		
		Ext.ux.form.UrlLinkFieldList.superclass.constructor.apply(this, [attr])
	}
	
	Ext.extend(Ext.ux.form.UrlLinkFieldList, Ext.ux.form.TextFieldList, new Object({
		emptyText :Ext.ux.getI18N("url"),
		emptyLabelText : Ext.ux.getI18N("label"),
		prefix: "",
		prefixHTTP: "http://",
		prefixFileLocal: "file:///",
		prefixFileNetwork: "file://///",
		enableEmptyAdd : false,
		showSequenceLinks: true,
		ctCls : 'x-url-link-field-list',
		viewEntry : "<a href='{[Signavio.Utils.escapeHTML(values.url)]}' target='_blank' tabindex='-1'>{[Signavio.Utils.escapeHTML(values.label||values.url)]}</a>",
		evaluateLokalURL : function(){
			// Add prefix for lokal urls
			var val = (Ext.ux.form.TextFieldList.prototype.getRawValue.call(this)||"").strip();
			
			// Replace '/' to '\'
			val = val.replace(/\\/g, "/");
			
			// FIND: C:...
			if (val.match(/^[A-Z]:[\/\\]/i)){
				val = val.replace(/^[A-Z]:/i, function(r){ return r.toUpperCase(); });
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this,this.prefixFileLocal+""+val);

			// FIND: //...
			} else if (val.match(/^\/\/[^\/]/)){
				val = val.slice(2);
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this,this.prefixFileNetwork+""+val);
			}
	    },		
		isURL: function(url){
			url = url.trim();
			return 	!!url.match(/^[^:\/\\#?;]*?\.[a-zA-Z]{2,4}$/) ||  // Find just url without parameter like: 	www.google.de
					!!url.match(/^[^:\/\\#?;]*?\.[a-zA-Z]{2,4}[\/]/);// Find the url with parameters like: 		www.google.de/com
		},
		initEvents : function(){
	        Ext.ux.form.UrlLinkFieldList.superclass.initEvents.apply(this, arguments);
        	this.el.on("keyup", this.evaluateLokalURL,  this);
		},
		onResize : function(w, h){
	        Ext.ux.form.UrlLinkFieldList.superclass.onResize.call(this, w, h);
	        if(typeof w == 'number'){
				var fw = (w/2) - ((this.trigger.getWidth() || 17)/2);
				if (this.el.dom.offsetWidth !== undefined && this.el.dom.scrollWidth !== undefined && 
					this.el.dom.offsetWidth !== this.el.dom.scrollWidth && (this.anchor || "").startsWith("100%")) {
					fw += 0;
				}
				
				// Set the label field to 70% of the half of the width
				var fwf = Math.max(70, Math.round(fw*0.7)),
					fwe = fw+(fw-fwf);
				this.fel.setWidth(this.adjustWidth('input', fwf));
	            this.el.setWidth(this.adjustWidth('input', fwe + (!this.trigger.getWidth()?17:0)));
	        }
	        this.wrap.setWidth(w); //this.el.getWidth()+(this.trigger.getWidth()||17)+this.fel.el.getWidth());
	    },

		onRender: function(){
			Ext.ux.form.UrlLinkFieldList.superclass.onRender.apply(this, arguments);
			
			this.fel = new Ext.form.TextField({
				style: "border-right:none;",
				emptyText: this.emptyLabelText,
				applyEmptyText: function(){
					if (this.el.dom.value === '')
						Ext.form.TextField.prototype.applyEmptyText.call(this);
				},
				listeners: {
					focus : this.mimicBlur.bind(this, {}),
					specialkey: function(t, e){
						// Set changes if in edit mode
						if (this.editing === undefined){ return; }
						if (e.getKey() === e.ENTER) {
							this.onTriggerClick();
						} else if (e.getKey() === e.ESC) {
							this.stopEdit();
						}
					}.bind(this)
				}
			});
			this.fel.render(this.wrap);
			this.fel.el.insertBefore(this.el);
			this.updateView();
		},
		onFocus 	: function(){
			Ext.ux.form.UrlLinkFieldList.superclass.onFocus.apply(this, arguments);
			if (this.getRawValueFrom(this)==='' && this.prefix){
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, this.prefix);
				window.setTimeout(this.el.focus.bind(this.el), 10);
			}
		},
		onBlur	: function(){
			if (this.prefix&&this.getRawValueFrom(this)==this.prefix){
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, "");
			}
			Ext.ux.form.UrlLinkFieldList.superclass.onBlur.apply(this, arguments);
		},		
		startEdit: function(index){
			// Abort previous editing
			if(this.editing !== undefined) {
				this.stopEdit();
			}
			
			this.editing = index;
			var el = this.itemField.query("li")[index];
			Ext.fly(el).addClass("x-editing");
			this.setRawValue(this.data[index]);
			this.preFocus();
			window.setTimeout(this.fel.focus.bind(this.fel), 10);
			this.onStartEdit();
		},
		stopEdit: function(){
			Ext.ux.form.UrlLinkFieldList.superclass.stopEdit.apply(this, arguments);
			this.el.focus();
			this.fel.focus(false, true);
		},
		setRawValue : function(value){
			Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, (value||{}).url || "");
			this.fel.setValue((value||{}).label || "");
		},
		preFocus : function(){
	        if(this.emptyText){
	            if(this.el.dom.value == this.emptyText){
					Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, "");
	            }
	            this.el.removeClass(this.emptyClass);
	        }
	        if(this.selectOnFocus){
	            this.el.dom.select();
	        }
	    },
		getRawValue: function(){
			var url = (this.getRawValueFrom(this) || "").trim();
			
			if(!this.fel) {
				return "";
			}
			
			var label = this.getRawValueFrom(this.fel);

			if (this.isURL(url)){
				url = this.prefixHTTP + url;
			}

			var obj = Ext.apply({}, {
				url: unescape(decodeURI(url)), 
				label: label
			}, this.editing !== undefined ? this.data[this.editing] : {});

			return url && url !== this.prefix ? obj : "";
		},
		getRawValueFrom: function(field){
			var v = field.rendered ? field.el.getValue() : Ext.value(field.value, '');
	        if(v === field.emptyText){
	            v = '';
	        }
	        return v;
		},
		applyEmptyText : function(){
	        if(this.rendered && this.emptyText && this.getRawValue().length < 1){            
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, this.emptyText);
	            this.el.addClass(this.emptyClass);
	        }
	    },
		focus: function(){
			this.fel.focus();
		},
		getValue: function(){
			if (this.editing !== undefined) {
				var value = this.getRawValue();
				if (value){
					var data = [].concat(this.data||[]);
					data[this.editing] = value;
					return data.compact();
				}
			}
			return [].concat(this.data || [], this.getRawValue() || []).compact();
		},
		setValue: function(){
			
		}
	}));

}());

/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.form){ Ext.ux.form = {}; }

new function(){
	
	Ext.ux.form.SuggestBoxList = Ext.extend(Ext.ux.form.TextFieldList, {
		displayField: "value",
		dataIndex: undefined,
		/**
		 * @cfg {Function} callback receiving every data selection change.
		 */
		valueChangedCB: Ext.emptyFn,
		/**
	     * @cfg {Boolean/String} shadow True or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right
	     */
	    shadow:'sides',
	    /**
	     * @cfg {String} listAlign A valid anchor position value. See {@link Ext.Element#alignTo} for details on supported
	     * anchor positions (defaults to 'tl-bl')
	     */
	    listAlign: 'tl-bl?',
	    /**
	     * @cfg {String} selectedClass CSS class to apply to the selected item in the dropdown list (defaults to 'x-combo-selected')
	     */
	    selectedClass: 'x-combo-selected',
	    /**
	     * @cfg {Number} maxHeight The maximum height in pixels of the dropdown list before scrollbars are shown (defaults to 300)
	     */
	    maxHeight: 300,
	    /**
	     * @cfg {Number} minHeight The minimum height in pixels of the dropdown list when the list is constrained by its
	     * distance to the viewport edges (defaults to 90)
	     */
	    minHeight: 90,
		/**
	     * @cfg {String} triggerAction The action to execute when the trigger field is activated.  Use 'all' to run the
	     * query specified by the allQuery config option (defaults to 'query')
	     */
	    triggerAction: 'query',
	    /**
	     * @cfg {Number} minChars The minimum number of characters the user must type before autocomplete and typeahead activate
	     * (defaults to 4 if remote or 0 if local, does not apply if editable = false)
	     */
	    minChars : 4,
	    /**
	     * @cfg {Boolean} typeAhead True to populate and autoselect the remainder of the text being typed after a configurable
	     * delay (typeAheadDelay) if it matches a known value (defaults to true)
	     */
	    typeAhead: true,
	    /**
	     * @cfg {Number} queryDelay The length of time in milliseconds to delay between the start of typing and sending the
	     * query to filter the dropdown list (defaults to 500 if mode = 'remote' or 10 if mode = 'local')
	     */
	    queryDelay: 500,
	    queryClickDelay: 100,
	    /**
	     * @cfg {Number} pageSize If greater than 0, a paging toolbar is displayed in the footer of the dropdown list and the
	     * filter queries will execute with page start and limit parameters.  Only applies when mode = 'remote' (defaults to 0)
	     */
	    pageSize: 0,
	    /**
	     * @cfg {Boolean} selectOnFocus True to select any existing text in the field immediately on focus.  Only applies
	     * when editable = true (defaults to false)
	     */
	    selectOnFocus:false,
	    /**
	     * @cfg {String} queryParam Name of the query as it will be passed on the querystring (defaults to 'query')
	     */
	    queryParam: 'query',
	    /**
	     * @cfg {String} queryParam Name of the query defining the page size limit as it will be passed on the querystring (defaults to 'limit')
	     */
	    limitParam: 'limit',
	    limit: 0,
	    /**
	     * @cfg {String} queryParam Name of the query defining the current 
	     * position in the result list as it will be passed on the 
	     * querystring (defaults to 'offset')
	     */	
	    offsetParam: 'offset',
	    offset: 0,
	    /**
	     * @cfg {object} key value map of other parameter passed along with the
	     * querystring (defaults to '{}')
	     */	
	    otherParams: {},
	    /**
	     * Function to filter the paging information.
	     */
	    pagesRecFn: undefined,
	    /**
	     * @cfg {String} loadingText The text to display in the dropdown list while data is loading.  Only applies
	     * when mode = 'remote' (defaults to 'Loading...')
	     */
	    loadingText: 'Loading...',
	    /**
	     * @cfg {Boolean} resizable True to add a resize handle to the bottom of the dropdown list (defaults to false)
	     */
	    resizable: false,
	    /**
	     * @cfg {Number} handleHeight The height in pixels of the dropdown list resize handle if resizable = true (defaults to 8)
	     */
	    handleHeight : 8,
	    /**
	     * @cfg {Boolean} editable False to prevent the user from typing text directly into the field, just like a
	     * traditional select (defaults to true)
	     */
	    editable: true,
	    /**
	     * @cfg {String} allQuery The text query to send to the server to return all records for the list with no filtering (defaults to '')
	     */
	    allQuery: '',
	    /**
	     * @cfg {String} mode Set to 'local' if the ComboBox loads local data (defaults to 'remote' which loads from the server)
	     */
	    mode: 'remote',
	    /**
	     * @cfg {Number} minListWidth The minimum width of the dropdown list in pixels (defaults to 70, will be ignored if
	     * listWidth has a higher value)
	     */
	    minListWidth : 70,
	    /**
	     * @cfg {Boolean} forceSelection True to restrict the selected value to one of the values in the list, false to
	     * allow the user to set arbitrary text into the field (defaults to false)
	     */
	    forceSelection:false,
	    /**
	     * @cfg {Number} typeAheadDelay The length of time in milliseconds to wait until the typeahead text is displayed
	     * if typeAhead = true (defaults to 250)
	     */
	    typeAheadDelay : 250,
	    /**
	     * @cfg {String} valueNotFoundText When using a name/value combo, if the value passed to setValue is not found in
	     * the store, valueNotFoundText will be displayed as the field text if defined (defaults to undefined)
	     */

	    /**
	     * @cfg {Boolean} lazyInit True to not initialize the list for this combo until the field is focused. (defaults to true)
	     */
	    lazyInit : true,
	    
	    

	    initComponent : function(){
	    	Ext.ux.form.SuggestBoxList.superclass.initComponent.call(this);
	        this.addEvents(
	            /**
	             * @event expand
	             * Fires when the dropdown list is expanded
	             * @param {Ext.form.ComboBox} combo This combo box
	             */
	            'expand',
	            /**
	             * @event collapse
	             * Fires when the dropdown list is collapsed
	             * @param {Ext.form.ComboBox} combo This combo box
	             */
	            'collapse',
	            /**
	             * @event beforeselect
	             * Fires before a list item is selected. Return false to cancel the selection.
	             * @param {Ext.form.ComboBox} combo This combo box
	             * @param {Ext.data.Record} record The data record returned from the underlying store
	             * @param {Number} index The index of the selected item in the dropdown list
	             */
	            'beforeselect',
	            /**
	             * @event select
	             * Fires when a list item is selected
	             * @param {Ext.form.ComboBox} combo This combo box
	             * @param {Ext.data.Record} record The data record returned from the underlying store
	             * @param {Number} index The index of the selected item in the dropdown list
	             */
	            'select',
	            /**
	             * @event beforequery
	             * Fires before all queries are processed. Return false to cancel the query or set the queryEvent's
	             * cancel property to true.
	             * @param {Object} queryEvent An object that has these properties:<ul>
	             * <li><code>combo</code> : Ext.form.ComboBox <div class="sub-desc">This combo box</div></li>
	             * <li><code>query</code> : String <div class="sub-desc">The query</div></li>
	             * <li><code>forceAll</code> : Boolean <div class="sub-desc">True to force "all" query</div></li>
	             * <li><code>cancel</code> : Boolean <div class="sub-desc">Set to true to cancel the query</div></li>
	             * </ul>
	             */
	            'beforequery'
	        );
	        if(this.transform){
	            this.allowDomMove = false;
	            var s = Ext.getDom(this.transform);
	            if(!this.hiddenName){
	                this.hiddenName = s.name;
	            }
	            if(!this.store){
	                this.mode = 'local';
	                var d = [], opts = s.options;
	                for(var i = 0, len = opts.length;i < len; i++){
	                    var o = opts[i];
	                    var value = (Ext.isIE ? o.getAttributeNode('value').specified : o.hasAttribute('value')) ? o.value : o.text;
	                    if(o.selected) {
	                        this.value = value;
	                    }
	                    d.push([value, o.text]);
	                }
	                this.store = new Ext.data.SimpleStore({
	                    'id': 0,
	                    fields: ['value', 'text'],
	                    data : d
	                });
	                this.valueField = 'value';
	                this.displayField = 'text';
	            }
	            s.name = Ext.id(); // wipe out the name in case somewhere else they have a reference
	            if(!this.lazyRender){
	                this.target = true;
	                this.el = Ext.DomHelper.insertBefore(s, this.autoCreate || this.defaultAutoCreate);
	                Ext.removeNode(s); // remove it
	                this.render(this.el.parentNode);
	            }else{
	                Ext.removeNode(s); // remove it
	            }

	        }
	        this.selectedIndex = -1;
	        if(this.mode == 'local'){
	            if(this.initialConfig.queryDelay === undefined){
	                this.queryDelay = 10;
	            }
	            if(this.initialConfig.minChars === undefined){
	                this.minChars = 0;
	            }
	        }
	    },
	    
	    // private
	    initEvents : function(){
	    	Ext.ux.form.SuggestBoxList.superclass.initEvents.call(this);

	        this.keyNav = new Ext.KeyNav(this.el, {
//	            "up" : function(e){
//	                this.inKeyMode = true;
//	                this.selectPrev();
//	            },
//
//	            "down" : function(e){
//	                if(!this.isExpanded()){
//	                    this.onTriggerClick();
//	                }else{
//	                    this.inKeyMode = true;
//	                    this.selectNext();
//	                }
//	            },

//	            "enter" : function(e){
//	                this.onViewClick();
//	                this.delayedCheck = true;
//					this.unsetDelayCheck.defer(10, this);
//	            },

	            "esc" : function(e){
	                this.collapse();
	            },

//	            "tab" : function(e){
//	                this.onViewClick(false);
//	                return true;
//	            },

	            scope : this,

	            doRelay : function(foo, bar, hname){
	                if(hname == 'down' || this.scope.isExpanded()){
	                   return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
	                }
	                return true;
	            },

	            forceKeyDown : true
	        });
	        this.queryDelay = Math.max(this.queryDelay || 10,
	                this.mode == 'local' ? 10 : 250);
	        this.dqTask = new Ext.util.DelayedTask(this.initQuery, this);
	        if(this.typeAhead){
	            this.taTask = new Ext.util.DelayedTask(this.onTypeAhead, this);
	        }
	        if(this.editable !== false){
	            this.el.on("keyup", this.onKeyUp, this);
	            this.el.on("mousedown", this.onMouseDown, this);
	        }
	        if(this.forceSelection){
	            this.on('blur', this.doForce, this);
	        }
	    },
	    
		onLoad : function(store, records, options){
	        if(!this.hasFocus){
	            return;
	        }
	        if(this.store.getCount() == 0 && records && records.size() > 0) {
	        	this.store.data.addAll(records);
	        }
	        
	        if(this.store.getCount() > 0){
	            this.expand();
	            this.restrictHeight();
	            if(this.lastQuery == this.allQuery){
	                if(this.editable){
	                    this.el.dom.select();
	                }
	                if(!this.selectByValue(this.value, true)){
	                    this.select(0, true);
	                }
	            } else {
					if (this.selectedIndex !== -1 || this.forceSelection){
						this.selectNext();
					}
	                if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
	                    this.taTask.delay(this.typeAheadDelay);
	                }
	            }
	        }else{
	            this.onEmptyResults();
	        }
	        //this.el.focus();
	    },
	    
	    // private
	    onEmptyResults : function(){
	        this.collapse();
	    },
	    
	    /**
	     * @override
	     * Removes duplicates from the view data list and triggers the 
	     * superclass method
	     */
	    updateView: function() {
	    	if(this.data instanceof Array) {
	    		this.data = this.data.uniq();
	    	}
	    	
	    	Ext.ux.form.SuggestBoxList.superclass.updateView.call(this,arguments);
	    },
	    
	    onViewClick : function(doFocus){
	        var index = this.view.getSelectedIndexes()[0];
	        var r = this.store.getAt(index);
	        if(r && r.data.rep.isSelectable) {
	        	this.data.push(r.data.rep.value);
	        	this.updateView();
	        }
//	        if(r){
//	            this.onSelect(r, index);
//	        } else if (!this.forceSelection) {
//				this.setValue(Ext.form.ComboBox.superclass.getValue.call(this));
//				this.collapse();
//			}
//	        if(doFocus !== false){
//	            this.el.focus();
//	        }
	    },
	    
	    // private
	    onTypeAhead : function(){
	        if(this.store.getCount() > 0){
	            var r = this.store.getAt(0);
	            var newValue = r.data[this.dataIndex][this.displayField];
	            var len = newValue.length;
	            var selStart = this.getRawValue().length;
	            if(newValue && selStart != len){
	                this.setRawValue(newValue);
	                this.selectText(selStart, newValue.length);
	            }
	        }
	    },
	    
	    /**
	     * Execute a query to filter the dropdown list.  Fires the beforequery event prior to performing the
	     * query allowing the query action to be canceled if needed.
	     * @param {String} query The SQL query to execute
	     * @param {Boolean} forceAll True to force the query to execute even if there are currently fewer characters
	     * in the field than the minimum specified by the minChars config option.  It also clears any filter previously
	     * saved in the current store (defaults to false)
	     */
	    doQuery : function(q, forceAll){
	        if(q === undefined || q === null){
	            q = '';
	        }
	        var qe = {
	            query: q,
	            forceAll: forceAll,
	            combo: this,
	            cancel:false
	        };
	        if(this.fireEvent('beforequery', qe)===false || qe.cancel){
	            return false;
	        }
	        q = qe.query;
	        forceAll = qe.forceAll;
	        if(forceAll === true || (q.length >= this.minChars)){
	            if(this.lastQuery !== q){
	                this.lastQuery = q;
	                if(this.mode == 'local'){
	                    this.selectedIndex = -1;
	                    if(forceAll){
	                        this.store.clearFilter();
	                    }else{
	                        this.store.filter(this.displayField, q);
	                    }
	                    this.onLoad();
	                }else{
	                	// Set query parameters
//	                    this.store.baseParams[this.queryParam] = this.getParams(q);
//	                    this.store.baseParams[this.limitParam] = this.limit;
//	                    this.store.baseParams[this.offsetParam] = this.offset;
	                	
	                	// Load initial values depending on query string
	                	if(q === '' && this.initialValues instanceof Array) {
	                		this.store.loadData(this.initialValues.pluck("data"));
	                	} else {
	                		this.store.load({
	                			force: true, // forced to use not the cache
	                			params: this.getParams(q)
//	                        filter: this.filter
	                		});	                		
	                	}
	                	 
	                    this.expand();
	                }
	            }else{
	                this.selectedIndex = -1;
	                this.onLoad();
	            }
	        }
	    },
	    
	    // private
	    onKeyUp : function(e){
	        if(this.editable !== false && !e.isSpecialKey()){
	            this.lastKey = e.getKey();
	            this.dqTask.delay(this.queryDelay);
	        }
	    },
	    
	    /**
	     * Same usage as key up, but for empty input. Triggers display of initial 
	     * suggestible values.
	     */
	    onMouseDown : function(e) {
	    	if(this.editable !== false && this.getRawValue() === "") {
	    		this.dqTask.delay(this.queryClickDelay);
	    	}
	    },
	    
	    // private
	    initQuery : function(){
	        this.doQuery(this.getRawValue());
	    },
	    
	    // private
	    getParams : function(q, start){
	        var p = {};
	        
	        if(this.pageSize){
	            p.offset = start||0;
	            p.limit = this.pageSize;
	        }
	        p[this.currentValueParam] = q;
	        
	        if(typeof(this.otherParams) !== "undefined") {
	        	Ext.apply(p,this.otherParams);
	        }
	        
	        return p;
	    },
	    
	 // private
	    bindStore : function(store, initial){
	        if(this.store && !initial){
	            this.store.un('beforeload', this.onBeforeLoad, this);
	            this.store.un('load', this.onLoad, this);
	            this.store.un('loadexception', this.collapse, this);
	            if(!store){
	                this.store = null;
	                if(this.view){
	                    this.view.setStore(null);
	                }
	            }
	        }
	        if(store){
	            //this.store = Ext.StoreMgr.lookup(store);
	        	this.store = store;

	            this.store.on('beforeload', this.onBeforeLoad, this);
	            this.store.on('load', this.onLoad, this);
	            this.store.on('loadexception', this.collapse, this);

	            if(this.view){
	                this.view.setStore(store);
	            }
	        }
	    },
	    
	    // private
	    onRender : function(ct, position){
	    	Ext.ux.form.SuggestBoxList.superclass.onRender.call(this, ct, position);
//	        if(this.hiddenName){
//	            this.hiddenField = this.el.insertSibling({tag:'input', type:'hidden', name: this.hiddenName, id: (this.hiddenId||this.hiddenName)},
//	                    'before', true);
//	            this.hiddenField.value =
//	                this.hiddenValue !== undefined ? this.hiddenValue :
//	                this.value !== undefined ? this.value : '';
//
//	            // prevent input submission
//	            this.el.dom.removeAttribute('name');
//	        }
//	        if(Ext.isGecko){
//	            this.el.dom.setAttribute('autocomplete', 'off');
//	        }

	        if(!this.lazyInit){
	            this.initList();
	        }else{
	            this.on('focus', this.initList, this, {single: true});
	        }

	        if(!this.editable){
	            this.editable = true;
	            this.setEditable(false);
	        }
	    },
	    
	    /**
	     * Allow or prevent the user from directly editing the field text.  If false is passed,
	     * the user will only be able to select from the items defined in the dropdown list.  This method
	     * is the runtime equivalent of setting the 'editable' config option at config time.
	     * @param {Boolean} value True to allow the user to directly edit the field text
	     */
	    //TODO: guess refactoring is required
	    setEditable : function(value){
	        if(value == this.editable){
	            return;
	        }
//	        this.editable = value;
//	        if(!value){
//	            this.el.dom.setAttribute('readOnly', true);
//	            this.el.on('mousedown', this.onTriggerClick,  this);
//	            this.el.addClass('x-combo-noedit');
//	        }else{
//	            this.el.dom.setAttribute('readOnly', false);
//	            this.el.un('mousedown', this.onTriggerClick,  this);
//	            this.el.removeClass('x-combo-noedit');
//	        }
	    },
	    
	    /**
	     * Expands the dropdown list if it is currently hidden. Fires the 'expand' event on completion.
	     */
	    expand: function(){
	        if(this.isExpanded() || !this.hasFocus){
	            return;
	        }
	        this.list.alignTo(this.wrap, this.listAlign);
	        this.list.show();
	        this.innerList.setOverflow('auto'); // necessary for FF 2.0/Mac
	        Ext.getDoc().on('mousewheel', this.collapseIf, this);
	        Ext.getDoc().on('mousedown', this.collapseIf, this);
	        this.fireEvent('expand', this);
	    },
	    
	    /**
	     * Returns true if the dropdown list is expanded, else false.
	     */
	    isExpanded: function(){
	        return this.list && this.list.isVisible();
	    },
	    
	    initList: function(){
	    	// VARs
	    	var doLoadFN;
	    	
	        if(!this.list){
	            var cls = 'x-combo-list';

	            this.list = new Ext.Layer({
	                shadow: this.shadow, cls: [cls, this.listClass].join(' '), constrain:false
	            });

	            var lw = this.listWidth || Math.max(this.wrap.getWidth(), this.minListWidth);
	            this.list.setWidth(lw);
	            this.list.swallowEvent('mousewheel');
	            this.assetHeight = 0;

	            if(this.title){
	                this.header = this.list.createChild({cls:cls+'-hd', html: this.title});
	                this.assetHeight += this.header.getHeight();
	            }

	            this.innerList = this.list.createChild({cls:cls+'-inner'});
	            this.innerList.on('mouseover', this.onViewOver, this);
	            this.innerList.on('mousemove', this.onViewMove, this);
	            this.innerList.setWidth(lw - this.list.getFrameWidth('lr'));

	            if(this.pageSize){
	            	doLoadFN = function(start) {
	            		var currentVal = this.getRawValue(),
	            			opt;
	            		
	            		if(!currentVal) {
	            			currentVal = '';
	            		}
	            		
	            		opt = this.getParams(currentVal, start);
            	        this.store.load({params:opt});
	            	}.bind(this);
	                this.footer = this.list.createChild({cls:cls+'-ft'});
	                this.pageTb = new Ext.ux.PagingToolbar({
	                    store:this.store,
	                    pageSize: this.pageSize,
	                    renderTo:this.footer,
	                    doLoad: doLoadFN,
	                    style: 'z-index:1000002',
	                    afterPageText: "/{0}",
	                    beforePageText: "{0}",
	                    ctCls: "x-paginglist-container",
	                    cls: "x-paginglist"
	                });
	                this.assetHeight += this.footer.getHeight();
	            }

	            if(!this.tpl){
				    /**
				    * @cfg {String/Ext.XTemplate} tpl The template string, or {@link Ext.XTemplate}
				    * instance to use to display each item in the dropdown list. Use
				    * this to create custom UI layouts for items in the list.
				    * <p>
				    * If you wish to preserve the default visual look of list items, add the CSS
				    * class name <pre>x-combo-list-item</pre> to the template's container element.
				    * <p>
				    * <b>The template must contain one or more substitution parameters using field
				    * names from the Combo's</b> {@link #store Store}. An example of a custom template
				    * would be adding an <pre>ext:qtip</pre> attribute which might display other fields
				    * from the Store.
				    * <p>
				    * The dropdown list is displayed in a DataView. See {@link Ext.DataView} for details.
				    */
//	                this.tpl = '<tpl for="."><div class="'+cls+'-item"><a href="#{[xindex-1]}" class="x-form-add-trigger" tabindex="-1"><tpl for="rep">{value}</tpl></a></div></tpl>';
	            	var fn = function(rep) {
	            		if(rep.isSelectable) {
	            			return "x-row-unselectable";
	            		}
	            	};
	            	
	            	this.tpl = new Ext.XTemplate('<tpl for=".">',
	            			'<tpl for="rep"><div class="'+cls+'-item {[this.getRowClass(values)]}">',
	            			'{value}</div></tpl></tpl>',
	            			{
	            				getRowClass: function(val) {
	            					if(!val.isSelectable) {
	            						return "x-row-unselectable";
	            					}
	            				}
	            			});
	            }

			    /**
			    * The {@link Ext.DataView DataView} used to display the ComboBox's options.
			    * @type Ext.DataView
			    */
	            this.view = new Ext.DataView({
	                applyTo: this.innerList,
//	                disabledClass: "x-row-unselectable",
	                tpl: this.tpl,
	                singleSelect: true,
	                overClass:'x-view-over',
	                selectedClass: this.selectedClass,
	                itemSelector: this.itemSelector || 'div.' + cls + '-item'
	            });

	            this.view.on('click', this.onViewClick, this);

	            this.bindStore(this.store, true);

	            if(this.resizable){
	                this.resizer = new Ext.Resizable(this.list,  {
	                   pinned:true, handles:'se'
	                });
	                this.resizer.on('resize', function(r, w, h){
	                    this.maxHeight = h-this.handleHeight-this.list.getFrameWidth('tb')-this.assetHeight;
	                    this.listWidth = w;
	                    this.innerList.setWidth(w - this.list.getFrameWidth('lr'));
	                    this.restrictHeight();
	                }, this);
	                this[this.pageSize?'footer':'innerList'].setStyle('margin-bottom', this.handleHeight+'px');
	            }
	        }
	    },
	    
	 // private
	    onViewMove : function(e, t){
	        this.inKeyMode = false;
	    },

	    // private
	    onViewOver : function(e, t){
	    	if(this.inKeyMode){ // prevent key nav and mouse over conflicts
	            return;
	        }
	        var item = this.view.findItemFromChild(t);
	        if(item){
	            var index = this.view.indexOf(item);
	            this.select(index, false);
	        }
	    },
	    
	    // private
	    //TODO: refactoring
	    onBeforeLoad : function(){
	        if(!this.hasFocus){
	            return;
	        }
	        this.innerList.update(this.loadingText ?
	               '<div class="loading-indicator">'+this.loadingText+'</div>' : '');
	        this.restrictHeight();
	        this.selectedIndex = -1;
	    },
	    
	    /**
	     * Hides the dropdown list if it is currently expanded. Fires the 'collapse' event on completion.
	     */
	    collapse : function(){
	        if(!this.isExpanded()){
	            return;
	        }
	        this.list.hide();
	        Ext.getDoc().un('mousewheel', this.collapseIf, this);
	        Ext.getDoc().un('mousedown', this.collapseIf, this);
	        this.fireEvent('collapse', this);
	    },

	    // private
	    collapseIf : function(e){
	        if(!e.within(this.wrap) && !e.within(this.list)){
	            this.collapse();
	        }
	    },
	    
	    // private
		restrictHeight : function(){
	        this.innerList.dom.style.height = '';
	        var inner = this.innerList.dom;
	        var pad = this.list.getFrameWidth('tb')+(this.resizable?this.handleHeight:0)+this.assetHeight;
	        var h = Math.max(inner.clientHeight, inner.offsetHeight, inner.scrollHeight);
	        var ha = this.getPosition()[1]-Ext.getBody().getScroll().top;
	        var hb = Ext.lib.Dom.getViewHeight()-ha-this.getSize().height;
	        var space = Math.max(ha, hb, this.minHeight || 0)-this.list.shadowOffset-pad-2;
	        h = Math.min(h, space, this.maxHeight);
	        
	        this.innerList.setHeight(h);
	        this.list.beginUpdate();
	        this.list.setHeight(h+pad);
	        this.list.alignTo(this.el, this.listAlign);
	        this.list.endUpdate();
	    },
	    
	    /**
	     * Select an item in the dropdown list by its data value. This function does NOT cause the select event to fire.
	     * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
	     * @param {String} value The data value of the item to select
	     * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
	     * selected item if it is not currently in view (defaults to true)
	     * @return {Boolean} True if the value matched an item in the list, else false
	     */
	    selectByValue : function(v, scrollIntoView){
//	        if(v !== undefined && v !== null){
//	            var r = this.findRecord(this.valueField || this.displayField, v);
//	            if(r){
//	                this.select(this.store.indexOf(r), scrollIntoView);
//	                return true;
//	            }
//	        }
	        return false;
	    },

	    /**
	     * Select an item in the dropdown list by its numeric index in the list. This function does NOT cause the select event to fire.
	     * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
	     * @param {Number} index The zero-based index of the list item to select
	     * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
	     * selected item if it is not currently in view (defaults to true)
	     */
	    select : function(index, scrollIntoView){
	        this.selectedIndex = index;
	        this.view.select(index);
	        if(scrollIntoView !== false){
	            var el = this.view.getNode(index);
	            if(el){
	                this.innerList.scrollChildIntoView(el, false);
	            }
	        }
	    },

	    // private
	    selectNext : function(){
	        var ct = this.store.getCount();
	        if(ct > 0){
	            if(this.selectedIndex == -1){
	                this.select(0);
	            }else if(this.selectedIndex < ct-1){
	                this.select(this.selectedIndex+1);
	            }
	        }
	    },

	    // private
	    selectPrev : function(){
	        var ct = this.store.getCount();
	        if(ct > 0){
	            if(this.selectedIndex == -1){
	                this.select(0);
	            }else if(this.selectedIndex != 0){
	                this.select(this.selectedIndex-1);
	            }
	        }
	    },
	    
	    /**
	     * @override
	     * Propagates a value change at the displayed data list.
	     */
	    onUpdateView: function() {
	    	var option = {};
	    	
	    	if(this.data instanceof Array) {
	    		Ext.apply(option, this.otherParams);
	    		
	    		option.value = this.data;
	    		
	    		if(this.lastValue && this.lastValue != option) {
	    			this.valueChangedCB(option);	    			
	    		}
	    		
	    		this.lastValue = option;
	    	}
	    }
	});
}();

/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

ns("glossary");

(function() {

	var STORE_ID = "/glossarycategory";
	var PREFIX = STORE_ID + "/";

	var DUMMY_RECORD = [PREFIX, "", "", false];

	var TPL =
		'<tpl for=".">' +
			'<div class="x-combo-list-item">' +
				// Inden +
				'<tpl if="child">' +
					'<span style="margin-left:10px;">' +
				'</tpl>' +
				// Or not inden +
				'<tpl if="!child">' +
					'<span>' +
				'</tpl>' +
					'<div class="x-glossary-color" style="background-color:{color};"></div>' +
					'{name}' +
				'</span>' +
			'</div>' +
		'</tpl>';

	Signavio.glossary.CategorySelector = function(attrs) {
		attrs = attrs || {};

		this.blacklist = attrs.without || [];

		this.configure(attrs);
		this.extendStore(attrs.categoryStore);

		this.showAll = attrs.showAll;

		attrs.store = this.createStore(attrs.categoryStore, attrs.showDummy, attrs.hideChildren);

		if(attrs.value && !this.categoryAvailable(attrs.categoryStore, attrs.value)) {
			delete attrs.value;
		}

		Signavio.glossary.CategorySelector.superclass.constructor.apply(this, arguments);

		var that = this;

		this.on("blur", function() {
			that.restoreDomValue();

			return false;
		});
	};

	Ext.extend(Signavio.glossary.CategorySelector, Ext.form.ComboBox, {

		boolDefault: function(value, defaultValue) {
			return Ext.isDefined(value) ? value : defaultValue;
		},

		categoryAvailable: function(store, ref) {
			var index = store.findBy(function(record) {
				return record.get("href") === ref;
			});

			return index !== -1;
		},

		configure: function(attrs) {
			Ext.applyIf(attrs, {
				dataField: "category",
				fieldLabel: Ext.ux.getI18N("glossary.category.label"),
				displayField: "name",
				valueField: "id",
				forceSelection: true,
				mode: 'local',
				readOnly: true,
				allowBlank: this.boolDefault(attrs.showDummy, false),
				triggerAction: 'all',
				lazyRender: this.boolDefault(attrs.lazyRender, true),
				lazyInit: this.boolDefault(attrs.lazyInit, false),
				hideChildren: this.boolDefault(attrs.hideChildren, false),
				tpl: TPL,
				showDummy: this.boolDefault(attrs.showDummy, false)
			});
		},

		extendStore: function(store) {
			if(store.getRecords) {
				return;
			}

			// This code was copied from the explorer. The getRecords method
			// should be present on ALL stores in the system. This code here
			// needs to be removed once the Editor and Explorer share the
			// same store structure.
			store.getRecords = function(rel) {
				var recs = [];
				rel = rel instanceof Array ? rel : (rel ? [rel] : null);

				(this.snapshot || this.data).each(function(r){
					if( !rel || rel.include(r.get("rel")) ){
						recs.push(r);
					}
				});

				return recs;
			};
		},

		parseRecords: function(records) {
			var categories = {
				root: []
			};

			var that = this;

			records.sortBy(function(record) {
				var rep = record.get("rep");

				return rep.order;
			}).each(function(record) {
				var rep = record.get("rep");
				var parent = rep.parentCategory || "root";

				if(!categories[parent]) {
					categories[parent] = [];
				}

				if(rep.hidden && !that.showAll) {
					return;					
				}

				categories[parent].push(rep);
			});

			return categories;
		},

		createData: function(categories, hideChildren) {
			var data = [];
			var that = this;

			var addRecord = function(record) {
				if(that.blacklist.include(record.id)) {
					return;
				}

				data.push([
					record.id || "",
					record.name || "",
					record.color,
					Ext.isDefined(record.parentCategory)
				]);
			};

			categories.root.each(function(record) {
				addRecord(record);

				if(categories[record.id] && !hideChildren) {
					categories[record.id].each(addRecord);
				}
			});

			return data;
		},

		createStore: function(categoryStore, prependNone, hideChildren) {
			// The category store should be removed once all 
			// components share the same store architecture!
			// It should be replaced by something like:
			// Signavio.Core.StoreManager.getCategoryStore();
			var records = categoryStore.getRecords("cat");

			var categories = this.parseRecords(records);
			var data = this.createData(categories, hideChildren);

			if(prependNone) {
				data = [DUMMY_RECORD].concat(data);
			}

			return new Ext.data.SimpleStore({
				fields: ["id", "name", "color", "child"],
				data: data
			});
		},

		getValue: function() {
			var value = Ext.form.ComboBox.prototype.getValue.apply(this);

			if(value.replace(PREFIX, "") === "") {
				return null;
			}

			return value;
		},

		restoreDomValue: function() {
			this.el.dom.value = (this.el.dom.value || "").unescapeHTML();
		},

		setValue: function() {
			Ext.form.ComboBox.prototype.setValue.apply(this, arguments);

			this.restoreDomValue();
		}
	});

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
ns("glossary.config");

(function() {

	Signavio.glossary.config.REL = {
		GLOSSARY_ITEM: "gitem",
		ATTACHMENT: "att",
		LINK: "link",
		INFO: "info",
		LINKED: "glossarylink",
		CATEGORY: "cat"
	};

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
ns("glossary");

(function() {

	var STORE_ID = "/glossarycategory";
	var PREFIX = STORE_ID + "/";

	Signavio.glossary.Editor = function(attrs) {
		attrs = attrs || {};

		this.prepareDefaults(attrs);

		Signavio.glossary.Editor.superclass.constructor.call(this, attrs);

		var that = this;

		this.on("resize", function() {
			that.updateSize();
		});

		this.fields = [];
		this.currentCategory = attrs.category;

		var data = this.extractInfo(this.store);
		this.changeCategory(this.getCategory(data), data);
	};

	Ext.extend(Signavio.glossary.Editor, Ext.ux.Window, {

		prepareDefaults: function(attrs) {
			attrs.minHeight = 450;
			attrs.minWidth = 900;

			attrs.width = Math.max(attrs.width || 0, document.viewport.getWidth() * 0.7, attrs.minWidth);
			attrs.height = Math.max(attrs.height || 0, document.viewport.getHeight() * 0.7, attrs.minHeight);

			attrs.title = attrs.store ? Ext.ux.getI18N("glossary.edit.title") : Ext.ux.getI18N("glossary.new.title");

			attrs.cls = "x-glossary-new";
			attrs.modal = true;
			attrs.autoScroll = true;
			attrs.layout = "form";
			attrs.labelWidth = 150;
			attrs.onEsc = Ext.emptyFn;

			attrs.onSave = attrs.onSave || Ext.emptyFn;

			var that = this;

			attrs.buttons = attrs.buttons || [
				{
					text: attrs.store ? Ext.ux.getI18N("glossary.edit.save") : Ext.ux.getI18N("glossary.new.save"),
					handler: function() {
						var win = this.ownerCt;

						attrs.onSave(win, that.extractParams(that.getFields()));
					}
				}
			];
		},

		getStore: function() {
			return this.store;
		},

		getFields: function() {
			return this.fields;
		},

		clearFields: function() {
			var that = this;

			(this.items || []).each(function(item) {
				that.remove(item);
			});

			this.fields.clear();
		},

		addField: function(field) {
			this.fields.push(field);
		},

		getLabels: function() {
			var iterate = function(children, labels){
				labels = labels || [];

				children.each(function(child){
					if (!child instanceof Ext.Panel){
						return;
					}

					if (child instanceof Ext.ux.form.TranslationField) {
						return;
					}

					if(child.items && child.items.getCount()){
						return iterate(child.items, labels);
					}

					labels.push(child);
				});

				return labels;
			};

			return iterate(this.items || []);
		},

		extractInfo: function(store){		
			if (!store) {
				return {
					category: "",
					title: "",
					description: "",
					glossaryLinks: [],
					attachments: [],
					formats: {},
					metaDataValues: {}
				};
			}

			var data = {};

			// Info
			var info = store.getRecords(Signavio.glossary.config.REL.INFO)[0];
			var rep = info.get("rep");

			if(!rep.category.startsWith(PREFIX)) {
				rep.category = PREFIX + rep.category;
			}

			// Category
			data.category = rep.category;
			// Title
			Ext.apply(data, Signavio.glossary.utils.getValuesFor(info.get("rep"), "title", function(title){
				return Signavio.Utils.unescapeHTML(title||"");
			}));
			// Description
			Ext.apply(data, Signavio.glossary.utils.getValuesFor(info.get("rep"), "description", function(desc){
				return Signavio.Utils.unescapeHTML(desc||"");
			}));
			//  Linked Attachments
			Ext.apply(data, Signavio.glossary.utils.getValuesFor(info.get("rep"), "attachments", function(v) {return v.clone();}));
			
			// Linked Models
			var glossaryLinks = store.getRecords(Signavio.glossary.config.REL.LINKED)[0];
			data.glossaryLinks = glossaryLinks.get("rep").map(function(link){ 
				return Signavio.Core.RecordCreator.create(link.rel, link.href, link.rep); 
			});
			
			// Formats
			data.formats = Object.clone(info.get("rep").formats || {});
			
			// Meta Data
			data.metaDataValues = Object.clone(info.get("rep").metaDataValues || {});
			
			return data;
		},

		onCategoryChange: function(value) {
			if (this.currentCategory === value){
				return;
			}

			this.currentCategory = value;

			var that = this;

			this.body.fadeOut({
				duration : 0.3,
				callback: function(){
					// Get the data
					var data = that.extractParams(that.getFields());
					// Get the missing records
					that.items.each(function(item){
						if (item instanceof Ext.ux.form.GlossaryField && item.dataField && item.records){
							data[item.dataField] = item.records;
						}
					});

					that.changeCategory(value, data);
				}
			});
		},

		changeCategory: function(value, data) {
			var that = this;

			this.clearFields();
			
			delete this.items;
			
			if(this.rendered) {
				this.body.update();
				this.body.show();
				this.body.setOpacity(0.01);
			}
			
			this.addItems(data);
			
			if(this.rendered) {
				// Update size
				this.doLayout();
				this.updateSize();
				this.doLayout();
				
				// Show the content
				this.body.fadeIn({
					duration: 0.3
				});
				
				this.syncSize();
			} else {
				window.setTimeout(function(){
					this.rendered && this.updateSize();
				}.bind(this), 1);
			}
		},

		updateSize: function() {
			var width = this.getInnerWidth() - this.body.getPadding("lr") - this.labelWidth - 25;
			
			this.getFields().each(function(item) {
				if (item instanceof Ext.ux.form.TranslationField || item.translation){ 
					return; 
				}
				
				item.setWidth(width);
			});

			// Update translation box
			this.translation && this.translation.updateSize();
			
			// Set height of textareas
			// var height = this.getInnerHeight() - this.body.getPadding("tb") - 60;
			var height = this.getInnerHeight();
			
			// Seperate all items into Textareas and others
			var partitions = [].concat(this.getFields(), this.getLabels()).partition(function(item) {
				return (item instanceof Ext.form.TextArea) || (item instanceof Ext.ux.form.RichtextEditor);
			});

			var textareas = partitions[0];
			var remainder = partitions[1];
			
			if (textareas.length === 0){ 
				return; 
			}
			
			// Subtract height from others
			remainder.each(function(r){ 
				if (!r.rendered || !r.el) {
					return;
				}
				
				var el = r instanceof Ext.form.TriggerField ? r.container : r.el;
				height -= el.getHeight() + el.getPadding("tb") + el.getMargins("tb");
				// height = height - (r.getInnerHeight ? r.getInnerHeight() : el.getHeight());
			});
			
			var textHeight = Math.max(height / textareas.length, 160);
			
			// Set height to Textareas or richtext editors
			textareas.each(function(text){
				if (text.translation){
					text.setHeight(textHeight);
					text.translation.origin && text.translation.origin.setHeight(textHeight+3);
				} else {
					text.setSize(width, textHeight);					
				}
			});
		},

		createTranslationForm: function(items, data) {
			if(!items || items.length === 0) {
				return;
			}

			this.translation = new Ext.ux.form.TranslationForm({
				items: items,
				languages: this.languages,
				language: this.languages.first(),
				editing: this.editing,
				originData: data
			});

			this.add(this.translation);
		},

		addItems: function(data) {
			var languages = this.languages;
			
			var standard = this.createStandardFields(data);
			var additional = this.createAdditionalFields(data);
			var all = standard.concat(additional);
			
			var that = this;

			var partition = all.partition(function(field) {
				// doing this here in order to not 
				// reiterate the list
				that.addField(field);
				
				return languages.length > 1 && (field.multilanguage || field.dataField == "glossaryLinks");
			});
			
			var multilanguage  = partition[0];
			var singlelanguage = partition[1];
						
			// Add the standard fields
			[].without.apply(standard, multilanguage).each(function(field) {
				that.add(field);
			});
						
			// Add translation panel
			this.createTranslationForm(multilanguage, data);
			
			// Add the rest fields
			[].without.apply(singlelanguage, standard).each(function(field, i) {
				if (i == 0 && multilanguage.length > 0){
					that.add(new Ext.Panel({
						html: Ext.ux.getI18N("glossary.multilanguage.non_attributes"),
						border: false,
						cls: "y-translation-hint",
						style: "width: auto",
						autoWidth: true
					}));
				}

				that.add(field);
			});
		},

		createStandardFields: function(data) {
			var fields = [];
			
			// Label
			var label = this.getLabel();
			fields.push(label);
			
			// Category
			var category = this.getCategory(data);
			var categoryField = this.getCategorySelector(category);
			fields.push(categoryField);
			
			// Title
			var title = this.generateTitleField(data.title);
			title.values = this.getValuesForMultilanguage(data, "title");
			this.getTitleField = function() {
				return title;
			};
			fields.push(title);
			
			// Glossary Links
			var links = this.getLinkListField(data.glossaryLinks);
			this.getGlossaryLinksField = function() {
				return links;
			};
			fields.push(links);
			
			// Description
			var descriptionField = this.getDescriptionField(data); 
			fields.push(descriptionField);
			
			// Attachments
			var attachmentsField = this.getAttachmentsField(data.attachments); 
			attachmentsField.values = this.getValuesForMultilanguage(data, "attachments", function(v) {
				return v.clone();
			});
			fields.push(attachmentsField);
			
			return fields;
		},

		getLabel: function() {
			var text = Ext.ux.getI18N("glossary.new.create");
			
			if(this.store) {
				text = Ext.ux.getI18N("glossary.edit.description");
			}
			
			return new Ext.Panel({
				html	: text,
				border	: false,
				cls: "y-translation-hint"
			});
		},

		getCategorySelector: function(category) {
			var that = this;

			return new Signavio.glossary.CategorySelector({
				value: category,
				categoryStore: that.categoryStore,
				listeners: {
					change: function(t,value){
						that.onCategoryChange(value);
					},
					select: function(t,value){
						that.onCategoryChange(value.get("id"));
					}
				}
			});
		},

		/**
		 * Parse to the new format no matter what
		 */
		getCategory: function(data) {
			// Include fallback to parse the old format, just in case, y'know...?
			var category = (data.category || this.currentCategory).split("=").last();
			
			return category.startsWith(PREFIX) ? category : PREFIX + category;
		},

		generateTitleField: function(title) {
			var that = this;

			return Ext.ux.form.FieldFactory.generate("MetaDataGlossaryLink", {
				dataField: "title",
				fieldLabel: Ext.ux.getI18N("glossary.view.title"),
				value: title,
				multilanguage: true,
				showEmptyItems: true,
				forceSelection: false,
				hiddenItems: this.store && this.store.id ? [this.store.id] : [],
				languages: this.languages,
				language: this.languages.first(),
				getSearchQuery: function(){
					var me = this,
						value = " " + this.getRawValue().slice(0, this.getCursorPosition()).toLowerCase().replace(/\s+/g, " ") + " ";
					var records = that.getGlossaryLinksField().records || [];
					var lastWords = records.map(function(r){ 
						var title = me.translate(r.get("rep"), "title") || "";
						return " " + title.trim().split(/\s+/g).last().toLowerCase() + " "; 
					}).uniq();
					var lastIndex = 0;
					
					lastWords.each(function(word){
						lastIndex = value.include(word) ? Math.max(value.indexOf(word)+word.length, lastIndex) : lastIndex;
					});
					
					return value.slice(lastIndex).trim();
				},
				getValue: function(){
					return this.getRawValue();
				},
				onNewRecord: function(record){
					that.getGlossaryLinksField().onSelect(record);
					delete this.records;
				}
			});
		},

		getAttachmentsField: function(attachments) {
			var attachmentTemplate = new Ext.XTemplate('<ol>'
					+'<tpl for=".">'
						+'<li>'
							+'<a href="{url}" target="_blank" tabindex="-1">'
								+'{[Signavio.Utils.escapeHTML(values.label || values.url)]}'
							+'</a> '
							+'<span class="x-smaller">'
								+'(<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">'
									+'{[Ext.ux.getI18N("btnRemove")]}'
								+'</a>)'
							+'</span>'
						+'</li>'
					+'</tpl>'
				+'</ol>');
			
			return Ext.ux.form.FieldFactory.generate("MetaDataUrlList", {
				dataField		: "attachments",
				fieldLabel		: Ext.ux.getI18N("glossary.view.attachments"),
				lineWrap		: true,
				multilanguage	: true,
				data			: attachments||[],
				itemFieldTpl	: attachmentTemplate
				
			});
		},

		getDescriptionField: function(data) {
			var description = data.description;
			var formats = data.formats;
			var that = this;
			
			if(this.richtextEnabled	&& formats && formats.description instanceof Array) {
				description = Ext.ux.Richtext.encode(description, formats.description);
			}
						
			// Encode all descriptions in all languages
			var descriptions = this.getValuesForMultilanguage(data, "description");
			if (this.richtextEnabled){
				$H(descriptions).each(function(pair){
					var key = "description";

					if(that.languages.first() && pair.key !== that.languages.first()) {
						key = key + "_" + pair.key;
					}

					if (formats[key] instanceof Array){
						descriptions[pair.key] = Ext.ux.Richtext.encode(descriptions[pair.key], formats[key]);
					}
				});
			}		
			
			return Ext.ux.form.FieldFactory.generate("MetaDataStringInfo", {
				dataField		: "description",
				fieldLabel		: Ext.ux.getI18N("glossary.view.description"),
				lineWrap		: true,
				multilanguage	: true,
				richtextEnabled	: this.richtextEnabled,
				value			: description,
				values			: descriptions
			});
		},

		getLinkListField: function(links) {
			var that = this;

			return Ext.ux.form.FieldFactory.generate("MetaDataGlossaryLinkList", {
				dataField	: "glossaryLinks",
				hideInput	: true,
				fieldLabel	: "", //Signavio.I18N.Glossary.View.linkedGlossaryItems,
				labelSeparator: "",
				records		: links || [],
				languages	: this.languages,
				language	: this.languages.first(),
				updateView	: function(){
					var empty = this.records.length === 0;

					this.container.parent().first().setDisplayed(true);
					this.container.parent(".x-form-item").setDisplayed(!empty);
					
					// shouldn't be necessary anymore as title field counts to multilanguage section
					that.getTitleField().container.parent()[empty ? "removeClass" : "addClass"]("x-no-margin");
				},		
				getValue: function(){
					var value = (this.records || []).map(function(rec){ 
						return rec.get("href") || rec.get("rep");
					});
					
					var exclude = (that.getTitleField().getValue() || "").strip();
				
					return value.findAll(function(v){
						// TODO: Use multilanguage
						return typeof v === "string" || (!exclude || !v.title !== exclude);
					});
				}
			});
		},

		createAdditionalFields: function(data) {
			var category = this.getCategory(data),
				metaData = data.metaDataValues || {},
				formats = data.formats || {},
				me = this;
			
			var fields = [];
			
			this.getMetaData(category).each(function(meta){
				var metaInfo = meta.get("rep");
				var className = metaInfo.type + (!!metaInfo.isList ? "List" : "");
				var value = metaData[metaInfo.id] || metaInfo.defaultValue || "";
				
				if (value instanceof Array){
					value = value.clone();
				} else if (value instanceof Object){
					value = Object.clone(value);
				}
				
				/* Richtext */
				if (this.richtextEnabled
						&& formats[metaInfo.id] instanceof Array 
						&& metaData[metaInfo.id]) {
					
					value = Ext.ux.Richtext.encode(metaData[metaInfo.id], formats[metaInfo.id]);
				}
				
				var defaultValue = "";
				
				if(metaInfo.defaultValue !== metaData[metaInfo.id]) {
					defaultValue = metaInfo.defaultValue || defaultValue;
				}
				
				
				// Encode all values in all languages
				var values = this.getValuesForMultilanguage(metaData, metaInfo.id);
				if (this.richtextEnabled){
					$H(values).each(function(pair){
						var key = metaInfo.id+(!me.languages.first() || pair.key == me.languages.first() ? "" : "_"+pair.key);
						if (formats[key] instanceof Array){
							values[pair.key] = Ext.ux.Richtext.encode(values[pair.key], formats[key]);
						}
					});
				}
				
				var field = Ext.ux.form.FieldFactory.generate(className, Ext.apply({
					dataField	: "metaDataValues." + metaInfo.id,
					fieldLabel	: metaInfo.name,
					richtextEnabled	: this.richtextEnabled,
					//emptyText	: "",
					defaultValue: defaultValue,
					values		: values,
					languages	: this.languages,
					linkableType: metaInfo.category? (metaInfo.category.startsWith(PREFIX)? metaInfo.category : (PREFIX + metaInfo.category)) : "",
					language	: this.languages.first()
				}, metaInfo, ["MetaDataStringInfoList"].include(className) ? {data: value || []} : {value: value}));
				
				fields.push(field);
			}.bind(this));
			
			return fields;
		},

		getValuesFor: function(data, key, fn){
			var obj = {};
			var fn = fn ? fn : Prototype.K;

			$H(data).each(function(pair){
				// Attention: Key must not have an _ as character
				if (pair.key === key || pair.key.startsWith(key + "_")) {
					obj[pair.key] = fn(pair.value);
				}
			});

			return obj;
		},

		getValuesForMultilanguage: function(data, key, fn){
			var obj = {};
			var defaultLanguage = this.languages.first();
			
			$H(Signavio.glossary.utils.getValuesFor(data, key, fn)).each(function(pair){
				obj[pair.key == key ? defaultLanguage||key : pair.key.replace(key+"_", "")] = pair.value;
			});

			return obj;
		},
		
		getBaseParams: function(){
			return {
				language:"en", 
				title:"", 
				description:""
			};
		},

		validateValue: function(value){
			if (typeof value !== "string"){
				return value;
			}
			
			// Replace invalid characters (see https://github.com/douglascrockford/JSON-js/blob/master/json2.js for more information)
			return value.replace(/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, '');
		},

		extractParams: function(items){
			
			var params = this.getBaseParams();
			var me = this;
			var defaultLanguage = this.languages.first();
			
			items.each(function(item){
				
				if (!item.dataField){ 
					return;
				}
				
				// Get the language for the item
				var lang = item.multilanguage && item.translation && item.ownerCt.ownerCt.ownerCt instanceof Ext.ux.form.TranslationForm && item.translation.language;
				if (lang && lang == defaultLanguage){
					lang = false;
				}
				
				// Define the default language
				var values = {};
				values[lang||defaultLanguage] = me.validateValue(item.getValue());
				
				if (item.translation instanceof Ext.ux.form.TranslationField && item.translation.values){
					values = Ext.apply({}, values, item.translation.values);
				}
				
				
				$H(values).each(function(pair){
					var language = pair.key != "undefined" ? pair.key : undefined, 
						value = pair.value;
					

					//if (me.valueHasChanged(value, item)) { // TODO: Check for changes
						
						// Get the key and property
						var key = item.dataField+(language && language !== defaultLanguage?"_"+language:""),
							property = params;
						
						// For complex properties, try to find the right one
						if (item.dataField.include(".")){
							var keys = item.dataField.split(".");
							// If the property and the structure defined by the
							// different keys, does not exist in the current
							// params, create it.
							keys.slice(0, keys.length - 1).each(function(key){ 
								if (!property[key]){ 
									property[key] = {}; 
								} 
								property = property[key];
							});
							key = keys.last()+(language && language !== defaultLanguage?"_"+language:"");
						}
						
						if (!(item instanceof Ext.ux.form.RichtextEditor)) {
							property[key] = me.validateValue(value);
						} else {
							
							var doc = document.createElement("body");
							doc.innerHTML = value;
							var decoded = Ext.ux.Richtext.decode(doc);
							if (decoded.text.trim()){
								property[key] = decoded.text;
								// If no formats are defined, create a new container
								params.formats = params.formats || {};
								// Save the formats for each data field
								params.formats[key] = decoded.format;
							}else{
								// If no formats are defined, create a new container
								params.formats = params.formats || {};
								params.formats[key] = [];
								// set empty description
								property[key] = "";
							}
						}
					//}
					
				});
			});
			
			// adding defaults
			params.formats = params.formats || {};
			params.metaDataValues = params.metaDataValues || {};
			params.attachments = params.attachments || [];
			params.glossaryLinks = params.glossaryLinks || [];
			
			return params;
		}

	});

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
ns("glossary.utils");

(function() {

	Signavio.glossary.utils.getValuesFor = function(data, key, fn){
		var obj = {};

		fn = fn ? fn : Prototype.K;

		$H(data).each(function(pair){
			// Attention: Key must not have an _ as character
			if (pair.key === key || pair.key.startsWith(key + "_")) {
				obj[pair.key] = fn(pair.value);
			}
		});

		return obj;
	};

}());
/**
 * Copyright (c) 2012
 * Lukas Brand
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

/**
 * Define namespaces
 */
if ("undefined" == typeof window.Ext){ window.Ext = {}; }
if ("undefined" == typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" == typeof Ext.ux.grid){ Ext.ux.grid = {}; }

(function() {    
	Ext.ux.grid.IKSEditorGridPanel = function(config) {
		Ext.apply(this, config);
		Ext.ux.grid.IKSEditorGridPanel.superclass.constructor.call(this, config);
	};
	
	Ext.ux.grid.IKSEditorGridPanel = Ext.extend(Ext.grid.EditorGridPanel, {
		
		startEditing : function(row, col, typeValue, trueOldValue) {
			this.stopEditing();
			if (this.colModel.isCellEditable(col, row)) {
				this.view.ensureVisible(row, col, true);
				var r = this.store.getAt(row);
				var field = this.colModel.getDataIndex(col);
				
				var columnConfig = this.colModel.getColumnById(col)||this.colModel.config[col];
				
				var value = r.data[field];
				
				var e = {
					grid : this,
					record : r,
					field : field.field || field,
					value : value,
					row : row,
					column : col,
					cancel : false
				};
				if (this.fireEvent("beforeedit", e) !== false && !e.cancel) {
					this.editing = true;
					var ed = this.colModel.getCellEditor(col, row);
					if ("undefined" === typeof (ed)) {
						return;
					}
					if (!ed.rendered) {
						ed.initialOpen = true;
						
						ed.render(this.view.getEditorParent(ed));
					}
					(function() {
						// complex but required for focus issues in safari, ie and opera
						if (!this.editing) {
							return;
						}
						ed.row = row;
						ed.col = col;
						ed.record = r;
						ed.trueOldValue = trueOldValue || r.data[field];
						ed.selectionModel = this.selModel;
						if (ed.trueOldValue instanceof Array) {
							ed.trueOldValue = ed.trueOldValue.clone();
						}
						ed.on("complete", this.onEditComplete, this, {
							single : true
						});
						ed.on("specialkey", this.selModel.onEditorKey, this.selModel);
						
						this.activeEditor = ed;
						var v;
						if (ed.field.requiresComplexData) {
							v = {
								existing : this.preEditValue(r, field),
								typed : typeValue ? typeValue : ""
							};
						}
						
						else {
							if (typeValue === undefined) {
								v = this.preEditValue(r, field);
							}
							else {
								v = typeValue;
							}
						}
						
						// If cell is empty and a default value exists
						if (v === "" && columnConfig.defaultValue) {
							v = columnConfig.defaultValue;
						}
						
						ed.startEdit(this.view.getCell(row, col), v);
					}).defer(50, this);
					
					// Fix for cursor position on initial editor open via typing
					if (ed.initialOpen) {
						window.setTimeout(function() {
							var rv = ed.field.el.dom.value;
							var field = ed.field.field||ed.field;
							field.reset();
							field.setRawValue(rv);
							delete ed.initialOpen;
						}, 50);
					}
					
				}
			}
		},
		
		onEditComplete : function(ed, value, startValue) {
			Ext.grid.EditorGridPanel.prototype.onEditComplete.call(this, ed, value, ed.trueOldValue);
		}
	});
}());
/**
 * Copyright (c) 2013
 * Lukas Brand, Christian Wiggert
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

/**
 * Define namespaces
 */
if ("undefined" == typeof window.Ext){ window.Ext = {}; }
if ("undefined" == typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" == typeof Ext.ux.grid){ Ext.ux.grid = {}; }

(function() {

    /**
     * This field class works in combination with the NestableEditorGridPanel and allows
     * to embed another NestableEditorGridPanel within an existing one. 
     * @param config configuration for the NestedGridField
     * Possible configuration options:
     * - {String} fieldId : an identifier for this field
     * - {String} emptyText : a text that will be shown when there is no content to render or the field is expanded
     * - {Boolean} noText : indicates that no content shall be rendered
     * - {Ext.XTemplate}||{Ext.Template}||{String} renderTpl : a template that defines the content that will be rendered
     * @param store the store that contains the contents for the nested grid, it will be used for the nested grid
     * To work properly, the store should contain a field 'parentId' which references the 'id' of the parent row in the parent grid.
     * Furthermore, a field 'id' should be defined which identifies every row in the store.
     * @param colModel the ColumnModel for the nested grid
     * @param gridConfig the configuration for the nested grid
     **/
    Ext.ux.form.NestedGridField = function(config, store, colModel, gridConfig) {
        var defaultValues = {
            id          : Ext.id(),
            fieldId     : 'source',
            emptyText   : Ext.ux.getI18N('NEGP.nestedField.emptyText')
        };
        Ext.apply(this, config, defaultValues);
        this.store = store;
        this.colModel = colModel;
        this.initialColConfig = this.colModel.config;
        this.nestedGridFields = colModel.config.findAll(function(entry) {
            return entry instanceof Ext.ux.form.NestedGridField;
        });
        this.gridConfig = gridConfig || {};
        if (!this.gridConfig.emptyText) {
            this.gridConfig.emptyText = config.emptyText;
        }
        this.renderer = this.renderer.createDelegate(this);
        Ext.ux.form.NestedGridField.superclass.constructor.call(this, config);
    };

    Ext.extend(Ext.ux.form.NestedGridField, Ext.form.Field, {
        init : function(grid) {
            this.grid = grid;
            this.grid.on("render", function() {
                var view = this.grid.getView();
                view.mainBody.on("click", this.onClick, this);
            }, this);
        },

        onClick : function(e, t) {
            if (!Ext.get(t).hasClass("x-grid3-" + this.fieldId + "-" + this.id)) {
                // in some browser the pointer-events does not work, so check if the click happened on a child element
                var parent = Ext.fly(t).findParent(".x-grid3-" + this.fieldId + "-" + this.id, 3, true);
                if (parent) {
                    t = parent;
                }
            }
            if (Ext.get(t).hasClass("x-grid3-" + this.fieldId + "-" + this.id)) {
                e.stopEvent();

                // Remove any existing confirm hints
//              this.plugin.clearActiveConfirmHints();

                var inner = Ext.get(t).parent(".x-grid3-cell-inner");
                var cell = inner.parent(".x-grid3-cell");
                var row = cell.parent(".x-grid3-row-table");

                var index = this.grid.getView().findRowIndex(row.dom);
                // Get the active record
                var record = this.grid.store.getAt(index);
                var level = (this.grid.level || 0);

                // Find expanded nodes in the control column and close them
                Ext.DomQuery.select(".y-nestedgrid-parent .expanded").without(cell.dom).each(function(node) {
                    var $node = Ext.fly(node);
                    var m = $node.dom.className.match(/hierarchy-level-(\d+)/);
                    if (m && m[1] > level) {
                        $node.removeClass("expanded");
                        $node.removeClass(m[0]);
                    }
                });

                cell.toggleClass("expanded");

                if (cell.hasClass("expanded")) {

                    var mask = this.grid.getView().el.mask();
                    var ms = mask.dom.style;
                    ms["backgroundColor"] = "#FFFFFF";
                    ms["zIndex"] = 2 * (this.grid.level || 0) + 1; // instead of static 1
                    ms["opacity"] = "0.6";

                    // Close the control grid when the mask over the risk grid was clicked
                    mask.on("click", function() {
                        cell.removeClass("expanded");
                        this.hideNestedGrid(row);
                    }.bind(this));

                    cell.originalHeight = cell.getHeight();

                    // we limit the content of the store to the values belonging to the parent row
                    this.filterStore(record.get('id'));

                    this.nestedGrid = this.grid.getNestedGrid(this.fieldId, Ext.apply(this.gridConfig, {
                        store       : this.store,
                        cm          : this.colModel,
                        sourceCell  : inner,
                        cell        : cell,
                        row         : row,
                        parentId    : record.get("id"),
                        value       : this.value,
                        nestedField : this,
                        doResize    : function(parentGrid) {
                            var pBox = parentGrid.el.getBox();
                            var oldBox = this.getBox();

                            // Align the grid nicely inside the parentGrid
                            this.updateBox(Ext.apply(oldBox, {
                                width   : Math.round(pBox.width - 50),
                                x       : Math.round(pBox.x + 40)
                            }));
                        }
                    }));

                    this.nestedGrid.doResize(this.grid);

                    var s = this.nestedGrid.el.dom.style;

                    s["zIndex"] = 2 * (this.nestedGrid.level || 1); // instead of static 1
                    s["border"] = "1px solid #888888";
                    s["borderRadius"] = "1px";
                    s["boxShadow"] = "0px 6px 8px -6px silver";
                    s["position"] = "absolute";

                    // adjust the z-indices of the source field and its grid so the styling will be correct
                    inner.dom.style["zIndex"] = 2 * (this.nestedGrid.level || 1) + 1;
                    this.grid.el.dom.style["zIndex"] = "";
                    cell.addClass("hierarchy-level-" + (this.nestedGrid.level || 1));

                    this.nestedGrid.updateSourceCell();

                    // Show the control grid
                    this.nestedGrid.show();

                    this.nestedGrid.adjustCellHeight();

                    // Reposition the grid
                    this.nestedGrid.el.alignTo(inner, "tl-bl", [0, -1]);
                    this.nestedGrid.doResize(this.grid);
                    this.grid.syncShadow();

                } else if (this.nestedGrid && this.nestedGrid.isVisible()) {

                    this.hideNestedGrid(row);
                }
            }
        },

        initColConfig : function() {
            var config = [];
            this.initialColConfig.each(function(col) {
                config.push(Object.clone(col));
            });
            this.colModel.setConfig(config);
        },

        removeRowsWithParentId : function(parentId) {
            if (this.store && parentId) {
                this.unfilterStore();
                this.filterStore(parentId);
                var ids = [];
                var that = this;
                this.store.each(function(r) {
                    ids.push(r.get('id'));
                    that.store.remove(r);
                });
                // recursively remove the rows in the nested stores
                this.nestedGridFields.each(function(field) {
                    ids.each(function(id) {
                        field.removeRowsWithParentId(id);
                    });
                });
                this.unfilterStore();
                this.store.commitChanges();
            }
        },

        filterStore : function(parentId) {
            if (this.store && parentId) {
                this.store.filter('parentId', parentId);
                this.store.currentParentId = parentId;
            }
        },

        unfilterStore : function() {
            this.store.clearFilter();
            delete this.store.currentParentId;
        },

        hideNestedGrid : function(row) {
            // Hide all child grids
            this.nestedGrid.hideNestedGrids();
            // Hide the grid
            this.nestedGrid.hide();
            // Update the control count in the cell
            this.nestedGrid.updateSourceCell();
            var parentId = this.nestedGrid.parentId;

            // Remove the mask
            this.grid.getView().el.unmask();

            this.grid.detachNestedGrid(this.fieldId);
            delete this.nestedGrid;

            this.unfilterStore();

            this.refreshRow(parentId);
            // reset the z-index of the parent grid
            this.grid.el.dom.style['zIndex'] = 2 * (this.grid.level || 0);

            // Reset the size of the current row
            row.dom.style["height"] = "";
            this.grid.syncShadow();
        },

        refreshRow : function(parentId) {
            if (Ext.isDefined(this.grid.store)) {
                var r = this.grid.store.get('id', parentId);
                if(Ext.isDefined(r)) {
                    this.grid.getView().refreshRow(r);
                }
            }
        },

        getEmptyValue : function() {
            return ["<span class='y-empty-text'>",
                Signavio.Utils.escapeHTML(this.emptyText),
                " <img src='/images/glyphicons/small/more.png'/>",
                "</span>"].join("");
        },

        renderer : function(v, p, record) {
            p.css += 'x-grid3-nested';
            if (this.noText) {
                v = "&nbsp;<span class='y-empty-text'><img src='/images/glyphicons/small/more.png'/></span>";
            } else {
                if (this.store) {
                    v = this.store.getRange().findAll(function(row) {return row.get('parentId') === record.get('id');}).length;
                } else {
                    v = 0;
                }

                if (v === 0) {
                    v = this.getEmptyValue();
                } else {
                    if (Ext.isDefined(this.renderTpl)) {
                        var values = this.store.getRange().findAll(function(row) {return row.get('parentId') === record.get('id');});
                        if (this.renderTpl instanceof Ext.Template) {
                            v = this.renderTpl.apply({'records': values});
                        } else {
                            v = new Ext.XTemplate(this.renderTpl).apply({'records': values});
                        }
                    }

                    // If a value exists, render an edit icon
                    v += " <span class='y-empty-text'><img src='/images/glyphicons/small/more.png'/></span>";

                }
            }

            return ['<div class="x-grid3-nested-col x-grid3-',
                    this.fieldId,
                    '-',
                    this.id,
                    '"><div class="y-cell-value',
                    (this.noText ? ' y-no-text' : ''),
                    '">',
                        // The cell value
                        v,
                    '</div></div>'].join("");
        }
    });


    /**
     * This is the NestableEditorGridPanel, an EditorGridPanel which can contain
     * more nested instances of NestableEditorGridPanels. Another grid can be embedded
     * by defining a NestedGridField in the ColumnModel. 
     * @param config the configuration for this grid
     * The options are inherited from Ext.grid.EditorGridPanel and extended by the following options:
     * - {String} addNewRowText     : the text that shall be shown in the add new row line
     * - {JSONObject} defaultValues : an object where you can define a default value for every field in the store
     * - {JSONArray} additionalIds  : an array with ids of fields that shall be assigned a generated id if a new row is added
     **/
    Ext.ux.grid.NestableEditorGridPanel = function(config) {
        this.view = this.getStripeView(),
        this.nestedGrids = {};
        var cm = config.cm || config.colModel;
        // add the NestedGridFields to the list of plugins,
        // because it is required for their full functionality
        this.nestedGridFields = cm.config.findAll(function(entry) {
            return entry instanceof Ext.ux.form.NestedGridField;
        });
        config.plugins = (config.plugins || []).concat(this.nestedGridFields);
        if (!config.cls && !config.parentGrid) {
            config.cls = 'y-nestedgrid-main';
        }
        if (!Ext.isDefined(config.level) || !config.parentGrid) {
            this.level = 0;
        }
        Ext.apply(this, config);
        Ext.ux.grid.NestableEditorGridPanel.superclass.constructor.call(this, config);
        if (Ext.isDefined(this.selModel)) {
            // seems to be necessary to catch special keys in the editor
            this.selModel.grid = this;
        }
    };

    Ext.extend(Ext.ux.grid.NestableEditorGridPanel, Ext.grid.EditorGridPanel, {

        /* taken from IKSEditorGridPanel */
        startEditing : function(row, col, typeValue, trueOldValue) {
            this.stopEditing();
            if (this.colModel.isCellEditable(col, row)) {
                this.view.ensureVisible(row, col, true);
                var r = this.store.getAt(row);
                var field = this.colModel.getDataIndex(col);

                var columnConfig = this.colModel.getColumnById(col)||this.colModel.config[col];

                var value = r.data[field];

                var e = {
                    grid : this,
                    record : r,
                    field : field.field || field,
                    value : value,
                    row : row,
                    column : col,
                    cancel : false
                };
                if (this.fireEvent("beforeedit", e) !== false && !e.cancel) {
                    this.editing = true;
                    var ed = this.colModel.getCellEditor(col, row);
                    if ("undefined" === typeof (ed)) {
                        return;
                    }
                    if (!ed.rendered) {
                        ed.initialOpen = true;

                        ed.render(this.view.getEditorParent(ed));
                    }
                    (function() {
                        // complex but required for focus issues in safari, ie and opera
                        if (!this.editing) {
                            return;
                        }
                        ed.row = row;
                        ed.col = col;
                        ed.record = r;
                        ed.trueOldValue = trueOldValue || r.data[field];
                        ed.selectionModel = this.selModel;
                        if (ed.trueOldValue instanceof Array) {
                            ed.trueOldValue = ed.trueOldValue.clone();
                        }
                        ed.on("complete", this.onEditComplete, this, {
                            single : true
                        });
                        ed.on("specialkey", this.selModel.onEditorKey, this.selModel);

                        this.activeEditor = ed;
                        var v;
                        if (ed.field.requiresComplexData) {
                            v = {
                                existing : this.preEditValue(r, field),
                                typed : typeValue ? typeValue : ""
                            };
                        } else {
                            if (typeValue === undefined) {
                                v = this.preEditValue(r, field);
                            } else {
                                v = typeValue;
                            }
                        }

                        // If cell is empty and a default value exists
                        if (v === "" && columnConfig.defaultValue) {
                            v = columnConfig.defaultValue;
                        }

                        ed.startEdit(this.view.getCell(row, col), v);
                    }).defer(50, this);

                }
            }
        },

        onRender : function(parent) {
            Ext.ux.grid.NestableEditorGridPanel.superclass.onRender.apply(this, arguments);
            if (!this.parentGrid) {
                parent.addClass('y-nestedgrid-parent');
            }
        },

        onEditComplete : function(ed, value, startValue) {
            // Overwritten version of Ext.grid.EditorGridPanel.prototype.onEditComplete.
            // Support for complex field values was added.
            startValue = ed.trueOldValue;

            this.editing = false;
            this.activeEditor = null;
            ed.un("specialkey", this.selModel.onEditorKey, this.selModel);
            var r = ed.record;
            var field = this.colModel.getDataIndex(ed.col);
            value = this.postEditValue(value, startValue, r, field);
            // startValue might be a complex object
            // assume then it has an ID and run a check against the ID
            if(String(value) !== (typeof startValue === 'object' ? String(startValue.id) : String(startValue) )) {
                var e = {
                    grid: this,
                    record: r,
                    field: field,
                    originalValue: startValue,
                    value: value,
                    row: ed.row,
                    column: ed.col,
                    cancel:false
                };
                if(this.fireEvent("validateedit", e) !== false && !e.cancel){
                    r.set(field, e.value);
                    delete e.cancel;
                    this.fireEvent("afteredit", e);
                }
            }
            this.view.focusCell(ed.row, ed.col);
        },

        /* --- */

        /**
         * Creates a new nested grid and applies the given config. The grid is rendered to the container of this grid.
         * @param {JSONObject} config grid configuration object
         */
        createNestedGrid : function(config) {
            var grid = new Ext.ux.grid.NestableEditorGridPanel(Ext.apply({
                    cls             : 'y-nestedgrid',
                    renderTo        : this.container,
                    border          : false,
                    enableHdMenu    : false,
                    enableColumnMove: false,
                    minColumnWidth  : 100,
                    clicksToEdit    : 1,
                    autoHeight      : true,
                    sm              : this.getSelectionModel(),
                    parentGrid      : this,
                    level           : this.level + 1
                }, config));

            if (Ext.isIE) {
                grid.on("show", function() {
                    this.el.repaint();
                });
            }

            grid.on("afteredit", function() {
                this.store.commitChanges();
            });

            return grid;
        },

        /**
         * Returns a nested grid for the given fieldId. If no respective grid exists yet, a new one will 
         * be created. The given config will be used to initialize the new grid. If there is already a grid
         * it will be initialized with the given config and shown in the parent grids container.
         * @param fieldId ID of the field, the nested grid is connected to
         * @param config the configuration for the nested grid
         **/
        getNestedGrid : function(fieldId, config) {
            var grid = this.nestedGrids[fieldId];
            if (!Ext.isDefined(grid) || grid.el.dom.childNodes.length === 0) {
                // in case of IE the grid might have no child nodes after detaching, so create a new one
                grid = this.createNestedGrid(config);
                this.nestedGrids[fieldId] = grid;
                return grid;
            }
            // update the grid with the new config 
            Ext.apply(grid, config);
            if (grid.detached) {
                this.container.appendChild(grid.el);
                delete grid.detached;
            }
            return grid;
        },

        /**
         * Removes the nested grid for the given field ID from the DOM.
         * 
         * @param fieldId
         */
        detachNestedGrid : function(fieldId) {
            if (this.nestedGrids[fieldId]) {
                var grid = this.nestedGrids[fieldId];
                grid.detached = true;
                grid.el.remove();
            }
        },

        /**
         * Recursively hides all nested grids which are still expanded.
         **/
        hideNestedGrids : function() {
            var that = this;
            Object.keys(this.nestedGrids).each(function(gridId) {
                var grid = that.nestedGrids[gridId];
                if (!grid.detached) {
                    grid.nestedField.hideNestedGrid(grid.row);
                }
            });
        },

        /**
         * Returns a new Ext.grid.GridView with vertical stripes and fitted columns
         */
        getStripeView : function() {
            var me = this;
            return new Ext.grid.GridView({

                forceFit        : true,
                autoFill        : true,
                scrollOffset    : 0,

                findCell : function(el) {
                    if (!el) {
                        return false;
                    }
                    // increased the max depth from 3 to 5 because of the nested content
                    return this.fly(el).findParent(this.cellSelector, 5);
                },

                updateColumnCss: function(){
                    [].concat(this.innerHd, $A(this.getRows())).each(function(row){
                        var i = 0;
                        Ext.get(row).select("td{display!=none}").each(function(cell){
                            cell[(i++%2) === 0 ? "addClass" : "removeClass"]("x-colum-odd");
                        });
                    });
                },

                // @overwrite Update css classes for the row
                updateColumnHidden: function(){
                    var res = Ext.grid.GridView.prototype.updateColumnHidden.apply(this, arguments);
                    this.updateColumnCss();
                    return res;
                },
                // @overwrite Update css classes for the row
                processRows: function(){
                    var res = Ext.grid.GridView.prototype.processRows.apply(this, arguments);
                    this.updateColumnCss();
                    return res;
                },
                // @overwrite Update css classes for the row
                refreshRow: function(){
                    var nestedOpened = Object.keys(me.nestedGrids).any(function(key) {
                        return !!!me.nestedGrids[key].detached;
                    });
                    if (!nestedOpened) {
                        // TODO: change this, by calling the correct adjust height method
                        var res = Ext.grid.GridView.prototype.refreshRow.apply(this, arguments);
                        this.updateColumnCss();
                        return res;
                    }
                },

                /**
                 * Extend the renderUI method to add an addRow-button after the real grid
                 */
                renderUI : function() {
                    Ext.grid.GridView.prototype.renderUI.apply(this, arguments);

                    var addNode = document.createElement("div");
                    Ext.get(addNode).addClass("y-add-row");
                    addNode.innerHTML = ["<div unselectable='on'></div><span class='y-add-row-desc'>",
                                         me.addNewRowText ? Signavio.Utils.escapeHTML(me.addNewRowText) : "Add new row",
                                         "</span>"].join("");

                    this.mainBody.dom.parentNode.insertBefore(addNode, this.mainBody.dom.nextSibling);

                    // Add a new row on click
                    Ext.fly(addNode).on("click", this.grid.addNewRow.bind(this.grid));
                },

                getColumnTooltip : function(i){
                    var tt = this.cm.getColumnTooltip(i);
                    if(tt){
                        return 'title="'+tt+'"';
                    }
                    return "";
                }
            });
        },

        getSelectionModel : function() {
            var selModel = new Ext.grid.CellSelectionModel({
                listeners : {
                    // Handle clicks of the row remover
                    beforecellselect : function(s, r, c) {
                        if (c === 0) {
                            var conf = this.colModel.config[0];
                            // the first element might not be removeable (but only if there is just one element)
                            if (r === 0 && Ext.isDefined(conf) && !!conf.firstHidden && this.store.getCount() === 1) {
                                return false;
                            }
                            this.clearActiveConfirmHints();
                            this.confirmRowRemoval(r, this.view.getCell(r,c).firstChild);

                            return false;
                        }
                        return true;
                    }.bind(this)
                }
            });

            return selModel;
        },

        clearActiveConfirmHints : function() {
            if (this.confirmationDialog) {
                this.confirmationDialog.remove();
                delete this.confirmationDialog;
            }
        },

        /**
         * Displays a confirmation for removing a row, handles the actual removal of rows and attached controls when deleting a risk.
         */
        confirmRowRemoval : function(row, cell) {
            var record = this.store.getAt(row);

            // Check if the record is empty
            var isEmpty = !$H(record.data).any(function(p) {
                return p.key !== "id" && p.value;
            });

            // Create a new hint to ask for removal
            var confirmation = document.createElement("div");
            confirmation.innerHTML = "<span>"+ Ext.ux.getI18N('NEGP.delete') + "</span><a class='y-delete-confirm-yes' href='#'>" + Ext.ux.getI18N('NEGP.yes') + "</a><a class='y-delete-confirm-no' href='#'>" + Ext.ux.getI18N('NEGP.no') + "</a>";

            // Wrap the confirmation into an ext element
            var $confirmation = Ext.get(confirmation);
            // confirmation.setAttributeNS(null,"class", "y-delete-confirm");
            $confirmation.addClass("y-delete-confirm");

            // remove the confirmation dialog
            // in case of IE it seems that the same event, that creates this dialog is propagated further on,
            // therefore ignore the first click
            var clickCounter = Ext.isIE ? 1 : 0;
            var removeConfirmationDialog = function(e) {
                if (e.target === confirmation) {return;}
                if (clickCounter > 0) {
                    clickCounter--;
                    return;
                }
                $confirmation.remove();
                Ext.fly(document).un("click", removeConfirmationDialog);
            };

            // Add a click listener on the whole document to remove the confirmation dialog
            Ext.fly(document).on("click", removeConfirmationDialog);

            // Remove the row when the yes button is clicked
            $confirmation.child(".y-delete-confirm-yes").on("click", function(e) {
                Event.stop(e);
                $confirmation.remove();
                // TODO Show confirmation dialog to remove the record
                this.store.remove(record);

                this.nestedGridFields.each(function(field) {
                    field.removeRowsWithParentId(record.get('id'));
                });

                // Update the source cell with the new count
                this.updateSourceCell();

                this.view.refresh();

                this.syncShadow();
            }.bind(this));

            // Remove the confirmation when 'no' is clicked
            $confirmation.child(".y-delete-confirm-no").on("click", function(e) {
                Event.stop(e);
                $confirmation.remove();
            });

            // Align the confirmation dialog to the delete button inside the row
            this.el.parent().appendChild($confirmation);
            $confirmation.alignTo(cell, "l-l", this.getConfirmationAlignment());
            $confirmation.dom.style['zIndex'] = 2 * (this.level || 0) + 1;
            this.confirmationDialog = $confirmation;
        },

        /**
         * Sadly, yet again different browsers let ext align elements differently to each other,
         * so depending on the used browser, some small adjustments have to be made
         * @returns {Array} alignment
         */
        getConfirmationAlignment : function() {
            if (Ext.isFF) {
                return [-3, 0];
            }
        },

        /**
         * Adds a new row to the given grid
         */
        addNewRow : function() {
            var Row = Ext.data.Record.create(this.store.fields.items);
            var newRow = Object.clone(this.defaultValues);

            // initialize
            this.store.fields.items.each(function(field) {
                if (!Ext.isDefined(newRow[field.name])) {
                    newRow[field.name] = "";
                }
            });

            var isNested = Ext.isDefined(this.store.currentParentId);

            var addition = isNested ? {
                // add the id of the parent entry to the new entry of the nested grid
                parentId    : this.store.currentParentId,
                id          : Signavio.Utils.generateUUID()
            } : {
                // it is a new entry in the main grid
                id          : Signavio.Utils.generateUUID()
            };
            // generate ids for user defined fields
            (this.additionalIds || []).each(function(id) {
                addition[id] = Signavio.Utils.generateUUID();
            });

            // create a new record for the currently selected risk
            this.store.add(new Row(Ext.apply(newRow, addition)));

            this.updateSourceCell();

//          this.store.commitChanges();
            this.view.refresh();

            this.syncShadow();
        },

        adjustCellHeight : function() {
            // Update the height of the active row so the nested grid can be inside
            this.row.dom.style["height"] = (this.el.getHeight() + this.cell.originalHeight || (this.cell.originalHeight = this.cell.getHeight())) + "px";
            if (this.parentGrid && this.parentGrid.row) {
                // parentGrid is also a nested grid
                this.parentGrid.adjustCellHeight();
            }
        },

        updateSourceCell : function() {
            if (!this.sourceCell) {
                return;
            }
            var child = this.sourceCell.child(".y-cell-value");
            // the following content is visible if the nested grid is expanded
            if (!child.hasClass('y-no-text')) {
                var text = this.emptyText ? Signavio.Utils.unescapeHTML(this.emptyText) : 'Add content';
                child.dom.innerHTML = text;
            } else {
                child.dom.innerHTML = "&nbsp;";
            }
            this.adjustCellHeight();
        },

        syncShadow : function() {
            if (!this.parentGrid && this.ownerCt) {
                this.ownerCt.syncShadow();
            } else if (this.parentGrid) {
                this.parentGrid.syncShadow();
            }
        }
    });
}());
if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.grid) { Ext.ux.grid = {}; }

(function() {

    Ext.ux.grid.LockingColumnModel = Ext.extend(Ext.grid.ColumnModel, {

        isLocked: function(columnIndex) {
            return this.config[columnIndex].locked === true;
        },

        setLocked: function(columnIndex, value, suppressEvent) {
            if(this.isLocked(columnIndex) === value) {
                return;
            }

            this.config[columnIndex].locked = value;

            if(!suppressEvent) {
                this.fireEvent("columnlockchange", this, columnIndex, value);
            }
        },

        getTotalLockedWidth: function() {
            var totalWidth = 0;

            for(var i = 0, len = this.config.length; i < len; i = i + 1) {
                if(this.isLocked(i) && !this.isHidden(i)) {
                    totalWidth += this.getColumnWidth(i);
                }
            }

            return totalWidth;
        },

        getLockedCount: function() {
            var len = this.config.length;

            for(var i = 0; i < len; i = i + 1) {
                if(!this.isLocked(i)) {
                    return i;
                }
            }

            return len;
        },

        moveColumn: function(oldIndex, newIndex) {
            var oldLocked = this.isLocked(oldIndex),
                newLocked = this.isLocked(newIndex),
                state = oldIndex < newIndex && oldLocked && newLocked;

            this.setLocked(oldIndex, state, true);

            Ext.ux.grid.LockingColumnModel.superclass.moveColumn.apply(this, arguments);
        },

        getRendererScope : function(col){
            return this.config[col].scope;
        }

    });

}());
if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.grid) {Ext.ux.grid = {}; }

(function() {

    Ext.ux.grid.LockingEditorGridPanel = function(attrs) {
        attrs = attrs || {};

        attrs.view = attrs.view || new Ext.ux.grid.LockingGridView();
        attrs.cm = attrs.cm || new Ext.ux.grid.LockingColumnModel(attrs.columns);

        Ext.ux.grid.LockingEditorGridPanel.superclass.constructor.call(this, attrs);
    };

    Ext.extend(Ext.ux.grid.LockingEditorGridPanel, Ext.grid.EditorGridPanel);

}());if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.grid) { Ext.ux.grid = {}; }

(function() {

    Ext.ux.grid.LockingGridView = function(attrs) {
        Ext.ux.grid.LockingGridView.superclass.constructor.call(this, attrs);
    };

    Ext.extend(Ext.ux.grid.LockingGridView, Ext.grid.GridView, {

        lockText : 'Lock',
        unlockText : 'Unlock',
        rowBorderWidth : 1,
        lockedBorderWidth : 0,

        initTemplates: function() {
            var ts = this.templates || {};

            if(!ts.master) {
                ts.master = new Ext.Template(
                    '<div class="x-grid3" hidefocus="true">',
                        '<div class="x-grid3-locked">',
                            '<div class="x-grid3-header">',
                                '<div class="x-grid3-header-inner">',
                                    '<div class="x-grid3-header-offset" style="{lockedStyle}">',
                                        '{lockedHeader}',
                                    '</div>',
                                '</div>',
                                '<div class="x-clear"></div>',
                            '</div>',
                            '<div class="x-grid3-scroller">',
                                '<div class="x-grid3-body" style="{lockedStyle}">',
                                    '{lockedBody}',
                                '</div>',
                                '<div class="x-grid3-scroll-spacer"></div>',
                            '</div>',
                        '</div>',
                        '<div class="x-grid3-viewport x-grid3-unlocked">',
                            '<div class="x-grid3-header">',
                                '<div class="x-grid3-header-inner">',
                                    '<div class="x-grid3-header-offset" style="{ostyle}">',
                                        '{header}',
                                    '</div>',
                                '</div>',
                                '<div class="x-clear"></div>',
                            '</div>',
                            '<div class="x-grid3-scroller">',
                                '<div class="x-grid3-body" style="{bstyle}">',
                                    '{body}',
                                '</div>',
                                '<a href="#" class="x-grid3-focus" tabIndex="-1"></a>',
                            '</div>',
                        '</div>',
                        '<div class="x-grid3-resize-marker">&#160;</div>',
                        '<div class="x-grid3-resize-proxy">&#160;</div>',
                    '</div>'
                );
            }

            this.templates = ts;

            Ext.ux.grid.LockingGridView.superclass.initTemplates.call(this);
        },

        initElements: function() {
            var el = Ext.get(this.grid.getGridEl().dom.firstChild);

            var lockedWrap = el.child("div.x-grid3-locked");
            var lockedHd = lockedWrap.child("div.x-grid3-header");
            var lockedScroller = lockedWrap.child("div.x-grid3-scroller");

            var mainWrap = el.child("div.x-grid3-viewport");
            var mainHd = mainWrap.child("div.x-grid3-header");
            var mainScroller = mainWrap.child("div.x-grid3-scroller");

            if(this.grid.hideHeaders) {
                lockedHd.setDisplayed(false);
                mainHd.setDisplayed(false);
            }

            if(this.forceFit) {
                mainScroller.setStyle("overflow-x", "hidden");
            }

            Ext.apply(this, {
                el: el,
                mainWrap: mainWrap,
                mainHd: mainHd,
                mainBody: mainScroller.child("div.x-grid3-body"),
                focusEl: mainScroller.child("a.x-grid3-focus"),
                innerHd: mainHd.child("div.x-grid3-header-inner").dom,
                scroller: mainScroller,
                resizeMarker: el.child("div.x-grid3-resize-marker"),
                resizeProxy: el.child("div.x-grid3-resize-proxy"),
                lockedWrap: lockedWrap,
                lockedHd: lockedHd,
                lockedScroller: lockedScroller,
                lockedBody: lockedScroller.child("div.x-grid3-body"),
                lockedInnerHd: lockedHd.child("div.x-grid3-header-inner").dom
            });

            this.focusEl.swallowEvent("click", true);
        },

        getLockedRows: function() {
            if(this.hasRows()) {
                return this.lockedBody.dom.childNodes;
            }

            return [];
        },

        getLockedRow: function(row) {
            return this.getLockedRows()[row];
        },

        getCell: function(row, col) {
            var lockedLength = this.cm.getLockedCount();

            if(col < lockedLength) {
                return this.getLockedRow(row).getElementsByTagName("td")[col];
            }

            return Ext.ux.grid.LockingGridView.superclass.getCell.call(this, row, col - lockedLength);
        },

        getHeaderCell: function(index) {
            var lockedLength = this.cm.getLockedCount();

            if(index < lockedLength) {
                return this.lockedHd.dom.getElementsByTagName("td")[index];
            }

            return Ext.ux.grid.LockingGridView.superclass.getHeaderCell.call(this, index - lockedLength);
        },

        syncScroll: function() {
            this.lockedScroller.dom.scrollTop = this.scroller.dom.scrollTop;

            Ext.ux.grid.LockingGridView.superclass.syncScroll.call(this);
        },

        addRowClass: function(row, cls) {
            var lockedRow = this.getLockedRow(row);

            if(lockedRow) {
                this.fly(lockedRow).addClass(cls);
            }

            Ext.ux.grid.LockingGridView.superclass.addRowClass.call(this, row, cls);
        },

        removeRowClass: function(row, cls) {
            var lockedRow = this.getLockedRow(row);

            if(lockedRow) {
                this.fly(lockedRow).removeClass(cls);
            }

            Ext.ux.grid.LockingGridView.superclass.removeRowClass.call(this, row, cls);
        },

        removeRow: function(row) {
            Ext.removeNode(this.getLockedRow(row));
            Ext.ux.grid.LockingGridView.superclass.removeRow.call(this, row);
        },

        removeRows: function(first, last) {
            var lockedBody = this.lockedBody.dom,
                rowIndex = first;

            for(; rowIndex <= last; rowIndex = rowIndex + 1) {
                Ext.removeNode(lockedBody.childNodes[first]);
            }

            Ext.ux.grid.LockingGridView.superclass.removeRows.call(this, first, last);
        },

        updateAllColumnWidths : function(){
            var totalWidth = this.getTotalWidth(),
                columnCount = this.cm.getColumnCount(),
                lockedWidth = this.getLockedWidth(),
                lockedLength = this.cm.getLockedCount(),
                widths = [],
                len,
                i;

            this.updateLockedWidth();

            for(i = 0; i < columnCount; i = i + 1){
                widths[i] = this.getColumnWidth(i);
                var hd = this.getHeaderCell(i);
                hd.style.width = widths[i];
            }

            var lockedRows = this.getLockedRows(),
                rows = this.getRows(),
                row,
                titleRow,
                j;

            for(i = 0, len = rows.length; i < len; i = i + 1){
                row = lockedRows[i];
                row.style.width = lockedWidth;

                if(row.firstChild){
                    row.firstChild.style.width = lockedWidth;
                    titleRow = row.firstChild.rows[0];

                    for (j = 0; j < lockedLength; j = j + 1) {
                       titleRow.childNodes[j].style.width = widths[j];
                    }
                }

                row = rows[i];
                row.style.width = totalWidth;

                if(row.firstChild){
                    row.firstChild.style.width = totalWidth;
                    titleRow = row.firstChild.rows[0];

                    for (j = lockedLength; j < columnCount; j = j + 1) {
                       titleRow.childNodes[j - lockedLength].style.width = widths[j];
                    }
                }
            }

            this.onAllColumnWidthsUpdated(widths, totalWidth);
            this.syncHeaderHeight();
        },

        updateColumnWidth : function(col){
            var width = this.getColumnWidth(col),
                lockedLength = this.cm.getLockedCount(),
                ns, rowWidth, c, row;

            this.updateLockedWidth();

            if(col < lockedLength){
                ns = this.getLockedRows();
                rowWidth = this.getLockedWidth();
                c = col;
            } else {
                ns = this.getRows();
                rowWidth = this.getTotalWidth();
                c = col - lockedLength;
            }

            var hd = this.getHeaderCell(col);
            hd.style.width = width;

            for(var i = 0, len = ns.length; i < len; i = i + 1) {
                row = ns[i];
                row.style.width = rowWidth;

                if(row.firstChild){
                    row.firstChild.style.width = rowWidth;
                    row.firstChild.rows[0].childNodes[c].style.width = width;
                }
            }

            this.onColumnWidthUpdated(col, width, this.getTotalWidth());
            this.syncHeaderHeight();
        },

        updateColumnHidden : function(col, hidden){
            var lockedLength = this.cm.getLockedCount(),
                ns, rowWidth, c, row,
                display = hidden ? 'none' : '';

            this.updateLockedWidth();

            if(col < lockedLength){
                ns = this.getLockedRows();
                rowWidth = this.getLockedWidth();
                c = col;
            }else{
                ns = this.getRows();
                rowWidth = this.getTotalWidth();
                c = col - lockedLength;
            }

            var hd = this.getHeaderCell(col);
            hd.style.display = display;

            for(var i = 0, len = ns.length; i < len; i = i + 1) {
                row = ns[i];
                row.style.width = rowWidth;

                if(row.firstChild){
                    row.firstChild.style.width = rowWidth;
                    row.firstChild.rows[0].childNodes[c].style.display = display;
                }
            }

            this.onColumnHiddenUpdated(col, hidden, this.getTotalWidth());
            delete this.lastViewWidth;
            this.layout();
        },

        doRender : function(cs, rs, ds, startRow, colCount, stripe){
            var templates = this.templates,
                cellTemplate = templates.cell,
                rowTemplate = templates.row,
                last = colCount - 1,
                totalStyle = 'width:' + this.getTotalWidth() + ';',
                lockedStyle = 'width:' + this.getLockedWidth() + ';',
                buf = [], lbuf = [], cb, lcb, c, p = {}, rp = {}, r;

            for(var j = 0, len = rs.length; j < len; j = j + 1) {
                r = rs[j]; cb = []; lcb = [];
                var rowIndex = (j+startRow);

                for(var i = 0; i < colCount; i = i + 1){
                    c = cs[i];
                    p.id = c.id;
                    p.css = (i === 0 ? 'x-grid3-cell-first ' : (i === last ? 'x-grid3-cell-last ' : '')) +
                        (this.cm.config[i].cellCls ? ' ' + this.cm.config[i].cellCls : '');

                    p.attr = p.cellAttr = '';
                    p.value = c.renderer(r.data[c.name], p, r, rowIndex, i, ds);
                    p.style = c.style;

                    if(Ext.isEmpty(p.value)){
                        p.value = '&#160;';
                    }

                    if(this.markDirty && r.dirty && Ext.isDefined(r.modified[c.name])){
                        p.css += ' x-grid3-dirty-cell';
                    }

                    if(c.locked){
                        lcb[lcb.length] = cellTemplate.apply(p);
                    } else {
                        cb[cb.length] = cellTemplate.apply(p);
                    }
                }
                var alt = [];

                if(stripe && ((rowIndex+1) % 2 === 0)){
                    alt[0] = 'x-grid3-row-alt';
                }

                if(r.dirty){
                    alt[1] = ' x-grid3-dirty-row';
                }

                rp.cols = colCount;

                if(this.getRowClass){
                    alt[2] = this.getRowClass(r, rowIndex, rp, ds);
                }

                rp.alt = alt.join(' ');
                rp.cells = cb.join('');
                rp.totalStyle = totalStyle;
                buf[buf.length] = rowTemplate.apply(rp);
                rp.cells = lcb.join('');

                // is this assignment correct!?
                rp.totalStyle = lockedStyle;
                lbuf[lbuf.length] = rowTemplate.apply(rp);
            }

            return [buf.join(''), lbuf.join('')];
        },

        /*
        afterRender : function(){
            if(!this.ds || !this.cm){
                return;
            }

            var bd = this.renderRows() || ['&#160;', '&#160;'];
            this.mainBody.dom.innerHTML = bd[0];
            this.lockedBody.dom.innerHTML = bd[1];
            this.processRows(0, true);

            if(this.deferEmptyText !== true){
                this.applyEmptyText();
            }

            this.grid.fireEvent('viewready', this.grid);
        },
        */
        renderUI : function(){
            var templates = this.templates,
                header = this.renderHeaders(),
                body = templates.body.apply({rows:'&#160;'});

            var html = templates.master.apply({
                body: body,
                header: header[0],
                lockedHeader: header[1],
                ostyle: 'width:' + this.getOffsetWidth() + ';',
                bstyle: 'width:' + this.getTotalWidth()  + ';',
                lockedBody: body,
                lockedStyle: 'width:'+this.getLockedWidth()+';'
            });

            var g = this.grid;

            g.getGridEl().dom.innerHTML = html;

            this.initElements();

            this.mainBody.dom.innerHTML = this.renderRows();
            this.processRows(0, true);

            // get mousedowns early
            Ext.fly(this.innerHd).on("click", this.handleHdDown, this);
            this.mainHd.on("mouseover", this.handleHdOver, this);
            this.mainHd.on("mouseout", this.handleHdOut, this);
            this.mainHd.on("mousemove", this.handleHdMove, this);

            this.scroller.on('scroll', this.syncScroll,  this);
            if(g.enableColumnResize !== false){
                this.splitone = new Ext.grid.GridView.SplitDragZone(g, this.mainHd.dom);
            }

            if(g.enableColumnMove){
                this.columnDrag = new Ext.grid.GridView.ColumnDragZone(g, this.innerHd);
                this.columnDrop = new Ext.grid.HeaderDropZone(g, this.mainHd.dom);
            }

            if(g.enableHdMenu !== false){
                if(g.enableColumnHide !== false){
                    this.colMenu = new Ext.menu.Menu({id:g.id + "-hcols-menu"});
                    this.colMenu.on("beforeshow", this.beforeColMenuShow, this);
                    this.colMenu.on("itemclick", this.handleHdMenuClick, this);
                }
                this.hmenu = new Ext.menu.Menu({id: g.id + "-hctx"});
                this.hmenu.add(
                    {id:"asc", text: this.sortAscText, cls: "xg-hmenu-sort-asc"},
                    {id:"desc", text: this.sortDescText, cls: "xg-hmenu-sort-desc"}
                );
                if(g.enableColumnHide !== false){
                    this.hmenu.add('-',
                        {id:"columns", text: this.columnsText, menu: this.colMenu, iconCls: 'x-cols-icon'}
                    );
                }
                this.hmenu.on("itemclick", this.handleHdMenuClick, this);

                //g.on("headercontextmenu", this.handleHdCtx, this);
            }

            if(g.enableDragDrop || g.enableDrag){
                var dd = new Ext.grid.GridDragZone(g, {
                    ddGroup : g.ddGroup || 'GridDD'
                });
            }

            this.updateHeaderSortState();
        },
        /*
        afterRenderUI: function(){
            var g = this.grid;
            this.initElements();
            Ext.fly(this.innerHd).on('click', this.handleHdDown, this);
            Ext.fly(this.lockedInnerHd).on('click', this.handleHdDown, this);
            this.mainHd.on({
                scope: this,
                mouseover: this.handleHdOver,
                mouseout: this.handleHdOut,
                mousemove: this.handleHdMove
            });
            this.lockedHd.on({
                scope: this,
                mouseover: this.handleHdOver,
                mouseout: this.handleHdOut,
                mousemove: this.handleHdMove
            });
            this.scroller.on('scroll', this.syncScroll,  this);
            if(g.enableColumnResize !== false){
                this.splitZone = new Ext.grid.GridView.SplitDragZone(g, this.mainHd.dom);
                this.splitZone.setOuterHandleElId(Ext.id(this.lockedHd.dom));
                this.splitZone.setOuterHandleElId(Ext.id(this.mainHd.dom));
            }
            if(g.enableColumnMove){
                this.columnDrag = new Ext.grid.GridView.ColumnDragZone(g, this.innerHd);
                this.columnDrag.setOuterHandleElId(Ext.id(this.lockedInnerHd));
                this.columnDrag.setOuterHandleElId(Ext.id(this.innerHd));
                this.columnDrop = new Ext.grid.HeaderDropZone(g, this.mainHd.dom);
            }
            if(g.enableHdMenu !== false){
                this.hmenu = new Ext.menu.Menu({id: g.id + '-hctx'});
                this.hmenu.add(
                    {itemId: 'asc', text: this.sortAscText, cls: 'xg-hmenu-sort-asc'},
                    {itemId: 'desc', text: this.sortDescText, cls: 'xg-hmenu-sort-desc'}
                );
                if(this.grid.enableColLock !== false){
                    this.hmenu.add('-',
                        {itemId: 'lock', text: this.lockText, cls: 'xg-hmenu-lock'},
                        {itemId: 'unlock', text: this.unlockText, cls: 'xg-hmenu-unlock'}
                    );
                }
                if(g.enableColumnHide !== false){
                    this.colMenu = new Ext.menu.Menu({id:g.id + '-hcols-menu'});
                    this.colMenu.on({
                        scope: this,
                        beforeshow: this.beforeColMenuShow,
                        itemclick: this.handleHdMenuClick
                    });
                    this.hmenu.add('-', {
                        itemId:'columns',
                        hideOnClick: false,
                        text: this.columnsText,
                        menu: this.colMenu,
                        iconCls: 'x-cols-icon'
                    });
                }
                this.hmenu.on('itemclick', this.handleHdMenuClick, this);
            }
            if(g.trackMouseOver){
                this.mainBody.on({
                    scope: this,
                    mouseover: this.onRowOver,
                    mouseout: this.onRowOut
                });
                this.lockedBody.on({
                    scope: this,
                    mouseover: this.onRowOver,
                    mouseout: this.onRowOut
                });
            }

            if(g.enableDragDrop || g.enableDrag){
                this.dragZone = new Ext.grid.GridDragZone(g, {
                    ddGroup : g.ddGroup || 'GridDD'
                });
            }

            this.updateHeaderSortState();
        },
        */
        getOffsetWidth : function() {
            return (this.cm.getTotalWidth() - this.cm.getTotalLockedWidth() + this.getScrollOffset()) + 'px';
        },

        getScrollOffset: function() {
            return this.scrollOffset;
        },

        getLockedWidth : function() {
            return this.cm.getTotalLockedWidth() + 'px';
        },

        getTotalWidth : function() {
            return (this.cm.getTotalWidth() - this.cm.getTotalLockedWidth()) + 'px';
        },

        layout : function(){
            if(!this.mainBody){
                return;
            }

            var g = this.grid;
            var c = g.getGridEl();
            var csize = c.getSize(true);
            var vw = csize.width;
            var vh;

            if(!g.hideHeaders && (vw < 20 || csize.height < 20)){
                return;
            }

            this.syncHeaderHeight();

            if(g.autoHeight){
                this.scroller.dom.style.overflow = 'visible';
                this.lockedScroller.dom.style.overflow = 'visible';

                if(Ext.isWebKit){
                    this.scroller.dom.style.position = 'static';
                    this.lockedScroller.dom.style.position = 'static';
                }
            } else {
                this.el.setSize(csize.width, csize.height);
                var hdHeight = this.mainHd.getHeight();
                vh = csize.height - (hdHeight);
            }

            this.updateLockedWidth();

            if(this.forceFit){
                if(this.lastViewWidth !== vw){
                    this.fitColumns(false, false);
                    this.lastViewWidth = vw;
                }
            } else {
                this.autoExpand();
                this.syncHeaderScroll();
            }

            this.onLayout(vw, vh);
        },

        renderHeaders : function(){
            var cm = this.cm,
                ts = this.templates,
                ct = ts.hcell,
                cb = [], lcb = [],
                p = {},
                len = cm.getColumnCount(),
                last = len - 1;

            for(var i = 0; i < len; i = i + 1){
                p.id = cm.getColumnId(i);
                p.value = cm.getColumnHeader(i) || '';
                p.style = this.getColumnStyle(i, true);
                p.tooltip = this.getColumnTooltip(i);
                p.css = (i === 0 ? 'x-grid3-cell-first ' : (i === last ? 'x-grid3-cell-last ' : '')) +
                    (cm.config[i].headerCls ? ' ' + cm.config[i].headerCls : '');

                if(cm.config[i].align === 'right'){
                    p.istyle = 'padding-right:16px';
                } else {
                    delete p.istyle;
                }

                if(cm.isLocked(i)){
                    lcb[lcb.length] = ct.apply(p);
                }else{
                    cb[cb.length] = ct.apply(p);
                }
            }

            return [ts.header.apply({cells: cb.join(''), tstyle:'width:'+this.getTotalWidth()+';'}),
                    ts.header.apply({cells: lcb.join(''), tstyle:'width:'+this.getLockedWidth()+';'})];
        },

        updateHeaders : function(){
            var hd = this.renderHeaders();
            this.innerHd.firstChild.innerHTML = hd[0];
            this.innerHd.firstChild.style.width = this.getOffsetWidth();
            this.innerHd.firstChild.firstChild.style.width = this.getTotalWidth();
            this.lockedInnerHd.firstChild.innerHTML = hd[1];

            var lw = this.getLockedWidth();
            this.lockedInnerHd.firstChild.style.width = lw;
            this.lockedInnerHd.firstChild.firstChild.style.width = lw;
        },

        getResolvedXY : function(resolved){
            if(!resolved){
                return null;
            }
            var c = resolved.cell, r = resolved.row;
            return c ? Ext.fly(c).getXY() : [this.scroller.getX(), Ext.fly(r).getY()];
        },

        syncFocusEl : function(row, col, hscroll){
            hscroll = col < this.cm.getLockedCount() ? false : hscroll;
            var xy = row;
            if(!Ext.isArray(xy)){
                row = Math.min(row, Math.max(0, this.getRows().length-1));
                if (isNaN(row)) {
                    return;
                }
                xy = this.getResolvedXY(this.resolveCell(row, col, hscroll));
            }
            this.focusEl.setXY(xy||this.scroller.getXY());
        },

        resolveCell : function(row, col, hscroll){
            if(!Ext.isNumber(row)){
                row = row.rowIndex;
            }
            if(!this.ds){
                return null;
            }
            if(row < 0 || row >= this.ds.getCount()){
                return null;
            }
            col = (col !== undefined ? col : 0);

            var rowEl = this.getRow(row),
                cm = this.cm,
                colCount = cm.getColumnCount(),
                cellEl;
            if(!(hscroll === false && col === 0)){
                while(col < colCount && cm.isHidden(col)){
                    col++;
                }
                cellEl = this.getCell(row, col);
            }

            return {row: rowEl, cell: cellEl};
        },

        ensureVisible : function(row, col, hscroll){
            return Ext.ux.grid.LockingGridView.superclass.ensureVisible.call(this, row, col, col < this.cm.getLockedCount() ? false : hscroll);
        },

        insertRows : function(dm, firstRow, lastRow, isUpdate){
            var last = dm.getCount() - 1;

            if(!isUpdate && firstRow === 0 && lastRow >= last){
                this.refresh();
            } else {
                if(!isUpdate){
                    this.fireEvent('beforerowsinserted', this, firstRow, lastRow);
                }

                var html = this.renderRows(firstRow, lastRow),
                    before = this.getRow(firstRow);

                if(before){
                    if(firstRow === 0){
                        this.removeRowClass(0, this.firstRowCls);
                    }

                    Ext.DomHelper.insertHtml('beforeBegin', before, html[0]);
                    before = this.getLockedRow(firstRow);
                    Ext.DomHelper.insertHtml('beforeBegin', before, html[1]);
                } else {
                    this.removeRowClass(last - 1, this.lastRowCls);
                    Ext.DomHelper.insertHtml('beforeEnd', this.mainBody.dom, html[0]);
                    Ext.DomHelper.insertHtml('beforeEnd', this.lockedBody.dom, html[1]);
                }

                if(!isUpdate){
                    this.fireEvent('rowsinserted', this, firstRow, lastRow);
                    this.processRows(firstRow);
                } else if(firstRow === 0 || firstRow >= last){
                    this.addRowClass(firstRow, firstRow === 0 ? this.firstRowCls : this.lastRowCls);
                }
            }

            this.syncFocusEl(firstRow);
        },

        getColumnStyle : function(col, isHeader){
            var style = !isHeader ? this.cm.config[col].cellStyle || this.cm.config[col].css || '' : this.cm.config[col].headerStyle || '';
            style += 'width:'+this.getColumnWidth(col)+';';

            if(this.cm.isHidden(col)){
                style += 'display:none;';
            }

            var align = this.cm.config[col].align;

            if(align){
                style += 'text-align:'+align+';';
            }

            return style;
        },

        getColumnData : function(){
            var cs = [], cm = this.cm, colCount = cm.getColumnCount();

            for(var i = 0; i < colCount; i = i + 1) {
                var name = cm.getDataIndex(i);
                cs[i] = {
                    name : (!Ext.isDefined(name) ? this.ds.fields.get(i).name : name),
                    renderer : cm.getRenderer(i),
                    scope : cm.getRendererScope(i),
                    id : cm.getColumnId(i),
                    style : this.getColumnStyle(i),
                    locked : cm.isLocked(i)
                };
            }

            return cs;
        },

        renderBody : function(){
            var markup = this.renderRows() || ['&#160;', '&#160;'];
            return [this.templates.body.apply({rows: markup[0]}), this.templates.body.apply({rows: markup[1]})];
        },

        refreshRow: function(record){
            var store = this.ds,
                colCount = this.cm.getColumnCount(),
                columns = this.getColumnData(),
                last = colCount - 1,
                cls = ['x-grid3-row'],
                rowParams = {
                    tstyle: String.format("width: {0};", this.getTotalWidth())
                },
                lockedRowParams = {
                    tstyle: String.format("width: {0};", this.getLockedWidth())
                },
                colBuffer = [],
                lockedColBuffer = [],
                cellTpl = this.templates.cell,
                rowIndex,
                row,
                lockedRow,
                column,
                meta,
                css,
                i;

            if (Ext.isNumber(record)) {
                rowIndex = record;
                record = store.getAt(rowIndex);
            } else {
                rowIndex = store.indexOf(record);
            }

            if (!record || rowIndex < 0) {
                return;
            }

            for (i = 0; i < colCount; i = i + 1) {
                column = columns[i];

                if (i === 0) {
                    css = 'x-grid3-cell-first';
                } else {
                    css = (i === last) ? 'x-grid3-cell-last ' : '';
                }

                meta = {
                    id: column.id,
                    style: column.style,
                    css: css,
                    attr: "",
                    cellAttr: ""
                };

                meta.value = column.renderer.call(column.scope, record.data[column.name], meta, record, rowIndex, i, store);

                if (Ext.isEmpty(meta.value)) {
                    meta.value = ' ';
                }

                if (this.markDirty && record.dirty && typeof record.modified[column.name] !== 'undefined') {
                    meta.css += ' x-grid3-dirty-cell';
                }

                if (column.locked) {
                    lockedColBuffer[i] = cellTpl.apply(meta);
                } else {
                    colBuffer[i] = cellTpl.apply(meta);
                }
            }

            row = this.getRow(rowIndex);
            row.className = '';
            lockedRow = this.getLockedRow(rowIndex);
            lockedRow.className = '';

            if (this.grid.stripeRows && ((rowIndex + 1) % 2 === 0)) {
                cls.push('x-grid3-row-alt');
            }

            if (this.getRowClass) {
                rowParams.cols = colCount;
                cls.push(this.getRowClass(record, rowIndex, rowParams, store));
            }

            // Unlocked rows
            this.fly(row).addClass(cls).setStyle(rowParams.tstyle);
            // rowParams.cells = colBuffer.join("");
            // row.innerHTML = this.templates.row.apply(rowParams);
            this.insertRows(this.ds, rowIndex, rowIndex, true);
            this.getRow(rowIndex).rowIndex = rowIndex;
            this.getLockedRow(rowIndex).rowIndex = rowIndex;

            this.onRemove(this.ds, record, rowIndex + 1, true);

            // Locked rows
            this.fly(lockedRow).addClass(cls).setStyle(lockedRowParams.tstyle);
            // lockedRowParams.cells = lockedColBuffer.join("");
            // lockedRow.innerHTML = this.templates.rowInner.apply(lockedRowParams);
            // lockedRow.innerHTML = this.templates.row.apply(lockedRowParams);
            // lockedRow.rowIndex = rowIndex;
            this.syncRowHeights(row, lockedRow);
            this.fireEvent('rowupdated', this, rowIndex, record);
        },

        refresh : function(headersToo){
            this.fireEvent('beforerefresh', this);
            this.grid.stopEditing(true);
            var result = this.renderBody();

            this.mainBody.update(result[0]);
            this.mainBody.setWidth(this.getTotalWidth());
            this.lockedBody.update(result[1]);
            this.lockedBody.setWidth(this.getLockedWidth());
            
            if(headersToo === true){
                this.updateHeaders();
                this.updateHeaderSortState();
            }

            this.processRows(0, true);
            this.layout();
            this.applyEmptyText();
            this.fireEvent('refresh', this);
        },

        onDenyColumnLock : function(){

        },

        processRows : function(startRow, skipStripe){
            if(!this.ds || this.ds.getCount() < 1){
                return;
            }
            var rows = this.getRows(),
                lrows = this.getLockedRows(),
                row, lrow;
            skipStripe = skipStripe || !this.grid.stripeRows;
            startRow = startRow || 0;
            for(var i = 0, len = rows.length; i < len; ++i){
                row = rows[i];
                lrow = lrows[i];
                row.rowIndex = i;
                lrow.rowIndex = i;
                if(!skipStripe){
                    row.className = row.className.replace(this.rowClsRe, ' ');
                    lrow.className = lrow.className.replace(this.rowClsRe, ' ');
                    if ((i + 1) % 2 === 0){
                        row.className += ' x-grid3-row-alt';
                        lrow.className += ' x-grid3-row-alt';
                    }
                }
                this.syncRowHeights(row, lrow);
            }
            if(startRow === 0){
                Ext.fly(rows[0]).addClass(this.firstRowCls);
                Ext.fly(lrows[0]).addClass(this.firstRowCls);
            }
            Ext.fly(rows[rows.length - 1]).addClass(this.lastRowCls);
            Ext.fly(lrows[lrows.length - 1]).addClass(this.lastRowCls);
        },

        syncRowHeights: function(row1, row2){
            if(this.syncHeights){
                var el1 = Ext.get(row1),
                    el2 = Ext.get(row2),
                    h1 = el1.getHeight(),
                    h2 = el2.getHeight();

                if(h1 > h2){
                    el2.setHeight(h1);
                }else if(h2 > h1){
                    el1.setHeight(h2);
                }
            }
        },

        initData : function(ds, cm){
            if(this.cm){
                this.cm.un('columnlockchange', this.onColumnLock, this);
            }

            Ext.ux.grid.LockingGridView.superclass.initData.call(this, ds, cm);

            if(this.cm){
                this.cm.on('columnlockchange', this.onColumnLock, this);
            }
        },

        onColumnLock : function(){
            this.refresh(true);
        },

        handleHdMenuClick : function(item){
            var index = this.hdCtxIndex,
                cm = this.cm,
                id = item.getItemId(),
                llen = cm.getLockedCount();

            switch(id){
                case 'lock':
                    if(cm.getColumnCount(true) <= llen + 1){
                        this.onDenyColumnLock();

                        return;
                    }

                    cm.setLocked(index, true, llen !== index);

                    if(llen !== index){
                        cm.moveColumn(index, llen);
                        this.grid.fireEvent('columnmove', index, llen);
                    }
                break;
                case 'unlock':
                    if(llen - 1 !== index){
                        cm.setLocked(index, false, true);
                        cm.moveColumn(index, llen - 1);
                        this.grid.fireEvent('columnmove', index, llen - 1);
                    } else {
                        cm.setLocked(index, false);
                    }
                break;
                default:
                    return Ext.ux.grid.LockingGridView.superclass.handleHdMenuClick.call(this, item);
            }
            return true;
        },

        handleHdDown : function(e, t){
            Ext.ux.grid.LockingGridView.superclass.handleHdDown.call(this, e, t);

            if(this.grid.enableColLock !== false){
                if(Ext.fly(t).hasClass('x-grid3-hd-btn')){
                    var hd = this.findHeaderCell(t),
                        index = this.getCellIndex(hd),
                        ms = this.hmenu.items, cm = this.cm;
                    ms.get('lock').setDisabled(cm.isLocked(index));
                    ms.get('unlock').setDisabled(!cm.isLocked(index));
                }
            }
        },

        syncHeaderHeight: function(){
            var hrow = Ext.fly(this.innerHd).child('tr', true),
                lhrow = Ext.fly(this.lockedInnerHd).child('tr', true);

            hrow.style.height = 'auto';
            lhrow.style.height = 'auto';
            
            var hd = hrow.offsetHeight,
                lhd = lhrow.offsetHeight,
                height = Math.max(lhd, hd) + 'px';

            hrow.style.height = height;
            lhrow.style.height = height;
        },

        updateLockedWidth: function(){
            var lw = this.cm.getTotalLockedWidth(),
                tw = this.cm.getTotalWidth() - lw,
                csize = this.grid.getGridEl().getSize(true),
                lp = Ext.isBorderBox ? 0 : this.lockedBorderWidth,
                rp = Ext.isBorderBox ? 0 : this.rowBorderWidth,
                vw = Math.max(csize.width - lw - lp - rp, 0) + 'px',
                so = this.getScrollOffset();

            if(!this.grid.autoHeight){
                var vh = Math.max(csize.height - this.mainHd.getHeight(), 0) + 'px';
                this.lockedScroller.dom.style.height = vh;
                this.scroller.dom.style.height = vh;
            }

            this.lockedWrap.dom.style.width = (lw + rp) + 'px';
            this.scroller.dom.style.width = vw;
            this.mainWrap.dom.style.left = (lw + lp + rp - 1) + 'px';

            if(this.innerHd){
                this.lockedInnerHd.firstChild.style.width = lw + 'px';
                this.lockedInnerHd.firstChild.firstChild.style.width = lw + 'px';
                this.innerHd.style.width = vw;
                this.innerHd.firstChild.style.width = (tw + rp + so) + 'px';
                this.innerHd.firstChild.firstChild.style.width = tw + 'px';
            }

            if(this.mainBody){
                this.lockedBody.dom.style.width = (lw + rp) + 'px';
                this.mainBody.dom.style.width = (tw + rp) + 'px';
            }
        },

        updateSortIcon : function(col, dir){
            var sortClasses = this.sortClasses,
                lockedHeaders = this.lockedHd.select('td').removeClass(sortClasses),
                headers = this.mainHd.select('td').removeClass(sortClasses),
                lockedLen = this.cm.getLockedCount(),
                cls = sortClasses[dir === 'DESC' ? 1 : 0];

            if(col < lockedLen){
                lockedHeaders.item(col).addClass(cls);
            } else {
                headers.item(col - lockedLen).addClass(cls);
            }
        }
    });

}());
if ("undefined" == typeof window.Ext){ window.Ext = {} }
if ("undefined" == typeof Ext.ux){ Ext.ux = {} }
if ("undefined" == typeof Ext.ux.grid){ Ext.ux.grid = {} }

new function() {
	/**
	 * @class Ext.grid.RowNumberer
	 * This is a utility class that can be passed into a {@link Ext.grid.ColumnModel} as a column config that provides
	 * an automatic row numbering column.
	 * <br>Usage:<br>
	 <pre><code>
	 // This is a typical column config with the first column providing row numbers
	 var colModel = new Ext.grid.ColumnModel([
	    new Ext.grid.RowNumberer(),
	    {header: "Name", width: 80, sortable: true},
	    {header: "Code", width: 50, sortable: true},
	    {header: "Description", width: 200, sortable: true}
	 ]);
	 </code></pre>
	 * @constructor
	 * @param {Object} config The configuration options
	*/
	Ext.ux.grid.RowLabeler = function(config){
	    Ext.apply(this, config);
	    if(this.rowspan){
	        this.renderer = this.renderer.createDelegate(this);
	    }
	};

	Ext.ux.grid.RowLabeler.prototype = {
	    /**
	     * @cfg {String} header Any valid text or HTML fragment to display in the header cell for the row
	     * number column (defaults to '').
	     */
	    header: "",
	    /**
	     * @cfg {Number} width The default width in pixels of the row number column (defaults to 23).
	     */
	    width: 23,
	    /**
	     * @cfg {Boolean} sortable True if the row number column is sortable (defaults to false).
	     */
	    sortable: false,

	    // private
	    fixed		: false,
	    menuDisabled: true,
	    dataIndex	: '',
	    id			: 'labeler',
	    rowspan		: undefined,
	    selectable	: false,

	    // private
	    renderer : function(v, p, record, rowIndex){
	        if(this.rowspan){
	            p.cellAttr = 'rowspan="'+this.rowspan+'"';
	        }
	        return record.get("label");
	    }
	};
}();

if ("undefined" == typeof window.Ext){ window.Ext = {} }
if ("undefined" == typeof Ext.ux){ Ext.ux = {} }
if ("undefined" == typeof Ext.ux.grid){ Ext.ux.grid = {} }


(function() {
	/**
	 @class Ext.ux.grid.SimpleRowSelectionModel
	 * @extends Ext.grid.RowSelectionModel
	 * Extends the default {@link Ext.grid.RowSelectionModel} by a 
	 * simpleSelect option.
	 * @constructor
	 * @param {Object} config
	 */
	Ext.ux.grid.SimpleRowSelectionModel = function(config) {
		Ext.apply(this, config);
		
		Ext.ux.grid.SimpleRowSelectionModel.superclass.constructor.call(this);
	};
	
	Ext.extend(Ext.ux.grid.SimpleRowSelectionModel, Ext.grid.RowSelectionModel,  {
		/**
	     * @cfg {Boolean} simpleSelect
	     * True to allow toggling the selection of one row without hold shift or
	     * ctrl. (defaults to true)
	     */
		simpleSelect: true,
		
		// private
		// overrides #handleMouseDown of the RowSelectionModel to enable 
		// simpleSelect
	    handleMouseDown : function(g, rowIndex, e){
	        if(e.button !== 0 || this.isLocked()){
	            return;
	        };
	        var view = this.grid.getView();
	        if(e.shiftKey && this.last !== false){
	            var last = this.last;
	            this.selectRange(last, rowIndex, e.ctrlKey);
	            this.last = last; // reset the last
	            view.focusRow(rowIndex);
	        }else{
	            var isSelected = this.isSelected(rowIndex);
	            if((e.ctrlKey||this.simpleSelect) && isSelected){
	                this.deselectRow(rowIndex);
	            }else if(!isSelected || this.getCount() > 1){
	                this.selectRow(rowIndex, e.ctrlKey || e.shiftKey || this.simpleSelect);
	                view.focusRow(rowIndex);
	            }
	        }
	    }
	});
}())/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

new function(){
	
	
	var isIPad = !!String(window.navigator.userAgent).match(/ipad/i);
	var isIPhone = !!String(window.navigator.userAgent).match(/iphone/i);
	
	var defaults = {touchCount: 1};

	Ext.isIPad = isIPad || isIPhone;
	Ext.isTouch = Ext.isIPad;
	
	
	if ((isIPad || isIPhone) && "undefined" != typeof iScroll){
		

		/*******************************
		 *** iPAD - EVENT - HANDLING ***
		 *******************************/
		(function(){ // @scope Event-Handling
			
			var initialScale = 1.0;
			try {
				initialScale = Number(Ext.getDoc().child("meta[name=viewport]").dom.content.replace(/(.*initial-scale=)([0-9\.]*)(.*)/, "$2"));
			} catch(e){}
			
			//window.addEventListener('onorientationchange' in window ? 'orientationchange' : 'resize', setHeight, false);
			document.addEventListener('touchmove', function(e){ e.preventDefault(); }, false);
			
			/**
			 * PRIVATE METHODS
			 * 
			 */
			
			// Raise event
			var raiseEvent = function(type, node, event, obj){
//				console.log(type)
				var ev = document.createEvent('MouseEvents');
				ev.initMouseEvent(type, true, true, window, 'dblclick' === type ? 2 : 1,
					event.screenX, event.screenY, event.clientX, event.clientY,
					false, false, false, false,
					0, null);
				ev._fake = true;
				Ext.apply(ev, obj || {});
				node.dispatchEvent(ev);
			};
			
			// Return the target element
			var getTarget = function(node){
				node = (node.ownerSVGElement ? (Ext.fly(node).parent("g")||{dom:node}).dom : node);
				return node.nodeType !== 1 ? node.parentNode : node;
			};
			
			var clickTarget = undefined, clickTimer, startPos;
			
			/**
			 * CLICK
			 */
 			document.addEventListener('touchstart', function(e){ 
 				if (e.target && ["textarea", "input"].include(String(e.target.tagName).toLowerCase())){
 					return;
 				}
 				clickTarget = undefined;
 				window.clearTimeout(clickTimer);
 				if (e.touches.length == 1){
 					clickTarget = getTarget(e.touches[0].target);
 					startPos = {x: e.touches[0].pageX, y: e.touches[0].pageY};
 					clickTimer = window.setTimeout(function(){ clickTarget = undefined; }, 1000);
 					raiseEvent("mousedown", e.touches[0].target, e.touches[0]);
 					
 					// Prevent default so that the mouse down is not raises twice. 
 					// Mainly that a menu won't close if clicking it --> Toolbar.
 					//if ((getComputedStyle(clickTarget, null)["-webkit-tap-highlight-color"] === "rgba(0, 0, 0, 0)" || String(clickTarget.className).include("x-menu")) && !clickTarget.ownerSVGElement){
 						e.preventDefault();
 					//}
 				}
 			}, true);

 			document.addEventListener('touchmove', function(e){
 				if (e.touches.length == 1 && clickTarget && startPos){
 					if ((Math.abs(startPos.x - e.touches[0].pageX) + Math.abs(startPos.y - e.touches[0].pageY)) >= 5){
 						clickTarget = startPos = undefined;
 					}
 				}
 			}, true);
 			
 			document.addEventListener('touchend', function(e){ 
 				if (e.changedTouches.length == 1 && clickTarget && clickTarget === getTarget(e.target)){
 					raiseEvent("mouseup", clickTarget, e.changedTouches[0]);
					raiseEvent("click", clickTarget, e.changedTouches[0]);
					raiseEvent("mouseout", clickTarget, e.changedTouches[0]);
 					clickTarget = false;
 				}
 			}, true);
 			
			var target, timer, dblClickEnabled = false;
			
			/**
			 * DBL-CLICK
			 */
 			document.addEventListener('click', function(e){ 
 				if (!e._fake){
 					if (window.navigator.product === "Gecko"){
 						return;
 					}
 					e.preventDefault();
 	 				e.stopPropagation();
 	 				return;
 				}

 				window.clearTimeout(timer);
 				if (dblClickEnabled && target === e.target){
 					raiseEvent("dblclick", e.target, e);
 					dblClickEnabled = target = false;
 				} else {
 					dblClickEnabled = true; target = e.target;
	 				timer = window.setTimeout(function(){
	 					dblClickEnabled = target = false;
	 				}, 1000);
 				}
 			}, true);
 			
 			
 			
			/**
			 * DBL-CLICK with TWO-FINGERS
			 */
			(function(){
				var clickcount = 0, timer, startDBLPos, 
					onDBLClick = function(e){
						raiseEvent("dblclick", e.target, e, {touchCount: 2});
					}.bind(this);
					
				document.addEventListener("gesturestart", function(ev){
					clickcount = clickcount > 1 ? 0 : ++clickcount;
					startDBLPos = 0;
					target = dblClickEnabled = clickTarget = startPos = false;
				}, false);
				
	 			document.addEventListener("touchmove", function(e){
	 				if (e.touches.length == 2 && clickcount > 0){
	 					if (!startDBLPos){
	 						startDBLPos = {x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY};
	 					}
	 					if ((Math.abs(startDBLPos.x - e.changedTouches[0].pageX) + Math.abs(startDBLPos.y - e.changedTouches[0].pageY)) >= 10){
	 						clickcount = startDBLPos = 0;
	 					}
	 				}
	 			}, true);
	 			
				document.addEventListener("gestureend", function(ev){
					window.setTimeout(function(){
						clickcount = 0;
					}, 2000);
					if (clickcount === 2){
						onDBLClick(ev);
						clickcount = 0;
						startDBLPos = undefined;
	 					dblClickEnabled = target = false;
 						clickTarget = startPos = undefined;
					}
				}, false);
			}.bind(this)());
			
 			/** **********************
 			 * MOUSE-EVENTS - EDITOR
 			 * 
 			 */
 			if ("undefined" != typeof ORYX){

 	 			/**
 	 			 * MOUSE-DOWN
 	 			 */
 	 			document.addEventListener('touchstart', function(e){ 
 	 				// @deprecated See above
 	 				//if (e.touches.length == 1)
 	 				//	raiseEvent("mousedown", e.touches[0].target, e.touches[0]);
 	 			}, true);
 	 			
 	 			/**
 	 			 * MOUSE-MOVE
 	 			 */
 	 			(function(){
 	 				var timer;
 	 	 			document.addEventListener('touchmove', function(e){ 
 	 	 				if (e.touches.length == 1){
// 	 	 					window.clearTimeout(timer);
// 	 	 					timer = window.setTimeout(function(event){
 	 	 						raiseEvent("mousemove", event.touches[0].target, event.touches[0]);
// 	 	 					}.bind(this, e), 100);
 	 	 				}
 	 	 			}, true);
 	 	 			
 	 	 			/**
 	 	 			 * MOUSE-UP
 	 	 			 */
 	 	 			document.addEventListener('touchend', function(e){ 
 	 	 				if (e.changedTouches.length == 1){
// 	 	 					window.clearTimeout(timer);
 	 	 					raiseEvent("mouseup", e.changedTouches[0].target, e.changedTouches[0]);
 	 	 				}
 	 	 			}, true);
 	 	 			document.addEventListener('gestureend', function(e){
// 	 					window.clearTimeout(timer);
 	 	 				raiseEvent("mouseup", e.target, e);
 					}, true);
 	 			}());

 	 			
 	 			/**
 	 			 * For ToolTips create a text representation.
 	 			 * Only supported for SVG dom elements
 	 			 */
 	 			Ext.ToolTip.prototype.initTarget = function(){
 	 				if (this.html && this.target){
 	 				    this.target = Ext.get(this.target);
 	 				    if (this.target.dom.ownerSVGElement){
	 	 				    var path = this.target.dom, parent = path.parentNode;
	 	 				    var node = ORYX.Editor.graft("http://www.w3.org/2000/svg", parent, ['text', {
	 	 				            stroke: "none",
	 	 				            x: path.transform.animVal.getItem(0).matrix.e + path.getBBox().width + 10,
	 	 				            y: path.transform.animVal.getItem(0).matrix.f - (path.getBBox().height / 2)
	 	 				        }, this.html]);

	 	 				 	path.addEventListener("DOMNodeRemoved", function(){
	 	 				 		node.parentNode.removeChild(node);
	 	 				 	}, false);
 	 				    }
 	 				}
 	 			};
 	 			
 	 		/** ********************
 			 * MOUSE-EVENTS - EXPLORER
 			 * 
 	 		 */
 			} else {
 				
 	 			var touch, moved = false, touchedEndRecently = false, touchCount = 0;
 	 			
 	 			/**
 	 			 * MOUSE-DOWN
 	 			 */
 	 			document.addEventListener('touchstart', function(e){ 
 					touchCount = e.touches.length;	
 	 				if (touchCount >= 1 && !touchedEndRecently && !moved) {
 	 					touch = touch || (e.touches.length == 2 ? e.changedTouches[0] : e.touches[0]);
 	 					moved = false;
 	 				}
 	 				
 	 				if (touchCount == 2 && touch && !moved) {
 	 					raiseEvent("mousedown", touch.target, touch);
 	 				}
 	 			}, true);
 	 			
 	 			/**
 	 			 * MOUSE-MOVE
 	 			 */
 	 			document.addEventListener('touchmove', function(e){ 
 	 				if (e.touches.length === 2){
 	 					raiseEvent("mousemove", e.touches[e.touches[0]==touch?1:0].target, e.touches[e.touches[0]==touch?1:0]);
 	 					moved = true;
 						target = dblClickEnabled = clickTarget = startPos = false;
 	 				}
 	 			}, true);
 	 			
 	 			/**
 	 			 * MOUSE-UP
 	 			 */
 	 			document.addEventListener('touchend', function(e){ 
 	 				if (e.changedTouches.length >= 1 && --touchCount === 1){
 	 					raiseEvent("mouseup", e.changedTouches[0].target, e.changedTouches[0]);
 	 					touchedEndRecently = true;
 	 					window.setTimeout(function(){touchedEndRecently = false; }, 1000);
 	 				}
 	 				if (moved){
 	 					moved = false;
 	 					e.preventDefault();
 	 					e.stopPropagation();
 	 				}
 	 				touch = undefined;
 	 			}, true);
 	 			
 			}

		}());
			
		
		/*****************************
		 *** EXT - UX - COMPONENTS ***
		 *****************************/
		
		
		/**
		 * Add SCROLLING for GRIP PANEL
		 */ 
		(function(){
			var rui = Ext.grid.GridView.prototype.renderUI;
			Ext.grid.GridView.prototype.renderUI = function(){
				var res = rui.apply(this, arguments);
				this.iscroll = new iScroll(this.mainBody.dom, Object.clone(defaults));
				
				//if (this instanceof Ext.grid.GroupingView){
					//this.mainBody.on('click', this.interceptMouse, this);
				//}
				
				return res;
			};

			var tog = Ext.grid.GroupingView.prototype.toggleGroup;
			Ext.grid.GroupingView.prototype.toggleGroup = function(){
				var res = tog.apply(this, arguments), initialScroll;
				if (this.iscroll){
					this.iscroll.destroy();
					initialScroll = this.mainBody.dom.style.webkitTransform;
				}
				this.iscroll = new iScroll(this.mainBody.dom, Object.clone(defaults));
				if (initialScroll){
					this.mainBody.dom.style.webkitTransform = initialScroll;
				}
				return res;
			};
			
		}());

		
		
		/**
		 * Add SCROLLING for TREE PANEL
		 */ 
		(function(){
			var onr = Ext.tree.TreePanel.prototype.onRender;
			Ext.tree.TreePanel.prototype.onRender = function(){
				var res = onr.apply(this, arguments);
				var sn = this.innerCt.findParent("div{overflow=auto}");
				sn = sn ? sn.firstChild : this.innerCt.dom;
				this.iscroll = new iScroll(sn, Object.clone(defaults));
				this.on("expandnode", function(){
					
					var sn = this.innerCt.findParent("div{overflow=auto}"), initialScroll;
					sn = sn ? sn.firstChild : this.innerCt.dom;
					
					if (this.iscroll){
						this.iscroll.destroy();
						initialScroll = sn.style.webkitTransform;
					}
					this.iscroll = new iScroll(sn, Object.clone(defaults));
					if (initialScroll){
						sn.style.webkitTransform = initialScroll;
					}
				});
				return res;
			};		
		}());

		
		
		/**
		 * Add SCROLLING for DATAVIEW
		 */
		(function(){
			Ext.DataView.prototype.onRender = function(){
				var created = true;
		        if(!this.el){
		        	created = false;
		            this.el = document.createElement('div');
		        }
		        Ext.DataView.superclass.onRender.apply(this, arguments);
		        
		        // @todo: Enable scrolling if dataview is created through applyTo like in the combobox-innerlist
		        if (!created){
			        if (this.cls){
			        	this.el.addClass(this.cls);
			        }
			        
			        if (this.style){
			        	this.el.applyStyles(this.style);
			        }
			        
			        if (!this.scroll){
			        	this.scroll = this.el.getStyle("overflow") === "auto" ? this.el.createChild({tag:"div"}) : this.el;
			        }
			        
			        if (this.scroll.parent().getStyle("overflow") === "auto"){
				        if (!this.iscroll){
							this.iscroll = new iScroll(this.scroll.dom, Object.clone(defaults));
				        } else {
					        this.iscroll.refresh();
				        }
			        }
		        }
			};
			
			Ext.DataView.prototype.refresh = function(){
		        this.clearSelections(false, true);
		        (this.scroll||this.el).update("");
		        var html = [];
		        var records = this.store.getRange();
		        if(records.length < 1){
		            (this.scroll||this.el).update(this.emptyText);
		            this.all.clear();
		            return;
		        }
		        this.tpl.overwrite((this.scroll||this.el), this.collectData(records, 0));
		        this.all.fill(Ext.query(this.itemSelector, (this.scroll||this.el).dom));
		        this.updateIndexes(0);
		        
		        if (this.iscroll){
		        	this.iscroll.refresh();
		        }
		    };
		    
		    Ext.DataView.prototype.onBeforeLoad = function(){
		        if(this.loadingText){
		            this.clearSelections(false, true);
		            (this.scroll||this.el).update('<div class="loading-indicator">'+this.loadingText+'</div>');
		            this.all.clear();
			        if (this.iscroll){
			        	this.iscroll.refresh();
			        }
		        }
		    };
		    
		    Ext.DataView.prototype.show = function(){
		    	Ext.BoxComponent.prototype.show.apply(this, arguments);
		        if (this.iscroll){
		        	this.iscroll.refresh();
		        }
		    };
		}());
		
		
		/**
		 * Stop Scrolling if drag and drop
		 */
	    
	    (function(){
	    	
	    	// Cache last move position
	    	var lastMouseMoveEvent;
	    	Ext.EventManager.on(document, "mousemove", function(e){ lastMouseMoveEvent = e; }, this, true);
	    	
	    	var stopScrolling = function(panel){
	    		if (panel && panel.iscroll){
	    			panel.iscroll.scrolling = false;
	    			panel.iscroll.resetPosition();
	    		}
	    	};
	    	
	    	
	    	Ext.dd.DragDropMgr.handleMouseDown = function(e, oDD) {
	            if(Ext.QuickTips){
	                Ext.QuickTips.disable();
	            }
	            this.currentTarget = e.getTarget();
	            this.dragCurrent = oDD;

	            var el = oDD.getEl();

	            // track start position
	            this.startX = e.getPageX();
	            this.startY = e.getPageY();

	            this.deltaX = this.startX - el.offsetLeft;
	            this.deltaY = this.startY - el.offsetTop;

	            this.dragThreshMet = false;
	        };
	        
	        
	        Ext.dd.DragDropMgr.startDrag = function(x, y) {
	        	//this.useCache = false;
	        	for (var i in this.ids["default"]) {
	                var oDD = this.ids["default"][i];
	                if (!this.isTypeOfDD(oDD)) { continue; }
	                if (this.isOverTarget(lastMouseMoveEvent ? lastMouseMoveEvent.getPoint() : new Ext.lib.Point(x, y), oDD, this.mode)){
	                	 // @TODO: This is a hacky way to get the parent panel of the dragProxy
	                	try {
	                		if (this.dragCurrent)          		
	                			stopScrolling(Ext.getCmp(this.dragCurrent.el.parent(".x-panel").dom.id));
	                		lastMouseMoveEvent = undefined;
	                	} catch(e){}
	                	break;
	                } else {
	                	return
	                }
	        	}
	            clearTimeout(this.clickTimeout);
	            if (this.dragCurrent) {   
	                this.dragCurrent.b4StartDrag(x, y);
	                this.dragCurrent.startDrag(x, y);
	            }
	            this.dragThreshMet = true;
	        };
	    }());
	    
	    
		// Return the scrolling of the given element
		var parseWebkitTransform = function(el){
			try {
				var obj = (el.style.webkitTransform || "").replace(/(.*translate.+?)([-0-9\.]+)(.*?)([-0-9\.]+)(.*)/i, "{left:$2, top:$4}");
				obj = obj.startsWith("{") ? obj.evalJSON() : {};
				if (obj && "undefined" != typeof obj.left && "undefined" != typeof obj.top){
					return [-obj.left, -obj.top];
				}
			} catch(e){}
			return [0, 0];
		};
		
	    
	    /**
	     * HTMLAnchorElement - Fix focus
	     */
	    (function(){
	    	var focus = HTMLAnchorElement.prototype.focus;
	    	HTMLAnchorElement.prototype.focus = function(){
	    	    var scroll =  Ext.fly(this).parent("div{overflow=auto}", true);
	    	    if (!scroll){
		    	    focus.call(this);
	    	    	return;
	    	    }

	    	    // Set origin scroll pos
	    	    var fc = scroll.children[0];
	    	    var sp = parseWebkitTransform(fc);
    	    	if (sp[0] || sp[1]){
    	    		scroll.scrollLeft = sp[0];
    	    		scroll.scrollTop = sp[1];
    	    	}
    	    	
	    	    // Focus
    	    	focus.call(this);
    	    	
	    	    // Set new scroll pos
	    	    fc.style.webkitTransform = "translate("+(-scroll.scrollLeft)+"px, "+(-scroll.scrollTop)+"px)";
	    	    scroll.scrollLeft = scroll.scrollTop = 0;
	    	};
	    }());
	    
	    
	    (function(){
		    /**
		     * EXT - FIX Scroll Animation
		     */
		    if (window.Ext && Ext.lib){
		    	// Get scroll attribute
		    	Ext.lib.Scroll.prototype.getAttribute = function(attr){
		            var val = null;
		            var el = this.getEl();
		            if (attr == 'scroll') {
		                val = parseWebkitTransform(el.firstChild);
		            } else {
		                val = Ext.lib.Scroll.superclass.getAttribute.call(this, attr);
		            }
		            return val;
		    	};
		    	
		    	// Set scroll attribute
		    	Ext.lib.Scroll.prototype.setAttribute = function(attr, val, unit) {
		            var el = this.getEl();
		            if (attr == 'scroll') {
			        	el.firstChild.style.webkitTransform = "translate("+(-val[0])+"px, "+(-val[1])+"px)";
	//		        	if (mainscroll && mainscroll.element === el){
	//		        		mainscroll.x = -val[0];
	//		        		mainscroll.y = -val[1];
	//		        	}
		            } else {
		            	Ext.lib.Scroll.superclass.setAttribute.call(this, attr, val, unit);
		            }
		        };
		        
		        // Get the scroll values
		        var gScroll = Ext.Element.prototype.getScroll;
		        Ext.Element.prototype.getScroll = function(){
			        var d = this.dom, doc = document; 
			        if (d !== doc && d !== doc.body) { 
			        	var scroll = new Ext.lib.Scroll(d).getAttribute("scroll");
			        	return {left: scroll[0], top: scroll[1]}; 
			        } else {
			        	return gScroll.apply(this, arguments);
			        } 
	
		        }
		    }
        
        
 			
 			/**
 			 * FIX YUI Scroll Animation
 			 *
 			 */
			if (window.YAHOO && YAHOO.util){
	 			YAHOO.util.Scroll.prototype.getAttribute = function(attr, val, unit) {
	 			    var val = null;
	 		        var el = this.getEl().firstChild;
	 		        if (attr == 'scroll') {
						val = parseWebkitTransform(el);
	 		        } else {
	 		            val = superclass.getAttribute.call(this, attr);
	 		        }
	 		        return val || [0, 0];
	 			}
	 			
	 			YAHOO.util.Scroll.prototype.setAttribute = function(attr, val, unit) {
			        var el = this.getEl().firstChild;
			        if (attr == 'scroll') {
//			        	console.log("scroll to "+val[0]+" and "+val[1])
			        	//var scrollTop = Math.min(Math.max(0, el.scrollHeight-el.parentNode.offsetHeight), Math.max(0, fx.now));
	 				
			        	el.style.webkitTransform = "translate("+(-val[0])+"px, "+(-val[1])+"px)";
			        	if (mainscroll && mainscroll.element === el){
			        		mainscroll.x = -val[0];
			        		mainscroll.y = -val[1];
			        	}
			        } else {
			        	YAHOO.util.Scroll.superclass.setAttribute.call(this, attr, val, unit);
			        }
	 			};

				
	 			/**
	 			 * FIX YUI get("scrollTop")/get("scrollLeft")
	 			 */
	 			var gap = YAHOO.util.AttributeProvider.prototype.get;
	 			YAHOO.util.AttributeProvider.prototype.get = function(key){
	 				if (key == "scrollTop" || key == "scrollLeft"){
	 					return parseWebkitTransform(this.get("element").firstChild)[key == "scrollTop" ? 1 : 0];
	 				}
	 	            return gap.call(this, key);
	 			};
	 			
			}
 			
 			
 			/**
 			 * FIX jQuery Scrolling animation
 			 */
 			if (window.jQuery && jQuery.fx){
	 			jQuery.fx.step.scrollTop = function(fx){
	 				var el = fx.elem.children[0];
	 				var scrollTop = Math.min(Math.max(0, el.scrollHeight-el.parentNode.offsetHeight), Math.max(0, fx.now));
	 				el.style.webkitTransform = "translate(0px, "+(-(scrollTop))+"px)";
	 			};
	 			
	 			var cur = jQuery.fx.prototype.cur;
	 			jQuery.fx.prototype.cur = function(){
	 				if (this.prop === "scrollTop" || this.prop === "scrollLeft"){
	 					return parseWebkitTransform(this.elem.children[0])[this.prop == "scrollTop" ? 1 : 0];
	 				} else {
	 					return cur.apply(this, arguments);
	 				}
	 			};
 			}
	    }());
	}

}();

/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" == typeof window.Ext){ window.Ext = {} }
if ("undefined" == typeof Ext.ux){ Ext.ux = {} }
if ("undefined" == typeof Ext.ux.layout){ Ext.ux.layout = {} }

/**
 * Implement a vertical box layout. Item are resized by their minHeight property.
 * Stretched by relatively by the flex weight factor. Or have a fixed height
 * value.
 */
new function(){
	Ext.ux.layout.VBoxLayout = Ext.extend(Ext.layout.ContainerLayout, {
		
		onLayout: function(ct, target) {
			Ext.ux.layout.VBoxLayout.superclass.onLayout.call(this, ct, target);
			
			var visibleItems = this.getVisibleItems(ct),
				containerSize = this.getContainerSize(),
			
				childBoxes = this.calculateChildBoxes(visibleItems, containerSize);
			
			this.layoutChildPanels(childBoxes);
		},
		
		/**
		 * Retrieves all items of the container being uncollapsed and rendered. 
		 * Additionally counts the collapsed ones.
		 */
		getVisibleItems: function(ct) {
			var container = ct||this.container,
				containerItems = container.items.items,
				
				// Static height of collapsed items
				coHeight = 0,
				// Items for height calculation
				visibleItems = [];
			
			containerItems.each(function(item) {
				if(item.rendered && item.hidden !== true) {
					if(item.collapsed === true) {
						coHeight += item.getSize().height||0;
					} else {
						visibleItems.push(item);
					}
				}
			});
			
			this.collapsedItemsHeight = coHeight;
			
			return visibleItems;
		},
		
		/**
		 * Calculates the size of the target layout container.
		 */
		getContainerSize: function() {
			var size = {width: 0 , height: 0},
				layoutTarget = this.container.getLayoutTarget();
			
			if(layoutTarget) {
				size = this.container.getLayoutTarget().getViewSize();
				
				// IE-Issues with invalid width and height values
				if(Ext.isIE && Ext.isStrict && size.width == 0) {
					size = layoutTarget.getStyleSize();
				}
				
				// TODO: perhaps consider padding?
				
				size.height -= layoutTarget.getPadding('tb');
				
			}
				
			return size;
		},
		
		isNumber: function(o) {
			return ! isNaN(o - 0);
		},
		
		/**
		 * Calculates the size of the child box elements and triggers the
		 * layout callback
		 */
		calculateChildBoxes: function(items, ctSize) {
			// Var declaration 
			var availableHeight = ctSize.height - this.collapsedItemsHeight,
				flexCount = 0,
				me = this,
				
				childHeight, hasLayoutCB, heightPerFlex,
				flex,
				boxes = [];			
                
			// Calculate flex values of all items
			items.each(function(child) {
				childHeight = child.height;
				hasLayoutCB = !child.hasLayout && (child.doLayout instanceof Function);
				
				// Only consider elements without a fixed height in the
				// calculation
				if(me.isNumber(childHeight)) {					
					if(hasLayoutCB) {
						child.doLayout();
						childHeight = child.getSize().height;
						availableHeight -= childHeight;
					}
				}
				
				// Flexible box
				else if(child.flex) {
					flexCount += child.flex;
				}
				
				// Default flex
				else {
					flexCount++;
				}
			});
			
			heightPerFlex = availableHeight / flexCount;
			
			// Calculate height values
			items.each(function(box) {
				// Ignore fixed height boxes
				if(!me.isNumber(box.height)) {
					flex = box.flex||1;
					boxes.push({panel: box, dirty: true, height: flex * heightPerFlex});
				}
			});
			
			return boxes;
		},
		
		/**
		 * Triggers layouting of child panels with adjusted sizes.
		 */
		layoutChildPanels: function(configs) {
			if(configs instanceof Array) {
				configs.each(function(info) {
					if(info.dirty) {
						// TODO: update other position setting here as well.
						info.panel.setSize(undefined, info.height);
						info.panel.doLayout();
					}
				});
			}
		},
		
		/**
		 * Recalculates size for each panel in the container and updates the
		 * layout.
		 */
		adjustSize : function(p) {
			var items = this.getVisibleItems(),
	            ctSize = this.getContainerSize(),
				
	            // Recalculate panel sizes         
	        	childBoxCache = this.calculateChildBoxes(items, ctSize);
	       
	        // Upadate layout
			this.layoutChildPanels(childBoxCache);
		},
		
		/**
		 * Additional removes the resize listener.
		 */
		onRemove: function(c){
	        Ext.ux.layout.VBoxLayout.superclass.onRemove.call(this, c);
	        
	        c.un('expand', this.adjustSize, this);
	        c.un('collapse', this.adjustSize, this);
	    },
	    
	    // private	
	    renderItem : function(c) {
	    	Ext.ux.layout.VBoxLayout.superclass.renderItem.apply(this, arguments);
			
			c.on('expand', this.adjustSize, this);
			c.on('collapse', this.adjustSize, this);
	    }
	    
	    
	});
	
	Ext.Container.LAYOUTS['ux.vbox'] = Ext.ux.layout.VBoxLayout;
}();

/**
 *  (c) 2010 Signavio GmbH
 *
 *  @author Willi Tscheschner
 *
 */

if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {} }

new function(){

	/**
	 * Returns the PropertyEditor for the given name.
	 *
	 * @param {String} name
	 * @return {AbstractPropertyEditor}
	 */
	Ext.ux.propertyeditor.getEditor = function(name){
		if (!name || "string" != typeof name){ return null; }
		name = name.toLowerCase();

		for (var i in Ext.ux.propertyeditor){
			if (String(i).toLowerCase() === name){
				return Ext.ux.propertyeditor[i];
			}
		}
		return null;
	}


	/**
	 * Abstract class to provide an editor which can be used in
	 * a stencilset and with this in the propertywindow
	 *
	 * @class
	 * @param {Object} property
	 * @param {Object} facade
	 */
	Ext.ux.propertyeditor.AbstractPropertyEditor = function(property, facade){
		this.property = property;
		this.properties = property ? property.stencil().properties() : undefined;
		this.facade = facade;
		Ext.ux.propertyeditor.AbstractPropertyEditor.superclass.constructor.apply(this, [{}]);
	}

	Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, Ext.form.TriggerField,  {

		readOnly: true,
		triggerClass:"x-trigger-other",

		windowCreate: {},

		/**
		 * This method can be used to define a value which
		 * will be shown in the property window.
		 * @param {Object} value
		 * @return {String}
		 */
		renderer: function(value){
			return String(value);
		},

		setValue: function(value){
			this.value = value;
			this.setRawValue(this.renderer(value));
		},

		getValue: function(){
			return this.value;
		},

		onTriggerClick: function(){

			var panel = this.getEditor(this.getValue())
				, me = this
				, buttons = (this.windowCreate||{}).buttons
				, noButtons = this.windowCreate.noButtons;

			delete (this.window||{}).noButtons;
			
			if (buttons){
				delete (this.windowCreate||{}).buttons;
			}

			var useApplyInsteadOfSaveButton = !!(this.windowCreate||{}).useApplyInsteadOfSaveButton;
			
			buttons = [].concat(buttons||[], [{
						text: Ext.ux.getI18N(useApplyInsteadOfSaveButton ? "btnapply" : "btnsave"),
						handler: function(){
							if (this.onBeforeSave(this.getValue(), panel.getValue())) {
								this.onSave(this.getValue(), panel.getValue());
								win.close();
							}
						}.bind(this)
					}]);
			
			// Destroy all buttons if specified by configuration
			if (noButtons) {
				buttons = [];
			}
			
			var win = new Ext.ux.Window(Ext.apply({
					autoCreate: true,
					title: (this.property?this.property.title():"")||this.title||"",
					cls: "x-property-editor",
					minWidth: 200,
					minHeight:200,
					height: 300,
					width: 340,
					modal: true,
					collapsible: false,
					fixedcenter: true,
					shadow: true,
					proxyDrag: true,
					layout: "anchor",
					bodyStyle: "padding:10px;background-color:#FFFFFF;",
					autoScroll: true,
					keys: [{
						key: 27, //Esc
						fn: function(){
							win.hide();
						}.bind(this)
					}],
					items: [panel],
					listeners: {
						show : this.onWindowShow.bind(this, win, panel),
						hide : this.onWindowHide.bind(this, win, panel)
					},
					render: function(){
						Ext.Window.prototype.render.apply(this, arguments);
						me.onWindowRendered(win);
					},
					buttons: buttons
				}, this.windowCreate));

			win.show();
			
			// store window reference
			this.win = win;
		},

		/**
		 * Callback before the new value is stored.
		 * Should be used for further checks.
		 * @param {Object} oldValue
		 * @param {Object} newValue
		 * @returns true if the Editor can save
		 */
		onBeforeSave: function(oldValue, newValue) {
			return true;
		},

		/**
		 * Callback to store the new value
		 * @param {Object} oldValue
		 * @param {Object} newValue
		 */
		onSave: function(oldValue, newValue){
			this.setValue(newValue);
			this.fireEvent('dialogClosed', this, newValue, oldValue);
		},

		/**
		 * Will be called if the window is shown
		 * @param {Object} win
		 * @param {Object} panel
		 */
		onWindowShow: function(win, panel){
			// Hide Editor
			this.fireEvent("blur");
			if (panel.focus instanceof Function) {
				// Set Focus to the field
				window.setTimeout(panel.focus.bind(panel), 100);
			}

			if(this.facade.disableEvent) {
				// this method is currently only available in the editor
				// -> Facade should also get part of libs and components should then only
				// extend it with specialized functionality
				this.facade.disableEvent(Signavio.Config.EVENT_KEYDOWN);
			}
		},

		/**
		 * Will be called if the window is hiding
		 * @param {Object} win
		 * @param {Object} panel
		 */
		onWindowHide: function(win, panel){
			if(this.facade.enableEvent) {
				// this method is currently only available in the editor
				// -> Facade should also get part of libs and components should then only
				// extend it with specialized functionality
				this.facade.enableEvent(Signavio.Config.EVENT_KEYDOWN);
			}
		},

		/**
		 * Will be called when the window has been rendered
		 * @param win
		 */
		onWindowRendered: function(win){},

		/**
		 * @abstract
		 */
		getEditor: function(value){
			throw Error("AbstractPropertyEditor.getEditor has to be implemented.");
		}

	});


}()
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Specific class to provide a ComMed Delay attribute
	 * 
	 */
	Ext.ux.propertyeditor.ComMedDelay = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width: 300, resizable: false},

		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if (value && "string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){}
			}
			
			var result = "";
			if ("object" == typeof value){
				result = [value.days 	? value.days + " " + (value.days == 1 ? Ext.ux.getI18N("day") : Ext.ux.getI18N("days")) : undefined,
						 value.hours 	? value.hours + " " + (value.hours == 1 ? Ext.ux.getI18N("hour") : Ext.ux.getI18N("hours")) : undefined,
						 value.minutes  ? value.minutes + " " + (value.minutes == 1 ? Ext.ux.getI18N("minute") : Ext.ux.getI18N("minutes")) : undefined].compact().join(", ");
			}
			return result;
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			if ("string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){ value = {};  }
			} else {
				value = value || {};
			}
			
			this.panel = new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "column",
				cls: "x-window-commed-expression",
				getValue: this.extractValue.bind(this),
				hideBorders: true,
				items: [new Ext.form.NumberField({
					emptyText	: Ext.ux.getI18N("day"),
					columnWidth	: 1/3,
					style		: "margin-right:5px;",
					commedType	: "days",
					allowDecimals: false,
					value		: value["days"] || ""
				}),new Ext.form.NumberField({
					emptyText	: Ext.ux.getI18N("hours"),
					columnWidth	: 1/3,
					style		: "margin-right:5px;",
					commedType	: "hours",
					allowDecimals: false,
					value		: value["hours"] || ""
				}),new Ext.form.NumberField({
					emptyText	: Ext.ux.getI18N("minutes"),
					columnWidth	: 1/3,
					commedType	: "minutes",
					allowDecimals: false,
					value		: value["minutes"] || ""
				})]
			});
			
			return this.panel;
		},
		
		/**
		 * Returns the value of the selected time delay
		 * 
		 */
		extractValue: function(){
			var value = {};
			this.panel.items.each(function(item){
				if (item.commedType){
					value[item.commedType] = item.getValue();
				}
			});
			return $H(value).keys().length ? Object.toJSON(value) : "";
		}
		
	});	
	
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.ComMedExpression = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width: 400, resizable: false},

		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if (value && "string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){}
			}
			if ("object" == typeof value && value.type){
				switch(value.type){
					case "otherwise":
						return Ext.ux.getI18N("commed.expression.otherwise"); 
					case "manual":
						return Ext.ux.getI18N("commed.expression.manual");
					case "rule":
						var val = String(value.value||"");
						val = val.replace(/&amp;/g,"&"); 
						var	tr = val.slice(0, 30);							
						return (tr != val ? tr+"..." : val) || Ext.ux.getI18N("commed.expression.automaticrule");
					case "error":
						return Ext.ux.getI18N("commed.expression.standarderror");
					case "exception":
						return value.name || value.value || Ext.ux.getI18N("commed.expression.exception");
				}
			}
			return "";
		},
		
		
		getSelectedRadioField: function(){
			return this.panel.items.items.find(function(item){
				return item instanceof Ext.form.Radio && item.checked
			});
		},
		
		getEnabledField: function(){
			var field;
			this.panel.items.each(function(item, index){
				if (item instanceof Ext.form.Radio && item.checked){
					field = this.panel.items.get(index+1);
					return;
				}
			}.bind(this));
			return field && !(field instanceof Ext.form.Radio) ? field : undefined;
		},
		
		updateEnableState: function(){
			this.panel.items.each(function(item){
				if (!(item instanceof Ext.form.Radio)){
					item.disable();
				}
			});
			
			var field = this.getEnabledField();
			if (field){
				field.enable();
			}
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			if ("string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){ value = {};  }
			} else {
				value = value || {};
			}
			
			var serviceTask = this.getPreviousServiceTask();
			
			this.panel = new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "anchor",
				cls: "x-window-commed-expression",
				getValue: this.extractValue.bind(this),
				hideBorders: true,
				items: [new Ext.form.Radio({
					boxLabel 	: "Kein",
					style		: "margin-bottom:7px;",
					checked		: !value.type,
					name		: "x-commed-expression",
					listeners	: { check: this.updateEnableState.bind(this)}
				}),new Ext.form.Radio({
					boxLabel 	: Ext.ux.getI18N("commed.expression.otherwise"),
					style		: "margin-bottom:7px;",
					checked		: value.type === "otherwise",
					commedType	: "otherwise",
					name		: "x-commed-expression",
					listeners	: { check: this.updateEnableState.bind(this)}
				}),new Ext.form.Radio({
					boxLabel 	: Ext.ux.getI18N("commed.expression.manual"),
					style		: "margin-bottom:7px;",
					checked		: value.type === "manual",
					name		: "x-commed-expression",
					commedType	: "manual",
					listeners	: { check: this.updateEnableState.bind(this)}
				}),new Ext.form.Radio({
					boxLabel 	: Ext.ux.getI18N("commed.expression.automaticrule"),
					checked		: value.type === "rule",
					name		: "x-commed-expression",
					listeners	: { check: this.updateEnableState.bind(this)}
				}),new Ext.form.TextArea({
					emptyText	: Ext.ux.getI18N("commed.expression.jsrule"),
					anchor		: "-20",
					height		: 150,
					disabled	: true,
					value		: (value.type === "rule" && value.value) || "",
					commedType	: "rule",
					style		: "margin-left: 20px;margin-bottom:10px;"
				}),new Ext.form.Radio({
					boxLabel 	: Ext.ux.getI18N("commed.expression.standarderror"),
					checked		: value.type === "error",
					name		: "x-commed-expression",
					commedType	: "error",
					style		: serviceTask ? "margin-bottom:7px;" : "",
					listeners	: { check: this.updateEnableState.bind(this)}
				}),
				serviceTask ? new Ext.form.Radio({
					boxLabel 	: Ext.ux.getI18N("commed.expression.exception"),
					checked		: value.type === "exception",
					name		: "x-commed-expression",
					listeners	: { check: this.updateEnableState.bind(this)}
				}) : undefined, 
				serviceTask ? this.service = new Ext.form.ComboBox({
					emptyText	: Ext.ux.getI18N("commed.expression.exceptions"),
					anchor		: "-20",
					style		: "margin-left: 20px;",
					mode		: "local",
					displayField: "name",
					commedType	: "exception",
					disabled	: true,
					value		: (value.type === "exception" && (value.name || value.value)) || "",
					store		: new Ext.data.SimpleStore({
						fields	: ["id", "name"],
						data	: []
					})
				}) : undefined].compact()
			});
			
			if (serviceTask){
				this.loadBO(serviceTask.properties["oryx-commedbocall"]);
			}
			
			return this.panel;
		},
		
		loadBO: function(bo){
			if (bo){
				if ("string" == typeof bo){
					try {
						bo = bo.evalJSON();
					} catch(e){}
				}
				if (bo.bo){
					var url = ((Signavio && Signavio.Config && Signavio.Config.BACKEND_PATH)||'/p')+'/commed?proxy=bo&id='+bo.bo,
						me = this;
					Request.execute(url, function(data){
						try {
							me.service.store.loadData(data[0].rep.exceptions.map(function(r){ return [r.id, r.name]}));
						} catch(e){}
					});
				}
			}
		},
		
		/**
		 * Returns the value of the selected time delay
		 * 
		 */
		extractValue: function(){
			
			var field = this.getEnabledField();
			if (field){
				if (field instanceof Ext.form.ComboBox){
					var rec = field.store.getAt(field.store.find("name", field.getValue()));
					return Object.toJSON({
						type	: field.commedType, 
						name	: rec ? rec.get("name") : field.getValue(), 
						value	: rec ? rec.get("id") : field.getValue()
					});
				} else {
					return Object.toJSON({
						type	: field.commedType, 
						value	: field.getValue()
					});
				}
			}
			
			field = this.getSelectedRadioField();
			if (field && field.commedType){
				return Object.toJSON({
					type	: field.commedType
				});
			}
			return "";
		},
		
		getPreviousServiceTask: function(){
			var edge = this.facade.getSelection()[0];
			
			if (edge){
				var gateway = edge.getIncomingNodes()[0];
				if (gateway && gateway.getStencil().id().endsWith("Exclusive_Databased_Gateway") && gateway.getIncomingShapes().length == 1){
					try {
						return gateway.getIncomingShapes()[0].getIncomingShapes()[0];
					} catch(e){}
					
				}
				if (gateway && gateway.getStencil().id().endsWith("Task") && gateway.properties["oryx-tasktype"] === "Service"){
					return gateway;
				}
			}
			
			return null;
		}
		
	});	
	
	/**
	 * Proxy to handle ajax requests to the server
	 * @class
	 * @author Willi Tscheschner
	 */
	var Request = {};
	Request.execute = function(url, callback, params, method, async){
		
		var successcallback = callback instanceof Array ? callback[0] : callback; 
		var failedcallback = callback instanceof Array ? callback[1] : undefined;
		
		new Ajax.Request(url, {
				method		: method || 'get',
				parameters	: params, 
				requestHeaders : {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
				//asynchronous: async === true,
				onSuccess: function(transport){
					var json;
					try {
						json = transport.responseText.evalJSON();	
					} catch(e){
						json = transport.responseText;
					}
					
					if (successcallback instanceof Function)
						successcallback(json, transport);
				},
				onFailure: function(transport){
					if (failedcallback instanceof Function)
						failedcallback( transport);
				}
			});
	};
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Specific class to provide a ComMed Delay attribute
	 * 
	 */
	Ext.ux.propertyeditor.ComMedRoleMapping = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:400, width: 300, resizable: true},

		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if ("string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){ value = {};  }
			} else {
				value = value || {};
			}
			
			return value.name || value.id || "";
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			if ("string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){ value = {};  }
			} else {
				value = value || {};
			}
			
			this.panel = new Ext.Panel({
				border	: false,
				anchor	: "100% 100%",
				layout	: "anchor",
				cls		: "",
				getValue: this.extractValue.bind(this),
				items	: [this.tree = this.getTreePanel(value)]
			});
			
			return this.panel;
		},
		
		getTreePanel: function(value){
			
			// Generate a root node for the tree panel
			var root = new Ext.tree.TreeNode({
				identifier 	: "/commed?proxy=user",
				text		: "Root",
				leaf		: false,
				cls			: "folder",
		        draggable	: false,
		        expanded 	: true,
				dontSort	: true				
			});
			
			
			var loadedParents;
			var loadParents = function(parents){
				if (parents instanceof Array && root.loaded){
					var getNode = function(node, id){
						return node.childNodes.find(function(node){
									return node.attributes.data.rep.id == id;
								});
					};
					var loadNode = function(childNode){
						var parent = parents.shift();
						if (parent){
							var child = getNode(childNode, parent);
							if (child){
								child.expand(false, true, loadNode);
							}
						} else {
							var child = getNode(childNode, value.id);
							if (child){
								child.select();
							}
						}										
					};	
					loadNode(root);
				}
			};
			
			if (value && value.id){
				// Request parent parallel to requesting the root node
				Request.execute("/p/commed?proxy=user&rel=parent&id="+value.id, function(parents){
					loadParents(loadedParents = parents);
				});
			}
			
			return new Ext.tree.TreePanel({
				anchor		: "100% 100%",
				cls			: "x-window-commed-form",
				loader		: new TreeLoader(),
				root		: root,
				animate		: true,
				autoScroll	: true,
				useArrows	: true,
				rootVisible : false,
				afterRender	: function(){
					Ext.tree.TreePanel.prototype.afterRender.apply(this, arguments);
					
					// Waiting spinner
					this.root.ui.wrap.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
											 	"<img src='/libs/ext-2.0.2/resources/images/default/grid/loading.gif' style='margin-right:5px;opacity:0.4;position:relative;top:4px;'/>" +
											 	Ext.ux.getI18N("commed.rolemapping.loadingroles") +
											 "</div>");
					this.getLoader().requestData(this.root, function(){
						Ext.get(root.ui.wrap).first().remove();
						root.loaded = true;
						loadParents(loadedParents);
					});
//					this.getSelectionModel().on("beforeselect", function(s, node){
//						return !node.attributes.data.rep.type.include("CATEGORY");
//					}.bind(this));
				}
			});
			
		},
		
		/**
		 * Returns the value of the selected time delay
		 * 
		 */
		extractValue: function(){
			var node = this.tree.getSelectionModel().getSelectedNode();
			if (node){
				return Object.toJSON({
					id   : node.attributes.data.rep.id,
					name : node.attributes.data.rep.name,
					type : node.attributes.data.rep.type
				});
			}
			return "";
		},
		
		/**
		 * Set performer to the title of the pool
		 * @param oldValue
		 * @param newValue
		 */
		onSave: function(oldValue, newValue){
			this.setValue(newValue);
			
			// Set some attributes
			var key = "oryx-name", sel = this.facade.getSelection(), self = this, name = this.renderer(newValue);
			
			// Use a command to set the property
			var Command = ORYX.Core.Command.extend({
				construct: function(){
					this.shapes 	= sel;
					this.key 		= key;	
					this.value 		= name;
					this.oldValues 	= this.shapes.map(function(e){
						return e.properties[this.key] || "";
					});
				},
				execute: function(){
					this.shapes.invoke("setProperty", this.key, this.value);						
					if (!this.executed) {
						self.fireEvent('dialogClosed', this, newValue, oldValue);
					}
					this.executed = true;
					this.update();
				},
				rollback: function(){
					this.shapes.each(function(shape, i){
						shape.setProperty(this.key, this.oldValues[i]);
					}.bind(this));
					this.update();
				},
				update: function(){
					self.facade.setSelection([]);
					self.facade.setSelection(this.shapes);
				}
			});
			this.facade.executeCommands([new Command()]);

		}
		
	});	
	
	
	
	
	/**
	 * Proxy to handle ajax requests to the server
	 * @class
	 * @author Willi Tscheschner
	 */
	var Request = {};
	Request.execute = function(url, callback, params, method, async){
		
		var successcallback = callback instanceof Array ? callback[0] : callback; 
		var failedcallback = callback instanceof Array ? callback[1] : undefined;
		
		new Ajax.Request(url, {
				method		: method || 'get',
				parameters	: params, 
				requestHeaders : {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
				//asynchronous: async === true,
				onSuccess: function(transport){
					var json;
					try {
						json = transport.responseText.evalJSON();	
					} catch(e){
						json = transport.responseText;
					}
					
					if (successcallback instanceof Function)
						successcallback(json, transport);
				},
				onFailure: function(transport){
					if (failedcallback instanceof Function)
						failedcallback( transport);
				}
			});
	};
	
	
	/**
	 * Implementation of a loaded which loads synchronouse the directories, models
	 * @class
	 * @author Willi Tscheschner
	 */
	var TreeLoader = function(){
		TreeLoader.superclass.constructor.apply(this, arguments);
	};
	
	Ext.extend(TreeLoader, Ext.tree.TreeLoader, {
		/**
		 * Enable requesting
		 */
		dataUrl:true,
		
		isLeaf: function(r){
			return r.rel !== "dir" && r.rep.type !== "CATEGORY_W_CHILDREN" && !r.rep.hasChildren;
		},
		
		getCls: function(r){
			if (r.rel == "form"){
				if (r.rep.type.include("CATEGORY")){
					return ["x-category", r.rep.type == "CATEGORY_EMPTY" ? "x-empty" : undefined].compact().join(" ");
				} else {
					return "x-form";
				}
			} else if (r.rel == "user"){
				return "x-user";
			}			
			return r.rel === "mod" ? "model" : "folder";
		},
		
		requestData: function(node, callback){
			if( node.attributes.identifier ){	
				Request.execute(ORYX.CONFIG.SERVER_HANDLER_ROOT + node.attributes.identifier, function(response){
					window.setTimeout(this.doResponse.bind(this, node, callback, response), 10);
				}.bind(this), {'_dc':Math.random().toFixed(10)});
			}
		},
		
		/**
		 * Generate the data for the nodes depending on the records
		 * @param {Object} records
		 */
		generateNodeData: function(node, data){

			if (node.attributes.dontSort !== true){
				// Sort by title/name
				var df = "name";
				var fn = function(r){ return (r.rep[df]||r.rep.name||r.rep.title||"").toLowerCase(); };
				data = data.sort(function(a,b){ return Number(a.rel > b.rel) || Number(a.rel == b.rel && fn(a) > fn(b)); });
			}

			
			// For every record in the store, append a new child
			return data.map(function(r){
//						if ((r.rel !== "mod" && r.rel !== "dir") || (r.rel === "dir" && r.rep.type === "trash")) {
//							return null;
//						}
						var attr = node.attributes;
						return {
							text		: Signavio.Utils.escapeHTML(Signavio.I18N.Repository.Folder[r.rep.type] || r.rep.name || r.rep.id || attr.value),
							cls			: this.getCls(r),
							leaf		: this.isLeaf(r),
							singleClickExpand : true,
							identifier	: r.href,
							data		: r
						};
					}.bind(this)).compact();
		},
		/**
		 * Callback when loading the new data from the store
		 * @param {Object} store Store where the new data comes from
		 * @param {Object} node Node where the data should append
		 * @param {Object} callback Callback when ready loading
		 * @param {Object} records New records of the store
		 */
		doResponse: function(node, callback, data){
	
			// Get the new items
			var items = this.generateNodeData( node, data );
			
			// Check if there are changes
			if( node.childNodes.length > 0 && node.childNodes.length === items.length && 
				node.childNodes.all(function(n){ return items.any(function(i){ return n.attributes.identifier === i.identifier && n.attributes.text === i.text; }); })){
				return;
			}	
			
			// Hide all childs
			node.collapse();
			
			// Remove all children
			var index = node.childNodes.length-1;
			for(; index>=0; index--){
				node.childNodes[index].remove();
			}
			
			// BEGIN
	        node.beginUpdate();
			// For every record in the store, append a new child
			items.each(function(d){		
				node.appendChild(this.createNode(d));
			}.bind(this));
			// END	
			node.endUpdate();
			
			window.setTimeout(function(){
				node.expand();
			}, 500);
			
			this.fireEvent("update", this, items);
			this.fireEvent("load", this, node);
				
			if(typeof callback == "function"){
	            callback(this, node);
	        }
		}
		
	});
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.ComMedAbstractCall = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width:Math.min(Ext.getBody().getWidth()*0.7, 800), resizable: false},

		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if ("string" == typeof value){
				try  {
					value = value.evalJSON();
				} catch(e){ value = {}; }
			}
			value = value || {};
			
			
			// BOCall
			if (value.boName || value.bo){
				return value.boName || value.bo;
			}
			
			// ServiceCall
			if (value.serviceName || value.service){
				return value.serviceName || value.service;
			}
			
			// SubprocessCall
			if ((value.inputs && value.inputs.length) || (value.outputs && value.outputs.length)){
				return [(value.inputs && value.inputs.length) 	? "Inputs"  : undefined,
						(value.outputs && value.outputs.length) ? "Outputs" : undefined]
							.compact().join(" "+Ext.ux.getI18N("commed.servicecall.and")+" ") + " "+Ext.ux.getI18N("commed.servicecall.aredefined");
			}
			
			return "";
		},
		
		getServicesCombo: function(data){
			
			var store =  new Ext.data.Store({
				baseParams: {},
	            proxy: new Ext.data.HttpProxy({
	            	useAjax	: true,
	            	method	: "GET", 
	            	headers	: {accept:"application/json"},
	                url		: ((Signavio && Signavio.Config && Signavio.Config.BACKEND_PATH)||'/p')+'/commed?proxy=service'
	            }),
	            reader: new Ext.ux.data.RecordReader({rels:'service'})
	        });
			
			var cmb = new Ext.form.ComboBox({
				width			: 216,
			    displayField	: 'rep',
				valueField		: 'rep',
			    triggerAction	: 'all',
			    store			: store,
			    fieldLabel		: "Dienst",
			    readOnly		: true,
			    tpl				: new Ext.XTemplate('<tpl for="."><tpl for="rep"><div class="x-combo-list-item" ext:qtip="{name}">{name}</div></tpl></tpl>'),
			    listeners		: {
			    	select : this.onServiceChange.bind(this)
			    },
			    render : function(){
			    	Ext.form.ComboBox.prototype.render.apply(this, arguments);
			    	
					// Preselect the given service
					if (data && data.service){
						cmb.setValue({id: data.service, name: data.serviceName || data.service});
						cmb.setRawValue(data.serviceName || data.service);
					}
			    },
			    setValue : function(v){
			        var text = v;
			        if(this.valueField){
			            var r = this.findRecord(this.valueField, v);
			            if(r){  text = r.get("rep").name; }
			        }
			        this.lastSelectionText = text;
			        if(this.hiddenField){
			            this.hiddenField.value = v;
			        }
			        Ext.form.ComboBox.superclass.setValue.call(this, text);
			        this.value = v;
			    }
			});
			
			return cmb;
		},

		getBOCombo: function(data){
			
			var store =  new Ext.data.Store({
				baseParams: {},
	            proxy: new Ext.data.HttpProxy({
	            	useAjax	: true,
	            	method	: "GET", 
	            	headers	: {accept:"application/json"}
	            }),
	            reader: new Ext.ux.data.RecordReader({rels:'bo'})
	        });
			
			if (data.service){
				store.proxy.conn.url = ((Signavio && Signavio.Config && Signavio.Config.BACKEND_PATH)||'/p')+'/commed?proxy=bo&serviceId='+data.service;
			}
			
			var cmb = new Ext.form.ComboBox({
				width			: 216,
			    displayField	: 'rep',
				valueField		: 'rep',
			    triggerAction	: 'all',
			    readOnly		: true,
			    store			: store,
			    fieldLabel		: "BO",
			    tpl				: new Ext.XTemplate('<tpl for="."><tpl for="rep"><div class="x-combo-list-item" ext:qtip="{name}">{name}</div></tpl></tpl>'),
			    listeners		: {
			    	select : this.onBOChange.bind(this)
			    },
			    render : function(){
			    	Ext.form.ComboBox.prototype.render.apply(this, arguments);
			    	
					// Preselect the given service
					if (data && data.bo){
						cmb.setValue({id: data.bo, name: data.boName || data.bo});
						cmb.setRawValue(data.boName || data.bo);
					}
			    },
			    setValue : function(v){
			        var text = v;
			        if(this.valueField){
			            var r = this.findRecord(this.valueField, v);
			            if(r){  text = r.get("rep").name; }
			        }
			        this.lastSelectionText = text;
			        if(this.hiddenField){
			            this.hiddenField.value = v;
			        }
			        Ext.form.ComboBox.superclass.setValue.call(this, text);
			        this.value = v;
			    }
			});
			
			return cmb;
		},
		
		
		mappingRenderer: function(rep, meta, rec){
			if (rec.get("out") && rec.get("out").mode == "INOUT"){
				return "<span style='color:silver;' ext:qtip='" +(rep && rep.name)+ "'>"+(rep && rep.name)+"</span>";
			}
			return "<span ext:qtip='" +(rep && rep.name)+ "'>" + (rep && rep.name) + "</span>";
		},
		
		valueRenderer: function(rep, meta, rec){
			var res = "";
			if (rep instanceof Array){
				res = rep.pluck("name").join(", ");
			} else {
				res = (rep && rep.name) || rep || "";
			}
			
			if (this.getType(rec) == "constant"){
				res = "<u>"+res+"</u>";
			}
			
			if (rec.get("out") && rec.get("out").mode == "INOUT"){
				res = "<span style='color:silver;'>" +(res)+ "</span>";
			}
			
			return res;
		},
		
		/**
		 * Returns the defined workflow variables which are defined on canvas level
		 * @param {String} type
		 * @returns {Array}
		 */
		getWorkflowVariable: function(type, isList){
			try {
				var wf = this.facade.getCanvas().properties["oryx-workflow_variablen"];
				if ("undefined" == typeof wf){
					wf = this.facade.getCanvas().getStencil().property("oryx-workflow_variablen").value();
				}
				wf = (wf||"{}").evalJSON();
				
				var items = wf.items || [],
					allowedTypes = [];
				
				switch(type.toLowerCase()){
					case "java.lang.integer":
					case "java.lang.double":
					case "java.lang.float":
					case "java.lang.long":
					case "java.lang.short":
					case "java.math.bigdecimal":
					case "java.lang.number":
						allowedTypes = ["string", "float", "integer"]; break;
						
					case "java.lang.boolean":
						allowedTypes = ["string", "boolean"]; break;
						
					case "java.lang.enum":
						allowedTypes = ["string", "integer"]; break;

					case "java.lang.string":
						allowedTypes = ["string", "boolean", "float", "integer"]; break;

					case "java.util.date":
						allowedTypes = ["string", "date"]; break;
						
					case "java.lang.object":
						allowedTypes = undefined; break;

					case "de.commed.carestation.core.persistence.AbstractEntity".toLowerCase():
					case "de.commed.carestation.components.bl.process.IServiceBean".toLowerCase():
					case "de.commed.carestation.model.services.formprocessor.DataDefinition".toLowerCase():
					case "de.commed.carestation.model.common.internal.catalogue.GenericBenefit".toLowerCase():
						allowedTypes = ["string"]; break;						
				}
				
				if (isList === true && allowedTypes){
					allowedTypes = [].concat(allowedTypes, allowedTypes.map(function(r){return r+"[]"; }));
				}
				
				// Returns all workflow variable of the allowed types
				return items.findAll(function(r){ return !allowedTypes || allowedTypes.include(r.type.toLowerCase()); });
			} catch(e){
				return [];
			}
		},
		
		/**
		 * Returns a list of values which are also 
		 * allowed for the given mapping additional
		 * to the work flow variables.
		 * @param {Object} mapping
		 * @returns {Array}
		 */
		getAllowedValues: function(mapping){
			var values = [];
			switch((mapping && mapping.type.toLowerCase()) || ""){
				case "java.lang.boolean":
					values.push({id:"true", name:"true"});
					values.push({id:"false", name:"false"});
					break;
			}
			return [].concat(values, mapping.allowedvalues || []);
		},
		
		/**
		 * 
		 */
		getFormTreePanel: function(value){
			
			// Generate a root node for the tree panel
			var root = new Ext.tree.TreeNode({
				identifier 	: "/commed?proxy=form",
				text		: "Root",
				leaf		: false,
				cls			: "folder",
		        draggable	: false,
		        expanded 	: true,
				dontSort	: true				
			});
			

			var loadedParents;
			var loadParents = function(parents){
				if (parents instanceof Array && root.loaded){
					var getNode = function(node, id){
						return node.childNodes.find(function(node){
									return node.attributes.data.rep.id == id;
								});
					};
					var loadNode = function(childNode){
						var parent = parents.shift();
						if (parent){
							var child = getNode(childNode, parent);
							if (child){
								child.expand(false, true, loadNode);
							}
						} else {
							var child = getNode(childNode, value.id);
							if (child){
								child.select();
							}
						}										
					};	
					loadNode(root);
				}
			};
			
			if (value && value.id){
				// Request parent parallel to requesting the root node
				Request.execute("/p/commed?proxy=form&rel=parent&id="+value.id, function(parents){
					loadParents(loadedParents = parents);
				});
			}
			
			
			return new Ext.tree.TreePanel({
				anchor		: "100% 100%",
				loader		: new TreeLoader(),
				root		: root,
				animate		: true,
				autoScroll	: true,
				useArrows	: true,
				rootVisible : false,
				afterRender	: function(){
					Ext.tree.TreePanel.prototype.afterRender.apply(this, arguments);
					
					// Waiting spinner
					this.root.ui.wrap.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
											 	"<img src='/libs/ext-2.0.2/resources/images/default/grid/loading.gif' style='margin-right:5px;opacity:0.4;position:relative;top:4px;'/>" +
											 	Ext.ux.getI18N("commed.servicecall.loadingformulars") +
											 "</div>");
					this.getLoader().requestData(this.root, function(){
						Ext.get(root.ui.wrap).first().remove();
						root.loaded = true;
						loadParents(loadedParents);
					});
					this.getSelectionModel().on("beforeselect", function(s, node){
						return !node.attributes.data.rep.type.include("CATEGORY");
					}.bind(this));
				}
			});
		},
		
		/**
		 * Returns the editor for the formulars
		 * @returns {Ext.grid.GridEditor}
		 */
		getFormEditor: function(mapping, record){
			var me = this, tree, editor;
			
			return editor = new Ext.grid.GridEditor(new Ext.form.TriggerField({
				triggerClass	: "x-trigger-other",
			    setValue : function(v){
			        var text = "string" == typeof v ? v : v.name;
			        Ext.form.ComboBox.superclass.setValue.call(this, text);
			        this.value = v;
			    },
			    getValue: function(){
			    	return this.value;
			    },
				onTriggerClick	: function(){
					editor.completeEdit();
					var win = new Ext.Window({
						title	: Ext.ux.getI18N("commed.servicecall.formulars"),
						cls		: "x-window-commed-form",
						width	: 400,
						height	: 400,
						layout	: "anchor",
						bodyStyle: "background:white;padding:10px;",
						modal	: true,
						items	: [tree = me.getFormTreePanel(this.getValue())],
						buttons	:[{
							text: Ext.ux.getI18N("btnsave"),
							handler: function(){
								var value = tree.getSelectionModel().getSelectedNode();
								if (value){
									var rep = value.attributes.data.rep;
									record.data.value = "";
									record.set("value", {
										id	: rep.id,
										name: rep.name
									});
								} else {
									record.set("value", "");
								}
								record.commit();
								win.close();
								this.value = record.get("value");
							}.bind(this)
						}, {
							text: Ext.ux.getI18N("btnclose"),
							handler: function(){
								win.close();
							}.bind(this)
						}]
					});
					win.show();
				}
			}));
		},

		
		
		/**
		 * 
		 */
		getMeasureTreePanel: function(){
			
			var url = "/commed?proxy=measure";
			
			// Generate a root node for the tree panel
			var root = new Ext.tree.TreeNode({
				identifier 	: url,
				text		: "Root",
				leaf		: false,
				cls			: "folder",
		        draggable	: false,
		        expanded 	: true,
				dontSort	: true				
			});
			
			
			var tree = new Ext.tree.TreePanel({
				loader		: new TreeLoader(),
				anchor		: "100% -27",
				root		: root,
				animate		: true,
				autoScroll	: true,
				useArrows	: true,
				rootVisible : false,
				afterRender	: function(){
					Ext.tree.TreePanel.prototype.afterRender.apply(this, arguments);
					
					// Waiting spinner
					this.root.ui.wrap.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
											 	"<img src='/libs/ext-2.0.2/resources/images/default/grid/loading.gif' style='margin-right:5px;opacity:0.4;position:relative;top:4px;'/>" +
											 	Ext.ux.getI18N("commed.servicecall.loadingmeasures") +
											 "</div>");
					this.getLoader().requestData(this.root, function(){
						Ext.get(root.ui.wrap).first().remove();
					});
					this.getSelectionModel().on("beforeselect", function(s, node){
						return !node.attributes.data.rep.type.include("CATEGORY");
					}.bind(this));
				}
			});
			
			var search = function(query){
				// Normalize
				query = (query || "").trim();
				
				// Set search query
				tree.root.attributes.identifier = url + (query ? "&q=" + query : "");
				
				// Waiting spinner
				tree.root.ui.wrap.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
										 	"<img src='/libs/ext-2.0.2/resources/images/default/grid/loading.gif' style='margin-right:5px;opacity:0.4;position:relative;top:4px;'/>" +
										 	Ext.ux.getI18N("commed.servicecall.performingsearch") +
										 "</div>");
				
				// Request
				tree.getLoader().requestData(tree.root, function(){
					Ext.get(root.ui.wrap).first().remove();
					if (root.childNodes.length === 0){
						root.ui.wrap.update("<div style='color:silver;font-style:italic;margin-left:5px;margin-top:4px;'>" +
								Ext.ux.getI18N("commed.servicecall.nofound") +
							 "</div>");
					}
				});
			};
			
			
			return new Ext.Panel({
				border: false,
				columnWidth: 0.5,
				height: 401,
				layout: "anchor",
				tree: tree,
				bodyStyle:"padding:0;",
				items:[new Ext.form.TriggerField({
					emptyText: "Suche...",
					anchor:"100%",
					style:"margin-bottom: 5px; border: 1px solid #777777;",
					triggerClass: "x-form-search-trigger",
					listeners: {
						specialkey: function(foo, evt){
							if (evt.getKey() == evt.ENTER)
								search(this.getValue());
						}
					},
					onTriggerClick: function(){
						search(this.getValue());
					}
				}), tree]
			});
		},
		
		getMeasureListPanel: function(values){
			var val = [];
			if (values instanceof Array){
				val = values.map(function(r){
					return ["measure", "id", r];
				})
			}
			return new Ext.DataView({
				store	: new Ext.data.SimpleStore({
					fields: ['rel', 'href', 'rep'],
					data: val
				}),
				columnWidth	: 0.5,
				cls			: "x-commed-measurelist",
				height		: 400,
				tpl			: new Ext.XTemplate('<tpl for="."><div class="x-item"><tpl for="rep">{name}</tpl></div></tpl>'),
				singleSelect : true,
				overClass	 : "x-view-hover",
				itemSelector : ".x-item",
				emptyText	 : "<div style='color:silver;font-style:italic;padding:5px 5px 0;'>"+Ext.ux.getI18N("commed.servicecall.nomeasuresselected")+"</div><div style='color:#DDDDDD;font-style:italic;padding:5px 5px 0;'>"+ Ext.ux.getI18N("commed.servicecall.pleaseselect") +"</div>"
			});
		},
		
		/**
		 * Returns the editor for the formulars
		 * @returns {Ext.grid.GridEditor}
		 */
		getMeasureEditor: function(mapping, record, multiSelect){
			var me = this;
			
			var editor = new Ext.grid.GridEditor(new Ext.form.TriggerField({
				triggerClass	: "x-trigger-other",
			    setValue : function(v){
			        var text = "string" == typeof v ? v : (v instanceof Array ? v.pluck("name").join(", ") : "");
			        Ext.form.ComboBox.superclass.setValue.call(this, text);
			        this.value = v;
			    },
			    getValue: function(){
			    	return this.value;
			    },
				onTriggerClick	: function(){
					var tree, list, btnLR, btnRL;
					var win = new Ext.Window({
						title	: Ext.ux.getI18N("commed.servicecall.measure"),
						width	: 600,
						cls		: "x-window-commed-form x-window-commed-measure",
						layout	: "column",
						resizable: false,
						bodyStyle: "background:white;padding:10px;",
						modal	: true,
						items	: [tree = me.getMeasureTreePanel(),
						     	   new Ext.Panel({
						     		   border	: false,
						     		   width	: 50,
						     		   height	: 400,
						     		   bodyStyle: "padding: 177px 13px;background:white;",
						     		   items	:[btnLR = new Ext.Button({
						     			   icon		: Ext.IMAGE_URL+"/famfamfam/arrow_right.png",
						     			   iconCls	: "x-dummy",
						     			   style	: "margin-bottom:5px;",
						     			   disabled	: true,
						     			   handler	: function(){
						     				   var node = tree.tree.getSelectionModel().getSelectedNode();
						     				   if (node){
						     					   node = node.attributes.data;
						     					   list.store.loadData([[node.rel, node.href, node.rep]], true);
						     					   btnLR.disable();
						     				   }
						     			   }
						     		   }),btnRL = new Ext.Button({
						     			   icon		: Ext.IMAGE_URL+"/famfamfam/arrow_left.png",
						     			   iconCls	: "x-dummy",
						     			   disabled	: true,
						     			   handler	: function(){
						     				   [].concat(list.getSelectedRecords()).each(function(record){
						     					   list.store.remove(record);
						     				   });
						     				   list.store.commitChanges();
						     				   list.refresh();
						     				  tree.tree.getSelectionModel().fireEvent("selectionchange");
						     			   }
						     		   })]
						     	   }),
						     	   list = me.getMeasureListPanel(record && record.get("value"))],
						buttons	:[{
							text: Ext.ux.getI18N("btnsave"),
							handler: function(){
								var values = list.store.getRange();
								if (values && values.length){
									record.data.value = "";
									record.set("value", values.map(function(rec){
										var rep = rec.get("rep");
										return {
											id	: rep.id,
											name: rep.name
										};
									}));
								} else {
									record.set("value", "");
								}
								record.commit();
								win.close();
								this.value = record.get("value");
							}.bind(this)
						}, {
							text: Ext.ux.getI18N("btnclose"),
							handler: function(){
								win.close();
							}.bind(this)
						}]
					});
					win.show();
					
					
					if (!multiSelect){
						var updateLRButton = function(){
							if (list.store.getCount() >= 1)
								btnLR.disable();
						};
						list.store.on("datachange", updateLRButton);
						list.store.on("load", updateLRButton);
						list.store.on("add", updateLRButton);
						list.store.on("remove", updateLRButton);
					}

					// Enable/disable buttons
					tree.tree.getSelectionModel().on("selectionchange", function(){
						var node = tree.tree.getSelectionModel().getSelectedNode();
						if (node && (multiSelect || list.store.getCount() < 1)){
							if (list.store.find("href", node.attributes.data.href) == -1){
								btnLR.enable();
								return;
							}
						}
						btnLR.disable();
					});
					
					list.on("selectionchange", function(){
						if (list.getSelectionCount() > 0){
							btnRL.enable();
						} else {
							btnRL.disable();
						}
					});
				}
			}));
			
			
			return editor;
		},
		
		/**
		 * Retruns the cell editor for a given mapping
		 * @param {Object} mapping
		 * @param {Ext.data.Record} record
		 * @returns {Ext.grid.GridEditor}
		 */
		getCellEditor: function(mapping, record){
			
			// FORM EDITOR
			if (mapping.type.toLowerCase() === "de.commed.carestation.model.services.formprocessor.DataDefinition".toLowerCase()){
				return this.getFormEditor(mapping, record);
			} else if (mapping.type.toLowerCase() === "de.commed.carestation.model.common.internal.catalogue.GenericBenefit".toLowerCase()){
				return this.getMeasureEditor(mapping, record, (record.get("out")||record.get("in")||{}).isList === true);
			}
			
			// Get the workflow variable
			var wfVariable = this.getWorkflowVariable(mapping.type, mapping.isList);
			// Prepend default values (mainly for enums)
			wfVariable = [].concat(this.getAllowedValues(mapping), wfVariable);
			
			
			var isNumber = ["java.lang.integer","java.lang.double","java.lang.float","java.lang.long",
						     "java.lang.short","java.math.bigdecimal","java.lang.number"].include(mapping.type.toLowerCase()),
				isFloat = ["java.lang.float","java.lang.double","java.math.bigdecimal","java.lang.number"].include(mapping.type.toLowerCase());
			
			// Generate the combo box
			var combo = new Ext.form.ComboBox({
				selectOnFocus	: true,
				forceSelection 	: false,
				forceAll		: true,
			    displayField	: 'name',
				valueField		: 'rep',
				mode			: 'local',
				readOnly		: ["java.lang.boolean", "java.lang.enum"].include(mapping.type.toLowerCase()),
				editable 		: !record.get("out"),
				doQuery			: function(r){ return Ext.form.ComboBox.prototype.doQuery.call(this, r, true); },
				onKeyUp			: function(){},
				initEvents		: function(){
					
					Ext.form.ComboBox.prototype.initEvents.call(this);
					
					if (isNumber){
						var baseChars = "0123456789-";
						if (isFloat){
							baseChars += ".,";
						}
						
				        var keyPress = function(e){
				            var k = e.getKey();
				            if(!Ext.isIE && k == e.browserEvent.keyCode && (e.isSpecialKey() || k == e.BACKSPACE || k == e.DELETE)){
				                return;
				            }
				            var c = e.getCharCode();
				            if(baseChars.indexOf(String.fromCharCode(c)) === -1){
				                e.stopEvent();
				            }
				        };
				        this.el.on("keypress", keyPress, this);
					}		
				
				},
				getValue 		: function(){
					var t = this.getRawValue();
			        t = this.value && this.value.name == t ? this.value : t;
			        if (isNumber && "string" == typeof t){
			        	var num = Number(t.replace(/,/g, "."));
			        	if (num && !isNaN(num)){
			        		t = String(num);
			        	} else {
			        		t = t == "0" ? t : "";
			        	}
			        }
			        return t;
			    },
			    setEditable : function(){
			    	Ext.form.ComboBox.prototype.setEditable.apply(this, arguments);
			    	this.el.dom.setAttribute('readonly', this.editable === false);
			    },
			    setValue : function(v){
			        var text = "string" == typeof v ? v : v.name;
			        this.lastSelectionText = text;
			        if(this.hiddenField){
			            this.hiddenField.value = v;
			        }
			        Ext.form.ComboBox.superclass.setValue.call(this, text);
			        this.value = v;
			    },
			    store			: new Ext.data.SimpleStore({
			    	fields 	: ['id', 'name', 'rep'],
			    	data 	: wfVariable.map(function(r){ return [r.id, r.name, r]; })
			    }),
			    onEmptyResults : function(){
					this.view.el.update('<div class="x-no-entry" style="color:silver;font-size:11px;font-style:italic;padding:2px 5px;">'+Ext.ux.getI18N("commed.servicecall.nowfv")+'</div>');
					this.expand();
					this.restrictHeight();
			    }
			});
			
			return new Ext.grid.GridEditor(combo);
		},
		
		/**
		 * Returns a panel which is necessary for the input mapping (left panel)
		 * @returns {Ext.Panel}
		 */
		getInputMapping: function(inputs){
			
			var cm = new Ext.grid.ColumnModel([{'dataIndex': 'value', 'header':"Input-Variable", editable: true, renderer: this.valueRenderer.bind(this)},
			    				       		   {'dataIndex': 'in', 'header':"Service-Feld", renderer: this.mappingRenderer.bind(this)}]);
			cm.getCellEditor = function(col, row){
				if (col == 0){
					var rec = this.input.store.getAt(row);
					return this.getCellEditor(rec.get("in"), rec);
				}
			}.bind(this);
			
			var me = this;
			
			return new Ext.grid.EditorGridPanel({
				height		: 350,
				initialValue: inputs,
				border		: true,
				enableColumnMove: false,
				enableHdMenu: false,
				cm			: cm,
				clicksToEdit: 1,
				viewConfig	: {
					forceFit	: true
				},
				onEditComplete : function(ed, value){ 
					ed.record.data.value = undefined;
					Ext.grid.EditorGridPanel.prototype.onEditComplete.call(this, ed, value, value == "" ? -1 : ""); 
					 
		    		
					//Check for mandatory fields
		    		var td = this.body.dom.descendants().findAll(function(el) {return el.nodeName === "table"}).slice(1).map(function(tab){return tab.descendants().find(function(el){return el.nodeName === "td"})});
		    		var mand = this.store.data.items.map(function(item){return item.data});
		    		for (var i = 0; i < mand.length; i++){
			    		if (mand[i].value === "" && mand[i]["in"].mandatory && td[i]) {	
			    			td[i].setAttribute("style", "background-image:url('" +Ext.IMAGE_URL+"/famfamfam/bullet_error.png'); background-repeat:no-repeat; background-position:95%" );
			    		}
		    		}
				}, 
				
				store		: new Ext.data.SimpleStore({
					fields		: ['value', 'in'],
					data		: [],
					listeners	: {
						/**
						 * Set value of output mapping to the
						 * same than the input mapping if INOUT is
						 * defined as mode.
						 */
						update: function(store, rec){
							if (rec.get("in").mode === "INOUT"){
								var id = rec.get("in").id,
									out = this.output.store.getRange().find(function(out){
												return out.get("out").id == id;
											});
								
								if (out){
									out.set("value", undefined);
									out.set("value", rec.get("value"));
								}
							}
						}.bind(this)
					}
				}),
				wait		: function(){
					this.view.mainBody.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
											 	"<img src='/libs/ext-2.0.2/resources/images/default/grid/loading.gif' style='margin-right:5px;opacity:0.4;position:relative;top:4px;'/>" +
											 	 me.getInputLoadingText()+
											 "</div>");
				},
				defaultText	: function(){
					this.view.mainBody.update("<div style='color:silver;font-style:italic;margin:5px;'>" +
											 	 me.getInputEmptyText()+
											 "</div>");
				}
			});
		},
		
		/**
		 * Returns a panel which is necessary for the output mapping (output panel)
		 * @returns {Ext.Panel}
		 */
		getOutputMapping: function(outputs){
			
			var me = this, 
				cm = new Ext.grid.ColumnModel([{'dataIndex': 'out', 'header':"Service-Feld", renderer: this.mappingRenderer.bind(this)},
			                                   {'dataIndex': 'value', 'header':"Output-Variable", editable: true, renderer: this.valueRenderer.bind(this)}]);
			cm.getCellEditor = function(col, row){
				if (col == 1){
					var rec = this.output.store.getAt(row);
					return this.getCellEditor(rec.get("out"), rec);
				}
			}.bind(this);
			
			// Set readonly for INOUT mappings
			cm.isCellEditable = function(col, row){
				if (col == 1){
					var rec = me.output.store.getAt(row);
					if (rec.get("out").mode == "INOUT"){
						return false;
					}
				}
				return Ext.grid.ColumnModel.prototype.isCellEditable.apply(this, arguments);
			};
			
			var me = this;
			
			return new Ext.grid.EditorGridPanel({
				height		: 350,
				initialValue: outputs,
				border		: true,
				enableColumnMove: false,
				enableHdMenu: false,
				cm			: cm,
				clicksToEdit: 1,
				viewConfig	: {
					forceFit	: true
				},
				onEditComplete : function(ed, value){ 
					ed.record.data.value = undefined;
					return Ext.grid.EditorGridPanel.prototype.onEditComplete.call(this, ed, value, value == "" ? -1 : ""); 
				}, 
				store		: new Ext.data.SimpleStore({
					fields		: ['out', 'value'],
					data		: []
				}),
				wait		: function(){
					this.view.mainBody.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
											 	"<img src='/libs/ext-2.0.2/resources/images/default/grid/loading.gif' style='margin-right:5px;opacity:0.4;position:relative;top:4px;'/>" +
											 	 me.getOutputLoadingText()+
											 "</div>");
				},
				defaultText	: function(){
					this.view.mainBody.update("<div style='color:silver;font-style:italic;margin:5px;'>" +
											 	me.getOutputEmptyText() +
											 "</div>");
				}
			});
		},
		
	
		/**
		 * Returns a panel which shows some more information to the selected service
		 * @returns {Ext.Panel}
		 */
		getInfoCenterPanel: function(){
			var me = this;
			return new Ext.Panel({
				width		: 150,
				border		: false,
				bodyStyle	: "padding: 10px;",
				html		: "",
				update		: function(service){
				
					if (service){
						var desc = service.get("rep");
						desc.description = desc.description
												.replace(/<[\/\s]*pre[\/\s]*>/g, "")
												.replace(/<li\/>/gi, "</li>");
						try {
						
							new Ext.XTemplate("<img src='"+Ext.IMAGE_URL+"/famfamfam/32x32/cog_go.png' style='margin: 10px 0 10px 49px;'/><div style='font-weight:bold;margin-bottom:5px;'>{name}</div><div class='x-format-list'>{description}</div>").overwrite(this.body, desc);
						
						} catch(e){
							// Fail back
							desc.description = String(desc.description).escapeHTML();
							new Ext.XTemplate("<img src='"+Ext.IMAGE_URL+"/famfamfam/32x32/cog_go.png' style='margin: 10px 0 10px 49px;'/><div style='font-weight:bold;margin-bottom:5px;'>{name}</div><div class='x-format-list'>{description}</div>").overwrite(this.body, desc);
						}
					} else {
						this.body.update("<img src='"+Ext.IMAGE_URL+"/famfamfam/32x32/cog_go.png' style='margin: 10px 0 10px 49px;opacity: 0.3;'/>"+
										 "<div style='color:silver;font-style:italic;text-align:center;'>" +
										 	 me.getServiceEmptyText()+
										 "</div>");
					}
				},
				wait: function(){
					this.body.update("<img src='"+Ext.IMAGE_URL+"/famfamfam/32x32/cog_go.png' style='margin: 10px 0 10px 49px;opacity: 0.3;'/>"+
									 "<div style='color:silver;font-style:italic;text-align:center;'>" +
									 	"<img src='/libs/ext-2.0.2/resources/images/default/grid/loading.gif' style='margin-right:5px;opacity:0.4;position:relative;top:4px;'/>" +
									 	me.getSeriveLoadingText() +
									 "</div>");
				}
			});
		},
		

		getInputLoadingText: function(){
			return Ext.ux.getI18N("commed.servicecall.loadinginputs");
		},		

		getInputEmptyText: function(){
			return Ext.ux.getI18N("commed.servicecall.noinputs");
		},		

		getOutputLoadingText: function(){
			return Ext.ux.getI18N("commed.servicecall.loadingoutputs");
		},		

		getOutputEmptyText: function(){
			return Ext.ux.getI18N("commed.servicecall.nooutputs");
		},
		
		getSeriveLoadingText: function(){
			return Ext.ux.getI18N("commed.servicecall.loadinservice");
		},		

		getServiceEmptyText: function(){
			return Ext.ux.getI18N("commed.servicecall.selectservice");
		},
		
		
		getCurrentServiceURL: function(){
			if (this.service && this.service.getValue()){
				return ((Signavio && Signavio.Config && Signavio.Config.BACKEND_PATH)||'/p')+'/commed?proxy=service&id='+this.service.getValue().id
			}
			return false;
		},
		
		onServiceChange: function(fn){
			this.updateMappingPanels(fn);
		},
		
		onBOChange: function(fn){
			this.updateMappingPanels(fn);
		},
		
		/**
		 * Callback, which get called after the service has been selected or changed
		 * 
		 */
		updateMappingPanels: function(fn){
			var url = this.getCurrentServiceURL();
			if (url){
				var store = new Ext.data.Store({
					baseParams: {},
		            proxy: new Ext.data.HttpProxy({
		            	useAjax	: true,
		            	method	: "GET", 
		            	headers	: {accept:"application/json"},
		                url		: url
		            }),
		            reader: new Ext.ux.data.RecordReader({rels:['service','subprocess','bo']})
		        });
				store.load({callback:function(store){
		        
					var inputs = [], outputs = [], records, mappings; 
					
					try {
			        	record 	 = store.getAt(0);
		        		mappings = record.get("rep").parameters;
	        			inputs 	 = mappings.findAll(function(rep){ return rep.mode.toUpperCase().include("IN"); });
	        			outputs  = mappings.findAll(function(rep){ return rep.mode.toUpperCase().include("OUT"); });
					} catch(e){ }
					
		        	// Fill with empty values and load data to the input/output store
					if (record){
						this.setServiceValues(record, inputs, outputs);
					} else {
						this.setEmptyValues();
					}
					
					if (fn instanceof Function){
						fn();
					}		        	
		        }.bind(this, store)});
		        

				this.input.ownerCt.enable();
				this.output.ownerCt.enable();
				[this.input, this.output, this.center].invoke("wait");
				
			} else {
				this.setEmptyValues();
			}
			
		},
		
		/**
		 * Disables and reset the 
		 * input, output and center panel
		 * 
		 */
		setEmptyValues: function(){
			this.input.ownerCt.disable();
			this.output.ownerCt.disable();
			this.input.defaultText();
			this.output.defaultText();
			this.center.update();
		},
		
		/**
		 * 
		 * @param rec
		 * @returns
		 */
		getDefaultMapping: function(rec){
			
			var wf = this.facade.getCanvas().properties["oryx-workflow_variablen"];
			if ("undefined" == typeof wf){
				wf = this.facade.getCanvas().getStencil().property("oryx-workflow_variablen").value();
			}
			wf = (wf||"{}").evalJSON();
			
			var items = wf.items || [],
				name = rec.id,
				id;
			
			if (!!name.match(new RegExp("^.*(EPRCONTAINEROID.*|EPROID.*|EPR_OID.*|EPR)$", "i"))){
				id = "BL_OBJ_PROCESS_PATHWAY_OID";
			} else if (!!name.match(new RegExp("^.*(CASEOID.*|CASE_OID.*|CASE)$", "i"))){
				id = "CASEOID";				
			} else if (!!name.match(new RegExp("^.*(CASEMIGRATIONOID.*|CMOID.*|CASEMIGRATION_OID.*|CASEMIGRATION)$", "i"))){
				id = "BL_OBJ_PROCESS_CASEMIG_OID";				
			}
			
			if (id){
				var item = items.find(function(e){ return e.id.toUpperCase() == id; });
				if (item){
					return item;
				}
			}
			
			return "";			
		},
		
		/**
		 * 
		 * 
		 */
		setServiceValues: function(record, inputs, outputs){
			var me = this;
			
			// Set the input values with default values
			inputs = $R(0, inputs.length-1).map(function(){ return ""; }).zip(inputs);
			var initialValues = this.input.initialConfig.initialValue || [];
			inputs.each(function(rec){
				var input = rec[1];
				var initial = initialValues.find(function(r){ return r.id == input.id; });
				if (initial){
					rec[0] = initial.value;
				} else {
					rec[0] = me.getDefaultMapping(rec[1]);
				}
			});
			
			// Set the output values with default values
			outputs = outputs.zip($R(0, outputs.length-1).map(function(){ return ""; }));
			var initialValues = this.output.initialConfig.initialValue || [];
			outputs.each(function(rec){
				var output = rec[0];
				var initial = initialValues.find(function(r){ return r.id == output.id; });
				if (initial){
					rec[1] = initial.value;
				} else {
					rec[1] = me.getDefaultMapping(rec[0]);
				}
			});
			
			// Set the data
			if (inputs.length){
				this.input.store.loadData(inputs);
			} else {
				this.input.defaultText();
			}
			if (outputs.length){
				this.output.store.loadData(outputs);
			} else {
				this.output.defaultText();
			}
    		this.center.update(record);
    		
    		//Check for mandatory fields
    		var td = this.input.body.dom.descendants().findAll(function(el) {return el.nodeName === "table"}).slice(1).map(function(tab){return tab.descendants().find(function(el){return el.nodeName === "td"})});
    		var mand = this.input.store.data.items.map(function(item){return item.data});
    		for (var i = 0; i < mand.length; i++){
	    		if (mand[i].value === "" && mand[i]["in"].mandatory && td[i]) {	
	    			td[i].setAttribute("style", "background-image:url('"+Ext.IMAGE_URL+"/famfamfam/bullet_error.png'); background-repeat:no-repeat; background-position:95%" );
	    		}
    		}
		},
		
		/**
		 * 
		 */
		onWindowRendered: function(){
			this.updateMappingPanels();
		},
		
		/**
		 * Returns TRUE if the service call combobox is enabled
		 * @returns {Boolean}
		 */
		isServiceCallEnabled: function(){
			throw new Error("isServiceCallEnabled must be implemented by its concrete implementation.");
		},	
		
		/**
		 * Returns TRUE if the service call combobox is enabled
		 * @returns {Boolean}
		 */
		isBOCallEnabled: function(){
			throw new Error("isBOCallEnabled must be implemented by its concrete implementation.");
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			if ("string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){ value = {};  }
			} else {
				value = value || {};
			}
			
			this.panel = new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "anchor",
				cls: "x-window-commed-service-call",
				getValue: this.extractValue.bind(this),
				hideBorders: true,
				items: [this.isServiceCallEnabled() ? new Ext.Panel({
							layout: "form",
							anchor: "100%",
							bodyStyle:!this.isBOCallEnabled() ? "padding-bottom:5px;" : "",
						    labelWidth: 87,
							items: [this.service = this.getServicesCombo(value||undefined)]
						}) : undefined,
						this.isBOCallEnabled() ? new Ext.Panel({
							layout: "form",
							anchor: "100%",
							bodyStyle:"padding-bottom:5px;",
						    labelWidth: 87,
						    disabled: !value.bo,
							items: [this.bo = this.getBOCombo(value||undefined)]
						}) : undefined,
						new Ext.Panel({
							layout: "column",
							anchor: "100%",
							bodyStyle : "",
							items: [new Ext.Panel({
										columnWidth	: 0.5, 
										border		: false,
										items		: [new Ext.form.Label({text:"Input:", style:"display:block;margin-bottom:3px;"}),
										     		   this.input  = this.getInputMapping(value.inputs)]
									}),
							        this.center = this.getInfoCenterPanel(), 
							        new Ext.Panel({
										columnWidth	: 0.5,
										border		: false,
										items		: [new Ext.form.Label({text:"Output:", style:"display:block;margin-bottom:3px;"}),
										     		   this.output = this.getOutputMapping(value.outputs)]
									})]
						})].compact()
			});
			
			// Add close button
			if (value && (value.service||value.bo)){
				this.windowCreate.buttons = [new Ext.Button({
						text 	: Ext.ux.getI18N("commed.servicecall.remove"),
						handler : function(){
							this.onSave(this.getValue(), "");	
							this.panel.ownerCt.close();
						}.bind(this),
						template: new Ext.Template("<a href='#' class='x-button-plain' style='color: white;display: block; font-size: 11px; padding: 2px 5px;'>{0}</a>"), 
						onRender: function(){
							this.el = Ext.get(this.template.overwrite(this.container.dom, [this.text]));
							this.el.on("click", function(e,t){
								this.handler.apply(this, arguments);
								e.stopEvent(); 
								return false;
							}.bind(this));
						}
					})];
			}
			return this.panel;
		},
		
		getType: function(r){
			var inout = r.get("in") || r.get("out");
			if (inout){
				// FORM
				if (inout.type.toLowerCase() === "de.commed.carestation.model.services.formprocessor.DataDefinition".toLowerCase()){
					return "form";
				} else if (inout.type.toLowerCase() === "de.commed.carestation.model.common.internal.catalogue.GenericBenefit".toLowerCase()){
					return "measure";
				} else if (inout.type.toLowerCase() === "java.lang.boolean") {
					var value = r.get("value");
					if (value && value.id && ["true", "false"].include(value.id)) {
						return "constant";
					}
				} else if (inout.type.toLowerCase() === "java.lang.enum") {
					var value = r.get("value");
					if (value && value.id && undefined !== inout.allowedvalues.find(function(v){return v.id == value.id}.bind(this))) {
						return "constant";
					}
				}
			}
			return "string" == typeof r.get("value") ? "constant" : "variable";
		},
		
		/**
		 * Returns the value of the selected time delay
		 * 
		 */
		extractValue: function(){
			var result = {},
				service = this.service && this.service.getValue(),
				bo = this.bo && this.bo.getValue(),
				me = this;
			
			if (service){
				// Service 
				result.service = service.id;
				result.serviceName = service.name;
			}
			
			if (bo){
				// BO
				result.bo = bo.id;
				result.boName = bo.name;
			}
			
			// Inputs
			var inputs = this.input.store.getRange().findAll(function(r){ return !!r.get("value"); });
			if (inputs.length > 0){
				result.inputs = inputs.map(function(r){
					return {
						type	: me.getType(r), 
						id		: r.get("in").id,
						value	: r.get("value")
					};
				});
			}
			
			// Outputs
			var outputs = this.output.store.getRange().findAll(function(r){ return !!r.get("value"); });
			if (outputs.length > 0){
				result.outputs = outputs.map(function(r){
					return {
						type	: me.getType(r),
						id		: r.get("out").id,
						value	: r.get("value")
					};
				});
			}
			return Object.toJSON(result);
		}
		
	});	
	
	/**
	 * Proxy to handle ajax requests to the server
	 * @class
	 * @author Willi Tscheschner
	 */
	var Request = {};
	Request.execute = function(url, callback, params, method, async){
		
		var successcallback = callback instanceof Array ? callback[0] : callback; 
		var failedcallback = callback instanceof Array ? callback[1] : undefined;
		
		new Ajax.Request(url, {
				method		: method || 'get',
				parameters	: params, 
				requestHeaders : {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
				//asynchronous: async === true,
				onSuccess: function(transport){
					var json;
					try {
						json = transport.responseText.evalJSON();	
					} catch(e){
						json = transport.responseText;
					}
					
					if (successcallback instanceof Function)
						successcallback(json, transport);
				},
				onFailure: function(transport){
					if (failedcallback instanceof Function)
						failedcallback( transport);
				}
			});
	};
	
	
	/**
	 * Implementation of a loaded which loads synchronouse the directories, models
	 * @class
	 * @author Willi Tscheschner
	 */
	var TreeLoader = function(){
		TreeLoader.superclass.constructor.apply(this, arguments);
	};
	
	Ext.extend(TreeLoader, Ext.tree.TreeLoader, {
		/**
		 * Enable requesting
		 */
		dataUrl:true,
		
		isLeaf: function(r){
			return r.rel !== "dir" && r.rep.type !== "CATEGORY_W_CHILDREN" && !r.rep.hasChildren;
		},
		
		getCls: function(r){
			if (r.rel == "form"){
				if (r.rep.type.include("CATEGORY")){
					return ["x-category", r.rep.type == "CATEGORY_EMPTY" ? "x-empty" : undefined].compact().join(" ");
				} else {
					return "x-form";
				}
			}
			return r.rel === "mod" ? "model" : "folder";
		},
		
		requestData: function(node, callback){
			if( node.attributes.identifier ){	
				Request.execute(ORYX.CONFIG.SERVER_HANDLER_ROOT + node.attributes.identifier, function(response){
					window.setTimeout(this.doResponse.bind(this, node, callback, response), 10);
				}.bind(this), {'_dc':Math.random().toFixed(10)});
			}
		},
		
		/**
		 * Generate the data for the nodes depending on the records
		 * @param {Object} records
		 */
		generateNodeData: function(node, data){

			if (node.attributes.dontSort !== true){
				// Sort by title/name
				var df = "name";
				var fn = function(r){ return (r.rep[df]||r.rep.name||r.rep.title||"").toLowerCase(); };
				data = data.sort(function(a,b){ return Number(a.rel > b.rel) || Number(a.rel == b.rel && fn(a) > fn(b)); });
			}

			
			// For every record in the store, append a new child
			return data.map(function(r){
//						if ((r.rel !== "mod" && r.rel !== "dir") || (r.rel === "dir" && r.rep.type === "trash")) {
//							return null;
//						}
						var attr = node.attributes;
						return {
							text		: Signavio.Utils.escapeHTML(Signavio.I18N.Repository.Folder[r.rep.type] || r.rep.name || attr.value),
							cls			: this.getCls(r),
							leaf		: this.isLeaf(r),
							singleClickExpand : true,
							identifier	: r.href,
							data		: r
						};
					}.bind(this)).compact();
		},
		/**
		 * Callback when loading the new data from the store
		 * @param {Object} store Store where the new data comes from
		 * @param {Object} node Node where the data should append
		 * @param {Object} callback Callback when ready loading
		 * @param {Object} records New records of the store
		 */
		doResponse: function(node, callback, data){
	
			// Get the new items
			var items = this.generateNodeData( node, data );
			
			// Check if there are changes
			if( node.childNodes.length > 0 && node.childNodes.length === items.length && 
				node.childNodes.all(function(n){ return items.any(function(i){ return n.attributes.identifier === i.identifier && n.attributes.text === i.text; }); })){
				return;
			}	
			
			// Hide all childs
			node.collapse();
			
			// Remove all children
			var index = node.childNodes.length-1;
			for(; index>=0; index--){
				node.childNodes[index].remove();
			}
			
			// BEGIN
	        node.beginUpdate();
			// For every record in the store, append a new child
			items.each(function(d){		
				node.appendChild(this.createNode(d));
			}.bind(this));
			// END	
			node.endUpdate();
			
			window.setTimeout(function(){
				node.expand();
			}, 500);
			
			this.fireEvent("update", this, items);
			this.fireEvent("load", this, node);
				
			if(typeof callback == "function"){
	            callback(this, node);
	        }
		}
		
	});
	
	
	
	
	/**
	 * This class implements the concrete use for sub processes.
	 * 
	 * @class Ext.ux.propertyeditor.ComMedSubProcessCall
	 * @inherits Ext.ux.propertyeditor.ComMedAbstractCall
	 * @author Willi Tscheschner
	 */
	Ext.ux.propertyeditor.ComMedSubProcessCall = Ext.extend(Ext.ux.propertyeditor.ComMedAbstractCall, {
		isServiceCallEnabled: function(){
			return false;
		},
		
		isBOCallEnabled: function(){
			return false;
		},
		
		getCurrentServiceURL: function(){
			var node = this.facade.getSelection();
			if (node && node.length > 0){
				var linked = node[0].properties["oryx-entry"];
				if (linked && linked.include("/model/")){
					linked = linked.split("/model/").last();
					if (linked.length == 32){
						return ((Signavio && Signavio.Config && Signavio.Config.BACKEND_PATH)||'/p')+'/commed?proxy=subprocess&id='+linked;
					}
				}
			}
			return false;
		},
		
		onTriggerClick: function(){
			if (this.getCurrentServiceURL()){
				Ext.ux.propertyeditor.ComMedAbstractCall.prototype.onTriggerClick.apply(this, arguments);
			} else {
				Ext.Msg.alert("Parameter-Mapping", 
						Ext.ux.getI18N("commed.servicecall.parameteralert"))
					.setIcon(Ext.Msg.INFO)
					.getDialog().syncSize();
			}
		},		

		getInputEmptyText: function(){
			return Ext.ux.getI18N("commed.servicecall.noinputsinsub");
		},			

		getOutputEmptyText: function(){
			return Ext.ux.getI18N("commed.servicecall.nooutputsinsub");
		},

		getServiceEmptyText: function(){
			return Ext.ux.getI18N("commed.servicecall.noserviceinsub");
		}
	});
	
	
	/**
	 * This class implements the concrete use for user tasks.
	 * 
	 * @class Ext.ux.propertyeditor.ComMedServiceCall
	 * @inherits Ext.ux.propertyeditor.ComMedAbstractCall
	 * @author Willi Tscheschner
	 */
	Ext.ux.propertyeditor.ComMedServiceCall = Ext.extend(Ext.ux.propertyeditor.ComMedAbstractCall, {
		
		isServiceCallEnabled: function(){
			return true;
		},
		
		isBOCallEnabled: function(){
			return false;
		}
	});
	
	
	/**
	 * This class implements the concrete use for service tasks.
	 * 
	 * @class Ext.ux.propertyeditor.ComMedBOCall
	 * @inherits Ext.ux.propertyeditor.ComMedAbstractCall
	 * @author Willi Tscheschner
	 */
	Ext.ux.propertyeditor.ComMedBOCall = Ext.extend(Ext.ux.propertyeditor.ComMedAbstractCall, {
		isServiceCallEnabled: function(){
			return true;
		},
		
		isBOCallEnabled: function(){
			return true;
		},
		
		getCurrentServiceURL: function(){
			return false;
		},
		
		getCurrentServiceURL: function(){
			var service = this.service && this.service.getValue(),
				bo = this.bo && this.bo.getValue();
			if (service && bo){
				return ((Signavio && Signavio.Config && Signavio.Config.BACKEND_PATH)||'/p')+'/commed?proxy=bo&id='+bo.id;
			}
			return false;
		},
		
		onServiceChange: function(fn){
			if (this.bo){
				var service = this.service && this.service.getValue();
				if (service){
					this.bo.ownerCt.enable();
					this.bo.setValue("");
					this.bo.lastQuery = undefined;
					this.bo.store.proxy.conn.url = ((Signavio && Signavio.Config && Signavio.Config.BACKEND_PATH)||'/p')+'/commed?proxy=bo&serviceId='+service.id;
				} else {
					this.bo.ownerCt.disable();
				}
			}
			this.updateMappingPanels(fn);
		},
		
		onBOChange: function(fn){
			this.updateMappingPanels(fn);
		},

		getServiceEmptyText: function(){
			return Ext.ux.getI18N("commed.servicecall.selectboandservice");
		}
	});
	
}();
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Specific class to provide a panel to define a text area for the condition of an edge for ITSM
	 * 
	 */
	Ext.ux.propertyeditor.ITSMCondition = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {resizable: false, bodyStyle: "padding: 0px; background: white;", layout: "anchor", width: 400, height: 300},

		
		getVariableCombo: function(){
			
			
			var items = [];
			try {
				var val = this.facade.getCanvas().getProperty("variables");
				if ("string" == typeof val){
					val = val.evalJSON();
				}
				if ("object" == typeof val){
					items = val.items.pluck("name").compact();
				}
			} catch(e){}
			
			var variablesStore = new Ext.data.SimpleStore({
				data: items.map(function(r){ return [r, r]; }),
				fields: ["title", "id"]
			});
			
			var variables = new Ext.form.ComboBox({
				displayField	: "title",
				valueField		: "id",
				store			: variablesStore,
				mode			: "local",
				triggerAction	: "all",
				emptyText		: Ext.ux.getI18N("propertyeditor.itsm.condition.add"),
				onViewClick 	: function(){
					return Ext.form.ComboBox.prototype.onViewClick.call(this, false);
				},
				listeners		: {
					select: function(foo, rec){
						this.appendVariable(this.getVariableName(rec));
						variables.setValue();
					}.bind(this)
				}
			});
			
			return variables;
		},
		
		/**
		 * Returns the readable name of the variable record
		 * @param rec {Ext.data.Record} 
		 * @returns {String}
		 */
		getVariableName: function(rec){
			return "'"+rec.get("title")+"'";
		},
		
		/**
		 * 
		 * @param title
		 */
		appendVariable: function(title){
			var text = this.text.getValue() || "",
				cursor = "undefined" == typeof this.lastcursor ? {start: text.length, end: text.length} : this.lastcursor;
			this.text.setValue(text.slice(0, cursor.start) + "" + title + "" + text.slice(cursor.end));
			
			window.setTimeout(function(){
				this.text.focus();
			}.bind(this), 100);
		},
		
		
		/**
		 * Returns a panel where the condition area is included
		 * @param {Object} value
		 */
		getEditor: function(value){
			this.panel = new Ext.Panel({
				getValue: this.extractValue.bind(this),
				anchor: "100% 100%",
				layout: "anchor",
				border: false,
				tbar:  new Ext.Toolbar({style: "border:none;", items:[this.getVariableCombo()]}),
				items: [this.text = new Ext.form.TextArea({
						getCursor: function(){
							var dom = this.el.dom;
							if (dom && "undefined" != typeof dom.selectionStart){
								return {start: dom.selectionStart, end: dom.selectionEnd};
							} else if (window.getSelection && window.getSelection().getRangeAt){
								var range = window.getSelection().getRangeAt(0);
								return {start: range.startOffset, end: range.endOffset};
							}
							return undefined;
						},
						anchor: "100% 100%",
						value: value || "",
						listeners: {
							focus: function(){ delete this.lastcursor; }.bind(this),
							blur: function(){ this.lastcursor = this.text.getCursor(); }.bind(this)
						}
					})
				]});
			return this.panel;
		},
		
		/**
		 * Returns the value of the defined
		 * 
		 */
		extractValue: function(){
			return Ext.form.TextArea.prototype.getValue.call(this.panel.items.get(0)) || "";
		}
		
	});	
}();
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	

	/**
	 * Abstract class to provide a panel to define variable mappings for ITSM
	 * 
	 */
	Ext.ux.propertyeditor.ITSMFormEditor = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {resizable: false, bodyStyle: "padding: 10px; background: white;", layout: "fit", width: undefined, height: undefined},

		config: {
			proxy: undefined,
			fields: []
		},
		
		/**
		 * Parses the value and returns the obj
		 * @param (String) value
		 * @returns
		 */
		parseValue: function(value){
			if (value && "string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){}
			}
			return value;
		},
		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			value = this.parseValue(value);			
			var result = this.config.fields.map(function(field){
				return value[field.id+"Name"] || undefined;
			}).compact().join(" - ") || "";
			return result.unescapeHTML();
		},
		
		/**
		 * Update all used comboboxes.
		 * Disable/enable related comboboxes
		 * 
		 */
		updateComboBoxes: function(){
			var ff1 = this.formfield1.getValue(),
				ff2 = this.formfield2.getValue(),
				ff3 = this.formfield3.getValue();
			
			this.formfield2.enable();
			this.formfield3.enable();
			
			if (!ff1){
				this.formfield2.setValue("");
				this.formfield2.disable();
				this.formfield3.setValue("");
				this.formfield3.disable();
			} else if (!ff2) {
				this.formfield3.setValue("");
				this.formfield3.disable();
			}
			
			if (this.formfield4 && this.formfield5){
				var ff4 = this.formfield4.getValue(),
					ff5 = this.formfield5.getValue();
				this.formfield4.enable();
				this.formfield5.enable();
				if (!ff3){
					this.formfield4.setValue("");
					this.formfield4.disable();
					this.formfield5.setValue("");
					this.formfield5.disable();
				} else if (!ff4) {
					this.formfield5.setValue("");
					this.formfield5.disable();
				}
			}
				
		},

		/**
		 * 
		 * @returns {String}
		 */
		getAdditionalParameters: function(){
			var company = this.facade.getCanvas().getProperty("enterprise");
			if (!company) {
				company = this.facade.getCanvas().getStencil().property("oryx-enterprise").value();
			}
			if (company){
				return "company="+company;
			}
			return "";
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			if ("string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){ value = {};  }
			} else {
				value = value || {};
			}
			
			var onFF1Change = function(){					
        		this.formfield2.lastQuery = undefined;
        		this.formfield2.store.proxy.conn.url = this.formfield2.initialConfig.url+"&"+this.config.fields[0].id+"="+escape(this.formfield1.getValue());
				this.formfield2.setValue("");
				this.formfield3.setValue("");
        		this.updateComboBoxes();
        	}.bind(this);
        	
			var onFF2Change = function(){
        		this.formfield3.lastQuery = undefined;
        		this.formfield3.store.proxy.conn.url = this.formfield3.initialConfig.url+"&"+this.config.fields[0].id+"="+escape(this.formfield1.getValue())+"&"+this.config.fields[1].id+"="+escape(this.formfield2.getValue());
				this.formfield3.setValue("");
        		this.updateComboBoxes();
        	}.bind(this);
        	
        	
        	var additionalParameters = this.getAdditionalParameters();

			this.formfield1 = new Ext.ux.form.ComboBox({
				fieldLabel: this.config.fields[0].label,
				forceSelection: false,
		        typeAhead: false, 
				allowBlank: false,
				fieldId: this.config.fields[0].id,
		        url: "/p/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[0].id+(additionalParameters?"&"+additionalParameters:""),
		        changed: onFF1Change,
		        listeners: {
		        	select: onFF1Change,
		        	change: onFF1Change
		        },
		        setValue : function(s) {
		        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
		        	if (this.rendered)
		        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
		        	return res;
		        }
		    });
			
			this.formfield2 = new Ext.ux.form.ComboBox({
				fieldLabel: this.config.fields[1].label,
				forceSelection: false,
		        typeAhead: false, 
				allowBlank: false,
				fieldId: this.config.fields[1].id,
		        url: "/p/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[1].id+(additionalParameters?"&"+additionalParameters:""),
		        disabled: true,
		        changed: onFF2Change,
		        listeners: {
		        	select: onFF2Change,
		        	change: onFF2Change
		        },
		        setValue : function(s) {
		        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
		        	if (this.rendered)
		        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
		        	return res;
		        }
		    });
			
			this.formfield3 = new Ext.ux.form.ComboBox({
				fieldLabel: this.config.fields[2].label,
				forceSelection: false,
		        typeAhead: false, 
				allowBlank: false,
				fieldId: this.config.fields[2].id,
		        url: "/p/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[2].id+(additionalParameters?"&"+additionalParameters:""),
		        disabled: true,
		        setValue : function(s) {
		        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
		        	if (this.rendered)
		        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
		        	return res;
		        }
		    });
			
			if (this.config.fields.length == 5){
				
				
				var onFF3Change = function(){
	        		this.formfield4.lastQuery = undefined;
	        		this.formfield4.store.proxy.conn.url = this.formfield4.initialConfig.url+"&"+this.config.fields[0].id+"="+escape(this.formfield1.getValue())+"&"+this.config.fields[1].id+"="+escape(this.formfield2.getValue())+"&"+this.config.fields[2].id+"="+escape(this.formfield3.getValue());
					this.formfield4.setValue("");
	        		this.updateComboBoxes();
	        	}.bind(this);

	        	this.formfield3.on("change", onFF3Change);
	        	this.formfield3.on("select", onFF3Change);
	        	this.formfield3.changed = onFF3Change;
				
	        	
	        	var onFF4Change = function(){
	        		this.formfield5.lastQuery = undefined;
	        		this.formfield5.store.proxy.conn.url = this.formfield5.initialConfig.url+"&"+this.config.fields[3].id+"="+escape(this.formfield4.getValue());
					this.formfield5.setValue("");
	        		this.updateComboBoxes();
	        	}.bind(this);
	        	
				this.formfield4 = new Ext.ux.form.ComboBox({
					fieldLabel: this.config.fields[3].label,
					forceSelection: false,
			        typeAhead: false, 
					allowBlank: false,
					fieldId: this.config.fields[3].id,
			        url: "/p/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[3].id+(additionalParameters?"&"+additionalParameters:""),
			        disabled: true,
			        changed: onFF4Change,
			        listeners: {
			        	select: onFF4Change,
			        	change: onFF4Change
			        },
			        setValue : function(s) {
			        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
			        	if (this.rendered)
			        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
			        	return res;
			        }
			    });
				
				this.formfield5 = new Ext.ux.form.ComboBox({
					fieldLabel: this.config.fields[4].label,
					forceSelection: false,
			        typeAhead: false, 
					allowBlank: false,
					fieldId: this.config.fields[4].id,
			        url: "/p/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[4].id+(additionalParameters?"&"+additionalParameters:""),
			        disabled: true,
			        setValue : function(s) {
			        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
			        	if (this.rendered)
			        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
			        	return res;
			        }
			    });
			}
			
			this.setInitialValue(value);

			// Enable blank field (but don't use the standard 
			// behavior, otherwise an empty record will be added)
			this.formfield1.allowBlank = true;
			this.formfield2.allowBlank = true;
			this.formfield3.allowBlank = true;
			if (this.formfield4) this.formfield4.allowBlank = true;
			if (this.formfield5) this.formfield5.allowBlank = true;
			
			this.panel = new Ext.Panel({
				layout: "form",
				border: false,
				anchor: "100% 100%",
				items: [this.formfield1, this.formfield2, this.formfield3, this.formfield4, this.formfield5].compact(),
				getValue: this.extractValue.bind(this)
			});
			
			return this.panel;
		},
		
		/**
		 * Returns the value of the defined
		 * 
		 */
		extractValue: function(){
			var cm = this.formfield1.getValue(),
				or = this.formfield2.getValue(),
				gr = this.formfield3.getValue(),
				f1 = (this.formfield4 && this.formfield4.getValue()) || false,
				f2 = (this.formfield5 && this.formfield5.getValue()) || false,
				getTitle = function(pn, value){ 
					return pn.store.getRange().find(function(t){ return t.get("value")== value; }).get("title");
				};
			if (!this.config.all || (cm && or && gr && (!this.formfield4 || f1) && (!this.formfield5 || f2))){
				var obj = {};
				if (cm){
					obj[this.config.fields[0].id+"Id"] = cm;
					obj[this.config.fields[0].id+"Name"] = getTitle(this.formfield1, cm);
				}
				if (or){
					obj[this.config.fields[1].id+"Id"] = or;
					obj[this.config.fields[1].id+"Name"] = getTitle(this.formfield2, or);
				}
				if (gr){
					obj[this.config.fields[2].id+"Id"] = gr;
					obj[this.config.fields[2].id+"Name"] = getTitle(this.formfield3, gr);
				}
				if (f1){
					obj[this.config.fields[3].id+"Id"] = f1;
					obj[this.config.fields[3].id+"Name"] = getTitle(this.formfield4, f1);
				}
				if (f2){
					obj[this.config.fields[4].id+"Id"] = f2;
					obj[this.config.fields[4].id+"Name"] = getTitle(this.formfield5, f2);
				}
				return Object.toJSON(obj);
			}
			return "";
		},
		
		/**
		 * Sets the initial values
		 */
		setInitialValue: function(value){
			// Set initial values
			if (!this.config.all || this.config.fields.all(function(field){ return value[field.id+"Id"] || false; })){
				var id1 = this.config.fields[0].id,
					id2 = this.config.fields[1].id,
					id3 = this.config.fields[2].id;
				
				if (value[id1+"Id"]){
					this.formfield1.store.loadData([{title: value[id1+"Name"], value:value[id1+"Id"]}]);
					this.formfield1.setValue(value[id1+"Id"]);
					this.formfield1.changed();
				}
				
				if (value[id2+"Id"]){
					this.formfield2.store.loadData([{title: value[id2+"Name"], value:value[id2+"Id"]}]);
					this.formfield2.setValue(value[id2+"Id"]);
					this.formfield2.changed(); 
				}
				
				if (value[id3+"Id"]){
					this.formfield3.store.loadData([{title: value[id3+"Name"], value:value[id3+"Id"]}]);
					this.formfield3.setValue(value[id3+"Id"]);
				}
				
				if (this.formfield4 && this.formfield5) {
					var id4 = this.config.fields[3].id,
						id5 = this.config.fields[4].id;
					this.formfield3.changed(); 
					
					if (value[id4+"Id"]){
						this.formfield4.store.loadData([{title: value[id4+"Name"], value:value[id4+"Id"]}]);
						this.formfield4.setValue(value[id4+"Id"]);
						this.formfield4.changed(); 
					}
					
					if (value[id5+"Id"]){
						this.formfield5.store.loadData([{title: value[id5+"Name"], value:value[id5+"Id"]}]);
						this.formfield5.setValue(value[id5+"Id"]);
					}
				}
			}
		}
	});	
	
	
	
	/**
	 * Specific panel for ITSM Assignees
	 */
	Ext.ux.propertyeditor.ITSMAssignee = Ext.extend(Ext.ux.propertyeditor.ITSMFormEditor, {
		
		config: {
			proxy: "role",
			all: true,
			fields: [{
					id: "company",
					label: Ext.ux.getI18N("propertyeditor.itsm.assignee.company")
				},{
					id: "organization",
					label: Ext.ux.getI18N("propertyeditor.itsm.assignee.organization")
				},{
					id: "group",
					label: Ext.ux.getI18N("propertyeditor.itsm.assignee.group")
				}]
		},
		
		getAdditionalParameters: function(){
			return "";
		}
	
	});
	
	
	
	
	
	
	Ext.ux.propertyeditor.ITSMLocation = Ext.extend(Ext.ux.propertyeditor.ITSMFormEditor, {
		
		config: {
			proxy: "location",
			fields: [{
					id: "region",
					label: Ext.ux.getI18N("propertyeditor.itsm.location.region")
				},{
					id: "sitegroup",
					label: Ext.ux.getI18N("propertyeditor.itsm.location.sitegroup")
				},{
					id: "site",
					label: Ext.ux.getI18N("propertyeditor.itsm.location.site")
				}]
		}
	
	});
	
	
	
	
	Ext.ux.propertyeditor.ITSMServiceCat = Ext.extend(Ext.ux.propertyeditor.ITSMFormEditor, {
		
		config: (function() {
			var tId = new Ext.Template("tier{0}");
			var tLabel = new Ext.Template(Ext.ux.getI18N("propertyeditor.itsm.servicecat.tier"));
			return {
				proxy: "servicecat",
				fields: $A($R(1,3).map(function(i) {
							return {
								id: tId.apply([i]), 
								label: tLabel.apply([i])
								};
						}))
			};
		})()
	
	});
	
	
	
	
	Ext.ux.propertyeditor.ITSMProductCat = Ext.extend(Ext.ux.propertyeditor.ITSMFormEditor, {
		
		config: (function() {
			var tId = new Ext.Template("tier{0}");
			var tLabel = new Ext.Template(Ext.ux.getI18N("propertyeditor.itsm.servicecat.tier"));
			return {
				proxy: "productcat",
				fields: $A($R(1,3).map(function(i) {
							return {
								id: tId.apply([i]), 
								label: tLabel.apply([i])
								};
						})).concat(
						[{
							 id: "name",
							 label: Ext.ux.getI18N("propertyeditor.itsm.productcat.name")
						 },{
							 id: "model",
							 label: Ext.ux.getI18N("propertyeditor.itsm.productcat.model")
						 }])
			};
		})()
	
	});
}();
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
//	/**
//	 * Specific class to provide a panel to define variable mappings for ITSM
//	 * 
//	 */
//	Ext.ux.propertyeditor.ITSMTaskGroupTemplateInterface = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
//		
//		windowCreate: {height: 400, width: 400, resizable: false, bodyStyle: "padding:0px;"},
//		
//		/**
//		 * Returns a panel where the skript form is inside
//		 * @param {Object} value
//		 */
//		getEditor: function(value){
//			
//			var shape = this.facade.getSelection()[0];
//			var taskGroupTemplate = shape.getProperty("taskgrouptemplates") || "";
//			if (taskGroupTemplate.length > 0) {
//			
//				new Ajax.Request("/p/itsm?proxy=interface&processname=" + escape(taskGroupTemplate), {
//					method		: 'get',
//					requestHeaders : {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
//					//asynchronous: async === true,
//					onSuccess: function(transport){
//						var json;
//						try {
//							json = transport.responseText.evalJSON();	
//						} catch(e){
//							json = transport.responseText;
//						}
//						
//						alert(transport.responseText);
//					}
//				});
//				
//			} else {
//				alert("Kein TaskGroupTemplate ausgewählt!");
//			}
//			
//
//			
//		}
//		
//	});	
}();
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Specific class to provide a panel to define variable mappings for ITSM
	 * 
	 */
	Ext.ux.propertyeditor.ITSMVariableMapping = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height: 400, width: 400, resizable: false, bodyStyle: "padding:0px;"},

		/**
		 * These magic numbers represent the specification for the maximum use of each variable type.
		 */
		maxNumbers: {
			"String"	: 6,
			"Integer"	: 3,
			"Real"		: 3,
			"Boolean"	: 2,
			"Date"		: 2
		},
		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if (value && "string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){}
			}
			if (value instanceof Array){
				return value.map(function(item){
					if (item && item.id){
						var usage = String(item.usage||"").toUpperCase();
						return [item.id, ((usage.include("IN")?"IN":"") + (usage.include("OUT")?"OUT":"")) || undefined].compact().join(" - ");
					}
				}).join("<br/>");
			}
			return "";
		},
		
		/**
		 * Retrieves variable values which happen to have an OUT usage
		 * from a precedent task, if any exists.
		 */
		retrieveOutValuesFromPredecessor: function() {
			if (this.facade.getSelection().length == 1) {
				var current = this.facade.getSelection()[0];
				if (current.incoming.length == 1 
					&& current.incoming[0].getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#SequenceFlow"
					&& current.incoming[0].incoming.length == 1
					&& current.incoming[0].incoming[0].getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#Task") {
					var mapping = current.incoming[0].incoming[0].getProperty("variablemapping");
					if (typeof mapping == "string" && mapping.length > 0) {
						mapping = mapping.evalJSON();
						if (mapping instanceof Array) {
							var items = mapping.findAll(function(item) {
								return item.usage.include("OUT");
							});
							items.each(function(item) {
								item.usage = "IN";
							})
							return items;
						}
					}
				}
				
			}	
			return {};
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			if ("string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){ value = {};  }
			} else {
				value = value || {};
			}
			
			if (!(value instanceof Array))
				value = this.retrieveOutValuesFromPredecessor();
			
			this.store = new Ext.data.SimpleStore({
				data: value instanceof Array ? value.map(function(item){
					if (item && item.id){
						var usage = String(item.usage||"").toUpperCase();
						return [item.id, usage.include("IN"), usage.include("OUT")];
					}
				}).compact(): [],
				fields: ["variable", "input", "output"]
			});
			
			
			var items = [];
			try {
				var val = this.facade.getCanvas().getProperty("variables");
				if ("string" == typeof val){
					val = val.evalJSON();
				}
				if ("object" == typeof val){
					items = val.items.pluck("name").compact();
				}
			} catch(e){}
			
			var variablesStore = new Ext.data.SimpleStore({
				data: items.map(function(r){ return [r, r]; }),
				fields: ["title", "id"]
			});
			
			var variables = new Ext.form.ComboBox({
				displayField	: "title",
				valueField		: "id",
				store			: variablesStore,
				mode			: "local",
				triggerAction	: "all",
				listeners		: {
					focus: function(){
						// Show only variables which are not used yet
						var used = this.store.getRange().map(function(r){ return r.get("variable") || undefined; }).compact();
						variablesStore.loadData(items.findAll(function(item){
							return !used.include(item);
						}).map(function(r){ return [r, r]; }));
					}.bind(this)
				}
			});

			var checkboxInput = new Ext.form.Checkbox({});
			var checkboxOuput = new Ext.form.Checkbox({});
			
			this.panel = new Ext.grid.EditorGridPanel({
				border	: false,
				anchor	: "100% 100%",
				getValue: this.extractValue.bind(this),
				store	: this.store,
				clicksToEdit : 2,
				autoExpandColumn : "variable",
				enableHdMenu : false,
				enableColumnResize: false,
				listeners : {
					afteredit: function(o){ o.record.commit(); }
				},
				sm 		: new Ext.grid.RowSelectionModel({singleSelect: true, listeners: { selectionchange: this.onSelectionChange.bind(this) }}),
				columns	: [{dataIndex:'variable',	header: Ext.ux.getI18N("propertyeditor.itsm.variablemapping.header.variable"), editor: variables, renderer: this.renderVariable.bind(this, variablesStore), id: "variable"},
				           {dataIndex:'input',		header: Ext.ux.getI18N("propertyeditor.itsm.variablemapping.header.input"), 	editor: checkboxInput, renderer: this.renderBoolean.bind(this), width: 50},
				           {dataIndex:'output',		header: Ext.ux.getI18N("propertyeditor.itsm.variablemapping.header.output"), 	editor: checkboxOuput, renderer: this.renderBoolean.bind(this), width: 50}],
				tbar	: [{text: Ext.ux.getI18N("btnadd"), icon: ""+Ext.IMAGE_URL+"/famfamfam/add.png", handler: this.doAdd.bind(this), iconCls:"x-dummy"},
				    	   {text: Ext.ux.getI18N("btnremove"), icon: ""+Ext.IMAGE_URL+"/famfamfam/cross.png", handler: this.doDelete.bind(this), iconCls:"x-dummy", disabled: true},
				    	   "-",
				    	   {text: Ext.ux.getI18N("moveup"), icon: ""+Ext.IMAGE_URL+"/famfamfam/bullet_arrow_up.png", handler: this.doMove.bind(this, -1), iconCls:"x-dummy", disabled: true},
				    	   {text: Ext.ux.getI18N("movedown"), icon: ""+Ext.IMAGE_URL+"/famfamfam/bullet_arrow_down.png", handler: this.doMove.bind(this, 1), iconCls:"x-dummy", disabled: true}]
			});
			
			return this.panel;
		},
		
		/**
		 * Returns the title of the given value from the store
		 * @param store
		 * @param value
		 * @returns
		 */
		renderVariable: function(store, value){
			if (!value){ return ""; }
			
			var record = store.getRange().find(function(r){ return r.get("id") == value; });
			if (record){
				return record.get("title");
			}
			return value;			
		},
		
		/**
		 * Returns a string representation of a boolean value
		 * @param value
		 * @param meta
		 * @returns {String}
		 */
		renderBoolean: function(value, meta){
			if (!value || value === "false"){
				return "";
			}
			meta.attr = "style='overflow:visible;position:relative;'";
			return "<img src='"+Ext.IMAGE_URL+"/famfamfam/check.png' style='position:absolute;top:1px;'/>";
		},
		
		/**
		 * Specific handling of the selection change from the grid panel
		 * 
		 */
		onSelectionChange: function(){
			var sm = this.panel.getSelectionModel(),
				index = sm.getCount() == 1 ? this.store.indexOf(sm.getSelected()) : -1,
				isSelected = index >= 0,
				isFirst = index === 0,
				isLast = index === this.store.getCount()-1,
				tb = this.panel.getTopToolbar();
				
			if (isSelected){
				tb.items.get(1).enable();
				tb.items.get(3).setDisabled(isFirst);
				tb.items.get(4).setDisabled(isLast);
			} else {
				tb.items.get(1).disable();
				tb.items.get(3).disable();
				tb.items.get(4).disable();
			}
		},
		
		/**
		 * Checks whether no more than the maximum number of variables of each type are used.
		 * this.maxNumbers defines the upper limits.
		 */
		onBeforeSave: function(oldValue, newValue) {
			if (!Ext.ux.propertyeditor.ITSMVariableMapping.superclass.onBeforeSave.apply(this, arguments))
				return false;
			var val = this.facade.getCanvas().getProperty("variables");
			if (typeof val == "undefined")
				// there are no variables defined
				return true;
			// get the global variable definitions
			if ("string" == typeof val){
				val = val.evalJSON();
			}
			var types = {};
			if ("object" == typeof val){
				val.items.each(function(item) {
					if (typeof item.name == "string" && item.name.length > 0)
						types[item.name] = item.type; 
				});
			}
			// count the locally used variables
			var newVal = newValue;
			if (typeof newVal == "string") {
				newVal = newVal.evalJSON();
			}
			if (newVal instanceof Array) {
				var count = {};
				newVal.each(function(item) {
					count[types[item.id]] = (count[types[item.id]] || 0) + 1;
				});
				var type = Object.keys(count).find(function(key) {
					return count[key] > this.maxNumbers[key];
				}.bind(this));
				if (type) {
				    this.showErrorMessageForType(type);
				    return false;
				}
			}
			return true;
		},
		
		/**
		 * Shows a short notice that to many variables of one type are registered.
		 */
		showErrorMessageForType: function(type) {
			Ext.Msg.show({
				title: Ext.ux.getI18N('propertyeditor.itsm.variablemapping.error.title'),
				msg: (new Ext.Template(Ext.ux.getI18N('propertyeditor.itsm.variablemapping.error.message'))).apply([type, this.maxNumbers[type]]),
				buttons: Ext.Msg.OK,
				icon: Ext.Msg.ERROR
			}).getDialog().syncSize();
		},
		
		/**
		 * Moves the currently selected record regarding the given offset inside the store
		 * @param offset
		 */
		doMove: function(offset){
			var selected = this.panel.getSelectionModel().getSelected();
			if (!selected){ return; }
			
			var index = this.store.indexOf(selected)+offset;
			this.store.remove(selected);
			this.store.commitChanges();
			this.store.insert(index, selected);
			this.store.commitChanges();
			this.panel.getSelectionModel().selectRow(index);
		},
		
		/**
		 * Adds a dummy record to the store
		 * 
		 */
		doAdd: function(){
			// Add empty entry
			this.store.loadData([["", true, false]], true);
			// Start editing
			this.panel.getSelectionModel().selectLastRow();
			this.panel.startEditing(this.store.getCount()-1, 0);
		},
		
		/**
		 * Remove the currently selected record from the store
		 * 
		 */
		doDelete: function(){
			
			var records = [].concat(this.panel.getSelectionModel().getSelections()),
				store = this.store,
				index = records.length>0?store.indexOf(records[0]):-1;
			records.each(function(record){
				store.remove(record);
			});
			store.commitChanges();
			if (index >= 0 && store.getCount()){
				this.panel.getSelectionModel().selectRow(Math.min(index, store.getCount()-1));
			}
		},
		
		/**
		 * Returns the value of the defined
		 * [{id:"anId", usage:"IN | OUT | INOUT|<leer>"}*]
		 */
		extractValue: function(){
			return Object.toJSON(this.store.getRange().map(function(rec){
			    		if (rec.get("variable")){
			    			return {id: rec.get("variable"), usage: (rec.get("input")?"IN":"")+ (rec.get("output")?"OUT":"")}
			    	    }
			    		// Ignore variables where no title is defined
			    	}).compact());
		}
		
	});	
}();
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Lukas Brand
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function(){
	
	var ControlField = function(config, plugin) {
		Ext.apply(this, config);
		if (!this.id) {
			this.id = Ext.id();
		}
		this.plugin = plugin;
		this.renderer = this.renderer.createDelegate(this);
	};
	
	ControlField.prototype = {
			init	: function(grid) {
				this.grid = grid;
				this.grid.on("render", function() {
					var view = this.grid.getView();
					view.mainBody.on("click", this.onClick, this);
				}, this);
			},
			
			/**
			 * When the grid is clicked, evaluate the target. If it is a control field,
			 * update the control grid with the target record and expand it.
			 */
			onClick : function(e, t) {
								
				if (Ext.get(t).hasClass("x-grid3-control-"+this.id) || 
					(Ext.isIE && Ext.get(t).hasClass("y-control-field-cell-item"))) {
					e.stopEvent();
					
					// Fix IE-Bug
					if (Ext.isIE && Ext.get(t).hasClass("y-control-field-empty-text")){
						t =  Ext.get(t).parent(".x-grid3-control-col").dom;
					}
					
					// Remove any existing confirm hints
					this.plugin.clearActiveConfirmHints();
					
					var inner = Ext.get(t).parent(".x-grid3-cell-inner");
					var cell = inner.parent(".x-grid3-cell");
					var row = cell.parent(".x-grid3-row-table");
					
					var index = this.grid.getView().findRowIndex(row.dom);
					// Get the active record
					var record = this.grid.store.getAt(index);
					
					// Find expanded nodes in the control column and close them
					Ext.DomQuery.select(".y-risk-dialog .expanded").without(cell.dom).each(function(node) {
						Ext.fly(node).removeClass("expanded");
					});
					
					cell.toggleClass("expanded");
					
					if (cell.hasClass("expanded")) {
						
						var mask = this.grid.getView().el.mask();
						var ms = mask.dom.style;
						ms["backgroundColor"] = "#FFFFFF";
						ms["zIndex"] = 1;
						ms["opacity"] = "0.6";
						
						// Close the control grid when the mask over the risk grid was clicked
						mask.on("click", function() {
							cell.removeClass("expanded");
							this.hideControlGrid(row);
						}.bind(this));
						
						cell.originalHeight = cell.getHeight();
						
						this.plugin.controlGrid = this.plugin.getControlGrid({
							controlCell : inner,
							cell		: cell,
							row			: row,
							riskid		: record.get("id"),
							value		: this.value,
							doResize	: function(riskGrid) {
								var riskBox = riskGrid.el.getBox();
								var oldBox = this.getBox();
								
								// Align the grid nicely inside the riskGrid
								this.updateBox(Ext.apply(oldBox, {
									width	: Math.round(riskBox.width - 50),
									x		: Math.round(riskBox.x + 40)
								}));								
								
							}
						});
						
//						this.plugin.controlGrid.doResize();
						
						var s = this.plugin.controlGrid.el.dom.style;
						
						s["zIndex"] = 1;
						s["border"] = "1px solid #888888";
						s["borderRadius"] = "1px";
						s["boxShadow"] = "0px 6px 8px -6px silver";
						s["position"] = "absolute";
						
						this.plugin.updateControlCell(this.plugin.controlGrid);
						
						// Show the control grid
						this.plugin.controlGrid.show();
						
						this.plugin.adjustCellHeight(this.plugin.controlGrid, row, cell, inner);
						
						// Reposition the grid
						this.plugin.controlGrid.el.alignTo(inner, "tl-bl", [0, -1]);
						this.plugin.controlGrid.doResize(this.plugin.grid);
						this.grid.ownerCt.syncShadow();
						
					} else if (this.plugin.controlGrid && this.plugin.controlGrid.isVisible()) {

						this.hideControlGrid(row);
					}
				}
			},
			
			/**
			 * Hides the control grid, resets the height of the opened row and syncs the size of the window
			 */
			hideControlGrid : function(row) {
				// Hide the grid
				this.plugin.controlGrid.hide();
				// Update the control count in the cell
				this.plugin.updateControlCell(this.plugin.controlGrid);
				
				// Remove the mask
				this.grid.getView().el.unmask();
				
				this.plugin.controlGrid.destroy();
				
				// Reset the size of the current row
				row.dom.style["height"] = "";
				this.grid.ownerCt.syncShadow();
			},
			
			renderer : function(v, p, record) {
				p.css += 'x-grid3-control';
				
				if (this.plugin.controlStore){
					v = this.plugin.controlStore.getRange().findAll(function(row) {return row.get("riskid") === record.get("id");}).length;
				} else {
					v = this.plugin.controlData.findAll(function(row) {return row.riskid === record.get("id");}).length;
				}

				if (v === 0) {
					v = this.plugin.getControlCellEmptyValue();
				} else {
					// If a value exists, render an edit icon
					v += "<span class='y-control-field-cell-item'><div class='y-risk-edit-icon y-control-field-cell-item'/></span>";
				}
				
				//var arrow = "<img src='/images/signavio/s.gif' class='y-arrow'/>";
				
				return ['<div class="x-grid3-control-col x-grid3-control-',
				        this.id,
				        '"><span class="y-control-field-cell-item y-cell-value">',
				        	// The cell value
				        	v,
				        '</span></div>'].join("");
			}
	};
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.MetaDataIKS = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {
			title		: Ext.ux.getI18N('IKS.title'),
			description	: Ext.ux.getI18N('IKS.desc'),
			bodyStyle	: "",
			maxHeight	: 600,
			autoHeight	: true,
			cls			: "y-risk-dialog",
			height		: undefined,
//			closeAction	: "close",
			width		: "80%",
			minWidth	: Ext.isIE ? 800 : 200,
			useApplyInsteadOfSaveButton : true,
			modal		: true
		},
		
		updateIKSHint : function() {
			var selectedNodes = this.facade.getSelection();
			this.facade.raiseEvent(ORYX.CONFIG.EVENT_UPDATE_IKS_HINT, selectedNodes);
			
		},
		
		renderer : function(value) {

			var parsedValue = {totalCount:0};
			
			if ("string" === typeof value && value.trim()) {
				try {
					var value = JSON.parse(value);
					if ("object" === typeof value && !(value instanceof Array)) {
						parsedValue = value;
					}
				} catch(e) {
					
				}
			}
			
			var count = parsedValue.totalCount || 0;
			
			return count + " " + (count===1?Ext.ux.getI18N('IKS.risk'):Ext.ux.getI18N('IKS.risks'));
		},
		
		/**
		 * Store all risk nodes for easier access
		 */
		riskNodes : [],
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value) {
			var me = this;
			
			this.windowCreate.listeners	= {
				close	: function() {
					me.updateIKSHint();
					this.destroy();
				}
			};
			
			var parsedValue = {items: []};
			
			if ("string" === typeof value && value.trim()) {
				try {
					var value = JSON.parse(value);
					if ("object" === typeof value && !(value instanceof Array)) {
						parsedValue = value;
					}
				} catch(e) {
					
				}
			}
			
			this.riskData = this.getAllRisks(parsedValue);
			this.controlData = this.getAllControls(parsedValue);
			this.getControlStore() // Cache data

			
			this.grid = new Ext.ux.grid.IKSEditorGridPanel({
				anchor			: '100%',
				cls				: 'y-risk-grid',
				cm				: this.getColModel(this.getRiskColumnConfig()),
				store			: this.getRiskStore(),
				autoExpandColumn: 'name',
//				autoWidth		: true,
				minColumnWidth	: Ext.isIE ? 90 : 100,
				border			: true,
				maxHeight		: 400,
				enableHdMenu	: false,
				enableColumnMove: false,
				clicksToEdit	: 1,
				autoHeight		: true,
				plugins			: this.getControlField(),
				sm				: this.getSelectionModel("risk"),
				view			: this.getStripeView("risk"),
				getValue		: function() {
					
					var value = {
						totalCount: 0,
						items: []
					};

					if (this.controlStore) { // Clear filter
						this.controlStore.clearFilter();
					}

					// Iterate over every Risk
					if (this.grid.store) {
						this.grid.store.getRange().each(function(record){
							var item = Object.clone(record.data);
							
							// Try to find every Control for the Risk
							if (this.controlStore) {
								item.controls = {items: []};
								this.controlStore.getRange().each(function(a) {
									if (a.get("riskid") == record.get("id")){
										var risk = Object.clone(a.data);
										delete risk.riskid;
										item.controls.items.push(risk);
									}
								});

								item.controls.totalCount = item.controls.items.length;
							}

							value.items.push(item);
						}.bind(this));
					}

					value.totalCount = value.items.length;
					
					
					/*
					 * If a default language for the model is defined, save it store the
					 * knowledge about the used language when editing risks/controls
					 */
					var lang = this.facade.getAllLanguages().first();
					if (lang) {
						value.language = lang;
					}
					
					return $H(value).toJSON();
				}.bind(this),
				listeners : {
					resize	: function(grid) {
											
						if (this.controlGrid && this.controlGrid.isVisible()) {
							this.controlGrid.doResize(grid);
						}
						
					}.bind(this)
				}
			});
			
			// Save changes immediately into the underlying store, don't keep dirty fields
			this.grid.on("afteredit", function() {
				this.store.commitChanges();
			});
			
			return this.grid;
		},

		getAllRisks: function(data){

			var risks = [];

			(data.items||[]).each(function(d){
				d = Object.clone(d);
				d.controls = "";
				risks.push(d);
			});

			return risks;
		},

		getAllControls: function(data){

			var controls = [];

			(data.items||[]).each(function(d){
				((d.controls||{items:[]}).items||[]).each(function(c){
					c = Object.clone(c);
					c.riskid = d.id;
					controls.push(c);
				});
			});

			return controls;
		},
		
		getControlGrid : function(config) {
			var me = this;
			
			var controlGrid = new Ext.ux.grid.IKSEditorGridPanel(Ext.apply({
				cls				: 'y-control-grid',
				cm				: this.getColModel(this.getControlColumnConfig()),
				store			: this.getControlStore(config.riskid),
				renderTo		: this.grid.ownerCt.body,
				autoExpandColumn: 'name',
				border			: false,
				enableHdMenu	: false,
				enableColumnMove: false,
				minColumnWidth	: 100,
				clicksToEdit	: 1,
				autoHeight		: true,
				sm				: this.getSelectionModel("control"),
				view			: this.getStripeView("control")
			}, config));

			if (Ext.isIE) {
				controlGrid.on("show", function() {
					this.el.repaint();
				});
			}
			
			controlGrid.on("afteredit", function() {
				this.store.commitChanges();
			});
			
			return controlGrid;
		},
		
		getRiskStore : function() {
			
			var fields = this.getRiskColumnConfig().pluck("dataIndex");	;
//				var data = shape.getProperty("iks");
//				var data = [[undefined, "Fehlerhafter Vorgabevorschlag", undefined, "Fehlende Info", "Verzögerung", "Hoch", 5, 3, 2],
//				            [undefined, "Bestellung entspricht VV nicht", undefined, "Kommunikation", "Verzögerung", "Mittel", 3, 0, 1],
//				            [undefined, "Ware entspricht Bestellung nicht", undefined, "Falsche Lieferung", "Mehraufwand", "Mittel", 5, 1, 3]];
			
			return new Ext.data.SimpleStore({
				fields	: fields,
				// Collect the data according to the defined fields
				data	: (this.riskData||[]).map(function(v) {
					return fields.map(function(f) {
						return v[f];
					});
				})
			});
		},
		
		getControlStore : function(riskid) {
			
			if (!this.controlStore) {
				
				var fields = this.getControlColumnConfig().pluck("dataIndex");
				
				this.controlStore = new Ext.data.SimpleStore({
					fields	: fields,
					data	: (this.controlData||[]).map(function(v) {
						return fields.map(function(f) {
							return v[f];
						});
					})
				});
			}
			
			if (riskid) {
				this.controlStore.filter("riskid", riskid);
				// Save the currently active risk id for filtering options
				this.controlStore.currentRiskID = riskid;
			}
			
			return this.controlStore;
		},
		
		/**
		 * Returns a new Ext.grid.ColumnModel for the given grid config
		 */
		getColModel : function(config) {
			return new Ext.grid.ColumnModel(config);
		},
		
		/**
		 * Returns a new column config
		 * @returns {Array}
		 */
		getRiskColumnConfig : function() {
			//TODO If a special config is defined in the admin panel, take it to override the default config
			var config = (this.property.complexItems()).clone().map(this.complexItemToColumn.bind(this));
			config = this.exaggerateConfig(config);
			
			// Id field
			var idField = {
				dataIndex	: 'id',
				hidden		: true
			};

			// Overwrite the conrol field with a custom one
			var control = config.find(function(c){ return c.id == "controls"; });
			if (control){
				config[config.indexOf(control)] = this.getControlField();
			}

			return [].concat(	this.getRowRemover("risk"),
								config,
								idField);
		},

		complexItemToColumn: function(complexItem){
			var me = this, json = Object.clone(complexItem.json());
			json.dataIndex 	= json.id;
			json.header 	= complexItem.title();
			json.renderer 	= json.renderer || function(val){
				if(json.type === "choice") {
					// Find the choice definition by value
					var valItem = (json.items||[]).find(function(i) {
						return i.value === val;
					});

					if(valItem) {
						var displayItem = me.getLocalizedProperty("title", valItem);
						if(displayItem) {
							return displayItem;
						}
					}
				}

				return "string" == typeof val ? val.escapeHTML() : val;
			}
			return json;
		},
		
		getControlColumnConfig : function() {
			//TODO If a special config is defined in the admin panel, take it to override the default config
			var config = (this.property.complexItems()||[]).clone();
			var control = config.find(function(c){ return c.id() == "controls"; });

			if (control){
				config = (control.complexItems()).clone().map(this.complexItemToColumn.bind(this));
			} else {
				return [];
			}

			config = this.exaggerateConfig(config);
			
			var riskIDField = {
				dataIndex	: 'riskid',
				hidden		: true
			};
			
			config = [].concat(	this.getRowRemover("control"),
								config,
								riskIDField);
			
			return config;
		},
		
		/**
		 * Add editors, default widths and types to the given config
		 * @param {Object} config
		 */
		exaggerateConfig : function(config) {
			if (!(config instanceof Array)) { return; }
			
			config = config.map(function(conf) {
				var newConf = Object.clone(conf);
				newConf.editor = this.getEditorForColumnConfig(conf);
				newConf.width = this.getWidthForColumnConfig(conf);
				newConf.minWidth = 100;
				//newConf.header = this.getLocalizedProperty("header", conf);
				newConf.tooltip = Signavio.Utils.escapeHTML(this.getLocalizedProperty("description", conf));
				
				return newConf;
			}.bind(this));
			
			return config;
		},
		
		/**
		 * Returns the width of the column based on its type
		 * @param {Object} columnConfig
		 */
		getWidthForColumnConfig : function(columnConfig) {
			if (columnConfig.id === "name"){
				return 250;
			}
			switch((columnConfig.type||"").toLowerCase()) {
			case "number":
			case "choice":
//				 return 100;
			default:
				 return 200;
			}
		},
		
		/**
		 * Returns the matching editor for the given column config, based on the defined type
		 */
		getEditorForColumnConfig : function(columnConfig) {
			if (!columnConfig) { return; }
			switch ((columnConfig.type||"").toLowerCase()) {
			case "number":
				return new Ext.form.NumberField({
					allowBlank		: columnConfig.optional !== false,
					allowNegative	: false
				});
				break;
			case "choice":
				return new Ext.form.ComboBox({
					mode			: "local",
					displayField	: "displayText",
					valueField		: "value",
					readOnly		: true,
					editable		: false,
					triggerAction	: 'all',
					lazyRender		: true,
					listClass		: 'y-combo-list',
					store			: new Ext.data.SimpleStore({
						fields		: ["value", "displayText"],
						data		: this.getComboItemsForColumnConfig(columnConfig.items||[])
					})
				});
				break;
			default:
				return new Ext.form.TextField({
					allowBlank		: columnConfig.optional !== false
				});
			}
		},
		
		/**
		 * Returns the data needed to create the store for a ComboBox based on columnConfig items
		 * @param {Array} items Takes the items defined in the columnConfig
		 * @returns {Array}
		 */
		getComboItemsForColumnConfig : function(items) {
			if (!(items instanceof Array)) { return; }
			
			return items.map(function(item) {
				return [item.value, this.getLocalizedProperty("title", item)];
			}.bind(this));
		},
		
		getRowRemover : function(type) {
			return new Ext.grid.RowNumberer({
				dataIndex: 'numberer',
				
				renderer : function(v, p, record, r) {
					p.cellAttr = 'title="' + Ext.ux.getI18N(type === "risk" ? 'IKS.removerisk':'IKS.removecontrol') + '"';
					return "";
					//return rowIndex + 1;
				}
			});
		},
		
		/**
		 * Adds a special column for opening the control grid on a row
		 */
		getControlField : function(value) {
			if (!this.controlField) {
				this.controlField = new ControlField({
					header		: Ext.ux.getI18N('IKS.controls'),
					dataIndex	: 'controls',
					width		: 220,
					value		: value
				}, this);
			}
			
			return this.controlField;
		},
		
		getSelectionModel : function(gridType) {
			var selModel = new Ext.grid.CellSelectionModel({
				listeners : {
					// Handle clicks of the row remover
					beforecellselect : function(s, r, c) {
						if (c === 0) {
							
							this.clearActiveConfirmHints();
							this.confirmRowRemoval(r, s.grid, s.grid.view.getCell(r,c).firstChild, gridType);
							
							return false;
						}
						return true;
					}.bind(this)
				}
			});
			
			return selModel;
		},
		
		clearActiveConfirmHints : function() {
			if (this.confirmationDialog) {
				this.confirmationDialog.remove();
				delete this.confirmationDialog;
			}
		},
		
		/**
		 * Returns a new Ext.grid.GridView with vertical stripes and fitted columns
		 * @param {String} gridType Either "risk" or "control" to determine the "add new row" title
		 */
		getStripeView : function(gridType) {
			
			var me = this;
			
			return new Ext.grid.GridView({
				
				forceFit		: true,
				autoFill		: true,
				scrollOffset	: 0,
				
				updateColumnCss: function(){
					[].concat(this.innerHd, $A(this.getRows())).each(function(row){
						var i = 0;
						Ext.get(row).select("td{display!=none}").each(function(cell){
							cell[(i++%2) === 0 ? "addClass" : "removeClass"]("x-colum-odd");
						});
					});
				},
				
				// @overwrite Update css classes for the row
				updateColumnHidden: function(){
					var res = Ext.grid.GridView.prototype.updateColumnHidden.apply(this, arguments);
					this.updateColumnCss();
					return res;
				},
				// @overwrite Update css classes for the row
				processRows: function(){
					var res = Ext.grid.GridView.prototype.processRows.apply(this, arguments);
					this.updateColumnCss();
					return res;
				},
				// @overwrite Update css classes for the row
				refreshRow: function(){
					var res = Ext.grid.GridView.prototype.refreshRow.apply(this, arguments);
					this.updateColumnCss();
					return res;
				},
				
				/**
				 * Extend the renderUI method to add an addRow-button after the real grid
				 */
				renderUI : function() {
					Ext.grid.GridView.prototype.renderUI.apply(this, arguments);
					
					var addNode = document.createElement("div");
					addNode.setAttributeNS(null, "class", "y-add-row");
					addNode.innerHTML = ["<div unselectable='on'></div><span class='y-add-row-desc'>",
					                     Signavio.Utils.escapeHTML(new Ext.Template(Ext.ux.getI18N('IKS.newEntry')).apply([(gridType === "risk" ? Ext.ux.getI18N('IKS.newEntryRisk') : Ext.ux.getI18N('IKS.newEntryControl') )])),
					                     "</span>"].join("");
					
					this.mainBody.dom.parentNode.insertBefore(addNode, this.mainBody.dom.nextSibling);
					
					// Add a new row on click
					Ext.fly(addNode).on("click", me.addNewRow.bind(me, this.grid));
				},
				
				getColumnTooltip : function(i){
			        var tt = this.cm.getColumnTooltip(i);
			        if(tt){
//			            if(Ext.QuickTips.isEnabled()){
//			                return 'ext:qtip="'+tt+'"';
//			            }else{
		                return 'title="'+tt+'"';
//			            }
			        }
			        return "";
			    }
			});
		},
		
		/**
		 * Adds a new row to the given grid
		 */
		addNewRow : function(grid) {
			var store = grid.store;
			var Row = Ext.data.Record.create(store.fields.items);
			var newRow = {};
			
			// initialize empty
			store.fields.items.each(function(field) {
				// TODO If typed cells exist, initialize it here (typed)
				newRow[field.name] = "";
			});
			
			var isControl = ("undefined" !== typeof store.currentRiskID);
			
			var addition = isControl ? {
				// If a risk is active and the new row is a control, add the corresponding risk id to the control
				riskid		: store.currentRiskID
			} : {
				// If a new risk is added, create a new id for it
				id			: ORYX.Editor.provideId()
			};
			
			// create a new record for the currently selected risk
			store.add(new Row(Ext.apply(newRow, addition)));
			
			this.updateControlCell(grid);

			store.commitChanges();
			
			this.grid.ownerCt.syncShadow();
		},
		
		/**
		 * Returns the icon which should be displayed inside the grid when no controls for the risk exists
		 */
		getControlCellEmptyValue : function() {
			return ["<span class='y-control-field-cell-item y-empty-text'>",
			        Signavio.Utils.escapeHTML(Ext.ux.getI18N('IKS.addControls')),
			        "</span>"].join(""); // <img src='/images/glyphicons/small/help.png' title='",Signavio.Utils.escapeHTML("Fügen sie neue Kontrollen für das gewählte Risiko hinzu"),"'/>"
		},

		/**
		 * Update the expanded control cell with the new row count, display a warning icon if no row exists
		 */
		updateControlCell : function(grid) {
			if (!grid.controlCell) {
				return;
			}
			
			var text = this.getControlCellEmptyValue();
			var controlCount = grid.store.data.length;
			
			if (!grid.controlCell.parent(".x-grid3-cell").hasClass("expanded") && controlCount) {
				text = controlCount + " <span class='y-empty-text y-control-field-cell-item'><div class='y-risk-edit-icon y-control-field-cell-item'/></span>";
			}

			grid.controlCell.child(".y-cell-value", true).innerHTML = text;
			this.adjustCellHeight(grid, grid.row, grid.cell, grid.controlCell);
		},
		
		/**
		 * Displays a confirmation for removing a row, handles the actual removal of rows and attached controls when deleting a risk.
		 */
		confirmRowRemoval : function(row, grid, cell, gridType) {
			var riskRecord = grid.store.getAt(row);
			
			// Check if the record is empty
			var isEmpty = !$H(riskRecord.data).any(function(p) {
				return p.key !== "riskid" && p.value;
			});
			
			// Create a new hint to ask for removal
			var confirmation = document.createElement("div");
			confirmation.setAttributeNS(null,"class", "y-delete-confirm");
			confirmation.innerHTML = "<span>"+Ext.ux.getI18N('IKS.deleteThisTpl')+(gridType==="risk"?Ext.ux.getI18N('IKS.deleteThisRisk'):Ext.ux.getI18N('IKS.deleteThisControl'))+"</span><a class='y-delete-confirm-yes' href='#'>"+Ext.ux.getI18N('IKS.yes')+"</a><a class='y-delete-confirm-no' href='#'>"+Ext.ux.getI18N('IKS.no')+"</a>";

			// Wrap the confirmation into an ext element
			var $confirmation = Ext.get(confirmation);
			
			 // in case of IE it seems that the same event, that creates this dialog is propagated further on,
			// therefore ignore the first click
			var clickCounter = Ext.isIE ? 1 : 0; 
			
			// remove the confirmation dialog
			var removeConfirmationDialog = function(e) {
				if (e.target === confirmation) {return;}
				if (clickCounter > 0) {
					clickCounter--;
					return;
				} 
				$confirmation.remove();
				Ext.fly(document).un("click", removeConfirmationDialog);
			};
			
			// Add a click listener on the whole document to remove the confirmation dialog
			Ext.fly(document).on("click", removeConfirmationDialog);
			
			// Remove the row when the yes button is clicked
			$confirmation.child(".y-delete-confirm-yes").on("click", function(e) {
				Event.stop(e);
				$confirmation.remove();
				// TODO Show confirmation dialog to remove the record
				grid.store.remove(riskRecord);
				
				var isRiskGrid = !grid.store.fields.keys.include("riskid");
				// If a risk row is deleted, remove all controls
				if (isRiskGrid) {
					var cStore = this.getControlStore();
					// Find all controls which are associated to the removed risk
					cStore.data.items.findAll(function(controlRecord) {
						return controlRecord.get("riskid") === riskRecord.get("id");
					})
					// And remove them
					.each(function(record) {
						cStore.remove(record);
					});
					
//					this.adjustCellHeight(grid, grid.row, grid.cell, grid.controlCell);
					
				} else {
					// Update the control cell with the new count
					this.updateControlCell(grid);
				}
				this.grid.ownerCt.syncShadow();
			}.bind(this));
			
			// Remove the confirmation when 'no' is clicked
			$confirmation.child(".y-delete-confirm-no").on("click", function(e) {
				Event.stop(e);
				$confirmation.remove();
			});
			
			// Align the confirmation dialog to the delete button inside the row
			grid.el.parent().appendChild($confirmation);
			$confirmation.alignTo(cell, "l-l", this.getConfirmationAlignment());
			
			this.confirmationDialog = $confirmation;
		},
		
		/**
		 * Sadly, yet again different browsers let ext align elements differently to each other,
		 * so depending on the used browser, some small adjustments have to be made
		 * @returns {Array} alignment
		 */
		getConfirmationAlignment : function() {
			if (Ext.isFF) {
				return [-3, 0];
			}
		},
		
		adjustCellHeight : function(grid, row, cell, inner) {

			var offsetLeft = -50;
			
			// Update the height of the active row so the control grid can be inside
			row.dom.style["height"] = (grid.el.getHeight() + cell.originalHeight || (cell.originalHeight = cell.getHeight())) + "px";
			// Let the control grid appear inside the row
			//grid.el.alignTo(inner, "tl-bl", [offsetLeft, 0]);
			
		},
		
		/**
		 * Returns the value of the given property name.
		 * @param {String} prop The name of the property
		 * @param {Object} obj The object to find the value in
		 */
		getLocalizedProperty : function(prop, obj) {
			return ORYX.Core.StencilSet.getTranslation(obj, prop);
			// if (!(obj||{})[prop]) {
			// 	var localizedProp = this.getLocalizedPropertyName(prop);
			// 	return obj[localizedProp] || "";
			// }
			// return obj[prop];
		},
		
		/**
		 * Returns the given property name annotated with the current language
		 * @param {String} prop The property name, e.g. title
		 * @returns {String} e.g. title_de
		 */
		getLocalizedPropertyName : function(prop) {
			// Store the current language lazily for easier reference
			if (!this.lang) {
				this.lang = this.facade.getAllLanguages().first() || ORYX.I18N.Language;
			}
			var lang = (this.lang||"").split("_").first();
			return prop + "_" + lang;
		}
	});
}());
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Christian Wiggert
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function(){
    var NPBData = {
        organisationLevel: {
            title: "Ebene der Verwaltungsorganisation",
            type: "Choice",
            items: ["Bund", "Land", "kommunale Ebene"]
        },
        topics: {
            title: "Themenbereiche",
            type: "Choice",
            multiSelect: true,
            extendable: true,
            items: ["Arbeit", "Auswärtiges", "Bauen und Wohnen", "Bildung", "Familie", "Finanzen", "Forschung", "Frauen", "Gesundheit", "Inneres", "Innere Verwaltung", "Integration", "Justiz", "Kultur", "Natur- und Landschaftspflege", "Rechtliche Planung und Entwicklung", "Schule", "Sicherheit und Ordnung", "Soziales", "Sozial-, Kinder-,Jugend- und Familienhilfe", "Sport", "Stadtentwicklung", "Technologie", "Tourismus", "Umwelt", "Umweltschutz", "Verbraucherschutz", "Ver- und Entsorgung", "Verkehrsflächen und -anlagen (ÖPNV)", "Verkehr", "Verteidigung", "Wirtschaft", "Wissenschaft"]
        },
        processStatus: {
            title: "Status des Prozesses",
            type: "Choice",
            items: ["Lokaler Ist-Prozess", "Interorganisational abgestimmter Ist-Prozess", "Interorganisational abgestimmter Soll-Prozess", "Visionärer Prozess"]
        },
        processType: {
            title: "Prozessart",
            type: "Choice",
            items: ["Unterstützungsprozess", "Kern-/Geschäftsprozess", "Führungsprozess"]
        },
        sizeOfRegionalAdministrationBody: {
            title: "Größe der Gebietskörperschaft",
            type: "Choice",
            items: ["über 400.000", "200.000 - 400.000", "100.000 - 200.000", "50.000 - 100.000", "25.000 - 50.000", "10.000 - 25.000"]
        },
        resultReceiver: {
            title: "Ergebnisempfänger",
            type: "Choice",
            multiSelect: true,
            items: ["Verwaltung (G2G)", "Bürger(G2C)", "Unternehmen (G2B)", "Sonstige verwaltungsexterne, juristische Körperschaften"]
        },
        description: {
            title: "Beschreibung",
            type: "String"
        },
        responsibleOrganisationUnit: {
            title: "Federführende Organisationseinheit",
            type: "String"
        },
        administrativeService: {
            title: "LeiKa-Schlüssel",
            type: "String"
        }
    };

    var CustomTrigger = Ext.extend(Ext.form.TriggerField, {
        triggerClass: "x-trigger-other",
        values: [],

        getValue: function() {
            return this.values;
        },

        onTriggerClick: function() {
            var valueCb = function(values) {
                this.values = values || [];
                this.setValue(this.values.join(', '));
            }.bind(this);
            var combo = new Ext.ux.form.ComboFieldList({
                fieldLabel  : NPBData.topics.title,
                store       : new Ext.ux.form.ChoiceStore({choices: NPBData.topics.items}),
                mode        : 'local',
                listClass   : 'npb-combo-list-wrap',
                onRender    : function() {
                    Ext.ux.form.ComboFieldList.superclass.onRender.apply(this, arguments);
                    this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {
                                    tag: 'div',
                                    style: 'margin: 5px; display:none;' + this.listStyle
                                }));
                    if(!this.itemFieldTpl) {
                        this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty"></span></tpl>',
                            '<ul class="x-combo-multi-list">',
                                '<tpl for=".">',
                                    '<li class="y-filter-combo-list">{[Signavio.Utils.escapeHTML(values[0])]} ',
                                        '<span class="x-smaller">',
                                            '(',
                                                '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>',
                                            ')',
                                        '</span>',
                                    '</li>',
                                '</tpl>',
                            '</ul>');
                    }
                    this.updateView();

                }
            });
            var radioA = new Ext.form.Radio({
                name: 'customRadio',
                boxLabel: Ext.ux.getI18N('propertyeditor.npb.topics.predefined') + ':'
            });
            radioA.on("check", function(checkBox, checked) {
                combo.setDisabled(!checked);
            });
            var radioB = new Ext.form.Radio({
                name: 'customRadio',
                boxLabel: Ext.ux.getI18N('propertyeditor.npb.topics.other') + ':'
            });
            radioB.on("check", function(checkBox, checked) {
                miscText.setDisabled(!checked);
            });
            var miscText = new Ext.form.TextField();
            var dialog = new Ext.ux.Window({
                autoHeight  : true,
                minHeight   : 300,
                width       : 234,
                modal       : true,
                title       : Ext.ux.getI18N('propertyeditor.npb.topics.title'),
                cls         : 'npb-topics-window',
                defaults    : {
                    width: 200
                },
                init        : function(values) {
                    var store = combo.store;
                    if (values.length == 1 && store.query('value', values[0]).length === 0) {
                        miscText.setValue(values[0]);
                        radioB.checked = true;
                        combo.disabled = true;
                    } else {
                        var list = combo.values;
                        values.each(function(v) { list.push([v, v]); });
                        radioA.checked = true;
                        miscText.disabled = true;
                    }
                },
                keys        : [{
                    key : 27,
                    fn  : function(){
                        dialog.destroy();
                        dialog.hide();
                    }
                }],
                closeAction : "close",
                buttons     : [{
                    text    : Ext.ux.getI18N('btnsave'),
                    handler : function(){
                        if (radioA.checked) {
                            valueCb(combo.values.pluck(0));
                        } else {
                            valueCb(miscText.getValue().length > 0 ? [miscText.getValue()] : []);
                        }
                        dialog.destroy();
                        dialog.close();
                    }
                }],
                items       : [
                    new Ext.form.Label({
                        text: Ext.ux.getI18N('propertyeditor.npb.topics.desc')
                    }),
                    radioA,
                    combo,
                    radioB,
                    miscText
                ]
            });
            dialog.init(this.values);
            dialog.show();
        }
    });

    var LeiKaStore = new Ext.data.Store({
        baseParams  : {},
        proxy       : new Ext.data.HttpProxy({
            useAjax : true,
            method  : 'GET',
            headers : {'Accept': 'application/json'},
            url     : '/p/leika' // TODO: which config to use?
        }),
        reader      : new Ext.ux.data.RecordReader({rels: 'leika'})
    });

    var LeiKaBox = function() {
        Ext.PagingToolbar.prototype.paramNames.start = "offset";
        LeiKaBox.superclass.constructor.apply(this, arguments);
    };

    Ext.extend(LeiKaBox, Ext.form.ComboBox, {
        lazyInit            : false,
        typeAhead           : false,
        hideTrigger         : true,
        preventScrollbars   : true,
        forceSelection      : true,
        displayField        : 'rep.id',
        loadingText         : Ext.ux.getI18N('propertyeditor.npb.searching'),
        emptyTextList       : '<div class="x-no-entry">' + Ext.ux.getI18N('propertyeditor.npb.no_leika') + '</div>',
        queryDelay          : 100,
        minChars            : 2,
        pageSize            : 10,
        resizable           : false,
        showEmptyItems      : true,
        queryParam          : "q",
        itemSelector        : 'div.search-item',
        invalidText         : Ext.ux.getI18N('propertyeditor.npb.invalid_leika'),
        tpl                 : new Ext.XTemplate(
                '<tpl for="."><div class="search-item">',
                    '<span><span style="font-weight: bold;">{values.rep.id}</span> - {values.rep.performance}<tpl if="Ext.isDefined(values.rep.performanceDetail) &amp;&amp; values.rep.performanceDetail.length &gt; 0"> ({values.rep.performanceDetail})</tpl> - {values.rep.serviceName}</span>',
                '</div></tpl>'
        ),

        listeners           : {
            select      : function(field, record, index) {
                if (record && record.get("rep")) {
                    this.setValue(record.get("rep").id);
                }
            },
            focus       : function(field) {
                var v = this.getRawValue();
                if (typeof v === 'string' && v.length > this.minChars) {
                    this.doQuery(this.getRawValue());
                }
            }
        },

        validator           : function(value) {
            if (Ext.isDefined(value) && value !== null) {
                return value.match(/^[0-9]{14}$/) !== null;
            }
            return false;
        },

        // @override
        initEvents      : function() {
            LeiKaBox.superclass.initEvents.call(this);

            // Overwrite tab behavior
            this.keyNav.tab = function() {
                if (this.selectedIndex >= 0){
                    this.onViewClick(false);
                } else {
                    this.collapse();
                }
                return true;
            };
        },

        // @override
        initList        : function() {
            var ps = Ext.isNumber(this.pageSize) ? this.pageSize : 10;
            // if the pageSize is 0, no toolbar will be shown
            this.pageSize = 0;
            LeiKaBox.superclass.initList.apply(this, arguments);
            // reset the pageSize afterwards
            this.pageSize = ps;
        },

        // @override
        onEmptyResults  : function() {
            var v = this.getRawValue();
            if (typeof v === 'string' && v.length > 0 && this.showEmptyItems) {
                this.view.el.createChild(this.emptyTextList, this.view.el.first());
            } else {
                this.collapse();
            }
        }

    });

    Ext.ux.propertyeditor.NPBAttributes = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
        windowCreate: {
            cls         : 'y-npb-property-editor',
            width       : 440,
            autoHeight  : true,
            title       : Ext.ux.getI18N('propertyeditor.npb.title')
        },

        renderer: function(value) {
            var i = 0;
            if (value || value.length > 0) {
                var obj = JSON.parse(value);
                var keys = Object.keys(NPBData);
                keys.each(function(key) {
                    if (NPBData[key].multiSelect) {
                        var v = this.parseMultiSelect(obj[key]);
                        if (v.length > 0)
                            i++;
                    } else if (obj[key] && obj[key].value && obj[key].value.length > 0)
                        i++;
                }.bind(this));
            }

            return i + Ext.ux.getI18N('propertyeditor.npb.render_msg');
        },

        parseMultiSelect: function(obj) {
            if (obj) {
                var v;
                if (typeof obj === "string") {
                    var temp = JSON.parse(obj);
                    if (typeof temp === "object") {
                        v = temp.value;
                    }
                } else if (typeof obj === "object") {
                    v = obj.value;
                }
                if (v) {
                    if (typeof v === "string") {
                        return JSON.parse(v);
                    } else if (v instanceof Array) {
                        return v;
                    }
                    // else we assume there is some kind of invalid value
                    // and return the default value
                }
            }
            return [];
        },

        parseValue: function(obj) {
            var v;
            if (obj) {
                if (typeof obj === "string") {
                    var temp = JSON.parse(obj);
                    if (typeof temp === "object") {
                        v = temp.value;
                    }
                } else if (typeof obj === "object") {
                    v = obj.value;
                }
            }
            return v || "";
        },

        getEditor: function(value) {
            // parse value to JSON or create initial JSON
            var obj;
            if (value !== null && value.length > 0) {
                obj = JSON.parse(value);
            } else {
                obj = {};
            }

            return new Ext.Panel({
                initialValue: obj,
                border: false,
                anchor: "100% 100%",
                layout: "form",
                labelWidth: 200,
                defaults: {
                    width: 200
                },
                getValue: function() {
                    // override the existing fields with the new values
                    // so not editable values don't get lost
                    this.initialValue.organisationLevel = this.wrapValue(this.items.items[0].getValue(), 'text');
                    this.initialValue.topics = this.wrapValue(this.items.items[1].getValue(), 'liste');
                    this.initialValue.processStatus = this.wrapValue(this.items.items[2].getValue(), 'text');
                    this.initialValue.processType = this.wrapValue(this.items.items[3].getValue(), 'text');
                    this.initialValue.sizeOfRegionalAdministrationBody = this.wrapValue(this.items.items[4].getValue(), 'text');
                    this.initialValue.resultReceiver = this.wrapValue(this.items.items[5].getValue(), 'liste');
                    this.initialValue.description = this.wrapValue(this.items.items[6].getValue(), 'text');
                    this.initialValue.responsibleOrganisationUnit = this.wrapValue(this.items.items[7].getValue(), 'text');
                    this.initialValue.administrativeService = this.wrapValue(this.items.items[8].getValue(), 'text');
                    return Object.toJSON(this.initialValue);
                },
                wrapValue: function(value, type) {
                    return {
                        'value': value,
                        'type': type
                    };
                },
                items: [
                        new Ext.ux.form.ComboBox({
                            fieldLabel  : NPBData.organisationLevel.title,
                            readOnly    : true,
                            store       : new Ext.ux.form.ChoiceStore({choices: NPBData.organisationLevel.items}),
                            value       : this.parseValue(obj.organisationLevel),
                            mode        : 'local',
                            listClass   : 'npb-combo-list-wrap'
                        }),
                        new CustomTrigger({
                            fieldLabel  : NPBData.topics.title,
                            readOnly    : true,
                            values      : this.parseMultiSelect(obj.topics),
                            value       : this.parseMultiSelect(obj.topics).join(', ')
                        }),
                        new Ext.ux.form.ComboBox({
                            fieldLabel  : NPBData.processStatus.title,
                            readOnly    : true,
                            store       : new Ext.ux.form.ChoiceStore({choices: NPBData.processStatus.items}),
                            value       : this.parseValue(obj.processStatus),
                            mode        : 'local',
                            listClass   : 'npb-combo-list-wrap'
                        }),
                        new Ext.ux.form.ComboBox({
                            fieldLabel  : NPBData.processType.title,
                            readOnly    : true,
                            store       : new Ext.ux.form.ChoiceStore({choices: NPBData.processType.items}),
                            value       : this.parseValue(obj.processType),
                            mode        : 'local',
                            listClass   : 'npb-combo-list-wrap'
                        }),
                        new Ext.ux.form.ComboBox({
                            fieldLabel  : NPBData.sizeOfRegionalAdministrationBody.title,
                            readOnly    : true,
                            store       : new Ext.ux.form.ChoiceStore({choices: NPBData.sizeOfRegionalAdministrationBody.items}),
                            value       : this.parseValue(obj.sizeOfRegionalAdministrationBody),
                            mode        : 'local',
                            listClass   : 'npb-combo-list-wrap'
                        }),
                        new Ext.ux.form.RadioGroup({
                            fieldLabel  : NPBData.resultReceiver.title,
                            store       : new Ext.ux.form.ChoiceStore({choices: NPBData.resultReceiver.items}),
                            multiSelect : true,
                            labelWidth  : 200,
                            autoWidth   : true,
                            values      : this.parseMultiSelect(obj.resultReceiver)
                        }),
                        new Ext.form.TextArea({
                            fieldLabel  : NPBData.description.title,
                            value       : this.parseValue(obj.description)
                        }),
                        new Ext.form.TextField({
                            fieldLabel  : NPBData.responsibleOrganisationUnit.title,
                            value       : this.parseValue(obj.responsibleOrganisationUnit)
                        }),
                        new LeiKaBox({
                            store       : LeiKaStore,
                            fieldLabel  : NPBData.administrativeService.title,
                            value       : this.parseValue(obj.administrativeService),
                            listClass   : 'npb-leika-list-wrap'
                        })]
                        // new Ext.form.TextField({
                        //     fieldLabel  : NPBData.administrativeService.title,
                        //     value       : this.parseValue(obj.administrativeService)
                        // })]
            });
        }
    });
})();/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Property Editor for remote accessible property editors of a customer
	 * specific implementation.
	 * 
	 * The remote property editor is loaded into an iFrame. Submit value 
	 * exchange than is again realized by an iFrame, initiated by the remote
	 * property editor. A Signavio JS Snipped is provided for OEM customers.
	 */
	Ext.ux.propertyeditor.RemoteProperty = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width:undefined, noButtons: true, hideCancelButton: true},
		
		/**
		 * It is assumed that value is of format {rawValue:"..", renderedValue:".."}
		 * 
		 * @param value
		 */
		getEditor: function(value) {
			var remoteEditorFrame = document.createElement("iframe")
			 , form = document.createElement("form")
			 , inputVal = document.createElement("input")
			 , iFrameId = "signavio_remoteproperty_" + Ext.id()
			 , propData = value||{}
			 , me = this;
			
			remoteEditorFrame.setAttribute("name", iFrameId);
			remoteEditorFrame.setAttribute("id", iFrameId);
			remoteEditorFrame.setAttribute("frameborder", "0");
			remoteEditorFrame.setAttribute("frameBorder", "0");
			remoteEditorFrame.setAttribute("height", "100%");
			remoteEditorFrame.setAttribute("width", "100%");
			remoteEditorFrame.setAttribute("marginheight", "0");
			remoteEditorFrame.setAttribute("marginwidth", "0");
			remoteEditorFrame.setAttribute("scrolling", "no");
			
			remoteEditorFrame.doSubmit = function(propDataSubmit){
				// Transform to JSON String
				propData = Object.toJSON(propDataSubmit)||"";
				
				// Call save
				if (me.win) {
					if (me.onBeforeSave(me.getValue(), panel.getValue())) {
						me.onSave(me.getValue(), panel.getValue());	
						me.win.close();
					}
					
//					me.win.destroy();
				}
			};
			
			remoteEditorFrame.cancelPropEdit = function() {
				if (me.win) {
					me.win.close();
//					me.win.destroy();
				}
			};
			
			/**
			 * Takes the property value string and returns the respective JSON
			 * object.
			 */
			remoteEditorFrame.getPropertyData = function() {
				var defaultVal = {rawValue:"", renderedValue:""};
				if ("string" == typeof propData) {
					try {
						return propData.evalJSON();
					} catch (e) {
						return defaultVal;
					}
				}
				return defaultVal;
			};
			
			/**
			 * Collects property data on submit from the iframe creating
			 * form and stores it for further processing.
			 * @returns
			 */
			var collectPostData = function() {
				propData = inputVal.getAttribute('value');
				console.log("onsubmit", propData);
				return true;
			};
			
			//Set form attributes to open the property editor in an iFrame and
			//to post the value data
			form.setAttribute("action", this.property.url());
			form.setAttribute("method", "POST");
			form.setAttribute("target", iFrameId);
			
			//Set form input to pass value to remote
			inputVal.setAttribute("name", "signavio_remoteproperty_value");
			inputVal.setAttribute("value", propData);
			
			form.appendChild(inputVal);
			remoteEditorFrame.appendChild(form);
			
			
			// Create editor panel
			// Window options
			
			if (!this.windowCreate.height) {
				this.windowCreate.height = this.property.remoteWindowHeight();
			}
			if (!this.windowCreate.width) {
				this.windowCreate.width = this.property.remoteWindowWidth();
			}
			this.windowCreate.autoScroll = this.property.remoteWindowAutoScroll();
			
			var panel = new Ext.Panel({
				html: '',
				border: false,
				anchor: "100% 100%",
				layout: "form",
				cls: "x-remoteprop",
				autoScroll: this.property.remoteWindowAutoScroll()||false,
				getValue: function(){
					return propData;
				},
				listeners: {
					render: function() {
						this.body.appendChild(remoteEditorFrame);
						
						// Append property value
						var eForm = Ext.get(form);
						eForm.on('onsubmit', collectPostData);
						form.submit();
					}
				}
			});
			
			
			return panel;
		},
		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			// VARs
			var valueObj, renderedVal = "";
			
			var renderToStringFn = function(val) {
				if ("string" == typeof val) {
					return val;
				} else {
					return Object.toJSON(val);
				}
			};
			
			if (value && "string" == typeof value) {
				try {
					valueObj = value.evalJSON();
				} catch (e) {
				}
			} 
			
			// Get the rendered value
			if (valueObj) {
				if (valueObj.renderedValue) {
					renderedVal = renderToStringFn(valueObj.renderedValue);
				}
			}
			
			// Case still no readable value
			if (!renderedVal && value && value.renderedValue) {
				renderedVal = renderToStringFn(value.renderedValue);
			}
			
			if (!renderedVal && value) {
				renderedVal = renderToStringFn(value);
			}
			
			return renderedVal.truncate(20, '...');
		}
		
		
	});
	
}();/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {} }

new function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.SaperionACL = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width:350},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			var conf = this.property.autocomplete();
			var skript = new Ext.ux.form.ComboBox({
							hideTrigger: conf.trigger === false,
							forceSelection: conf.optional === false,
					        typeAhead: conf.optional === false, 
					        url: conf.url,
							allowBlank: this.property.optional(),
							fieldLabel: this.property.title().split(":").last(),
							style:"margin-bottom: 5px;",
							value: ["+", "-"].include(String(value).slice(0, 1)) ? String(value).slice(1) : String(value)
					    });
			
						
			return new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "form",
				getValue: function(){
					var pre = this.items.last().checked ? "-" : "+",
						value = String(skript.getValue()).trim();
					return value ? pre+value : "";
				},
				defaults: {
					width: 200
				},
				items: [skript, 
						new Ext.form.Radio({
							fieldLabel: Ext.ux.getI18N("panel.operation"),
							boxLabel: Ext.ux.getI18N("panel.add"),
							style:"position: relative;top: 2px;",
							labelStyle:"padding: 1px 0;",
							checked: !String(value).startsWith("-"),
							name:"x-saperion-operation"
						}), 
						new Ext.form.Radio({
							fieldLabel: "",
							labelSeparator : "",
							style:"position: relative;top: 2px;",
							labelStyle:"padding: 1px 0;",
							boxLabel: Ext.ux.getI18N("panel.remove"),
							checked: String(value).startsWith("-"),
							name:"x-saperion-operation"
						})]
			});
		}
		
	});	
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion performer dialog.
	 * 
	 */
	Ext.ux.propertyeditor.SaperionPerformer = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		types: {
			"GRPORGUNIT": "group",
			"GRPROLE": "group",
			"GRPSIMPLE": "group",
			"GRPMEMBER": "user"
		},
		
		windowCreate: {height:undefined, width:630, resizable: false},
		
		url: "/p/saperion?proxy=members",
		
		/**
		 * Returns TRUE if the value is a json object
		 * @param {Object} value
		 */
		isStaticValue: function(value){
			return String(value).startsWith("{") && String(value).endsWith("}");
		},
		
				
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if (this.isStaticValue(value)){
				var obj = this.parsePerformers(value);
				return (obj.items||[]).pluck("fullname").join(", ")+""+(obj.selectuser ? " "+Ext.ux.getI18N("panel.label_free_userselection")+"":"");	
			} else {
				return value;
			}
		},
		
		/**
		 * Returns a panel where the performer form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			
			var enableStaticValue = !value || this.isStaticValue(value), performers = {totalCount:0, items:[]}, br = "";
			
			if (enableStaticValue){
				performers = this.parsePerformers(value);
			} else {
				br = value;
			}
			
			
			this.panel = new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "form",
				cls: "ext-el-mask-no-background x-performer-dialog",
				hideLabels: true,
				getValue: this.extractValue.bind(this),
				items: [
					// STATIC
					new Ext.form.Radio({
						boxLabel: Ext.ux.getI18N("panel.static"),
						name: "performertype",
						checked: enableStaticValue,
						listeners: {
							check: function(f, checked){
								var items = this.ownerCt.items.items;
								items.slice(1, items.length-2).invoke("setDisabled", !checked);
								items[3].setDisabled(!checked || !items[1].checked);
							}
						}
					}), 
					new Ext.form.Checkbox({
						boxLabel: Ext.ux.getI18N("panel.no_free_userselection"),
						style: "position:relative;top:2px;",
						checked: performers.selectuser || false,
						onRender: function(){
							Ext.form.Checkbox.prototype.onRender.apply(this, arguments);
							var width = this.ownerCt.items.get(0).wrap.child("label").getWidth();
							this.container.parent().setStyle({top: "0px", position: "absolute", left: (width+40)+"px"});
						},
						listeners: {
							check: function(cb, checked){
								cb.ownerCt.items.get(3).setDisabled(!checked);
							}
						}
					}), 
					new Ext.Panel({
						border: false,
						html:  Ext.ux.getI18N("panel.no_defined_role_label")+":",
						bodyStyle: "padding: 5px 0 2px 86px;"
					}),
					new Ext.Panel({
						border: false,
						layout: "column",
						bodyStyle: "padding-left: 86px;padding-bottom: 10px;", 
						listeners: { render: function(r){ if (!performers.selectuser) r.disable(); }},
						getValue: function(){
							return {
								selectsingleuser: this.items.get(0).items.get(0).checked,
								selectrolemember: this.items.get(1).items.get(0).checked,
								selectrole: this.items.get(2).items.get(0).checked
							};
						},
						items: [new Ext.Panel({
									border: false,
									columnWidth: 0.3,
									items: [new Ext.form.Checkbox({
										style: "position:relative;top:2px;",
										boxLabel: Ext.ux.getI18N("panel.no_defined_role_single_user"),
										checked: performers.selectsingleuser !== false
									})]
								}),new Ext.Panel({
									border: false,
									columnWidth: 0.3,
									items: [new Ext.form.Checkbox({
										style: "position:relative;top:2px;",
										boxLabel: Ext.ux.getI18N("panel.no_defined_role_role_member"),
										checked: performers.selectrolemember !== false
									})]
								}),new Ext.Panel({
									border: false,
									columnWidth: 0.3,
									items: [new Ext.form.Checkbox({
										style: "position:relative;top:2px;",
										boxLabel: Ext.ux.getI18N("panel.no_defined_role_group"),
										checked: performers.selectrole !== false
									})]
								})]
					}),
					this.getPerformerPanel(performers, !enableStaticValue),
					
					// DYNAMIC
					new Ext.form.Radio({
						boxLabel:Ext.ux.getI18N("panel.dynamic"),
						name:"performertype",
						checked: !enableStaticValue,
						listeners: {
							 check: function(f, checked){
								this.ownerCt.items.last().setDisabled(!checked);
							}
						}
					}),
//					new Ext.form.TextField({
//						width: 575,
//						emptyText: Ext.ux.getI18N("panel.businessrule"),
//						style: "margin-left:20px;",
//						disabled: enableStaticValue,
//						value: br
//					})
					new Ext.ux.form.ComboBox({
						emptyText: Ext.ux.getI18N("panel.businessrule"),
						exceptionText: "Der SAPERION Server ist nicht erreichbar.",
						hideTrigger: false,
						forceSelection: false,
				        typeAhead: true, 
				        url: "./saperion?proxy=script",
						allowBlank: true,
						width: 575,
						disabled: enableStaticValue,
						value: br,
						afterRender: function(){
							Ext.ux.form.ComboBox.prototype.afterRender.apply(this, arguments);
							this.wrap.setStyle("margin-left", "20px");
						}
				    })
				]
			});
			
			return this.panel;
		},
		
		/**
		 * Returns the Ext.Panel to define the performers.
		 * @param {Array} performers
		 * @param {Boolean} enabled
		 * @return {Ext.Panel}
		 */
		getPerformerPanel: function(performers, enabled){
			
			var height = 300, performerList, self = this, me = this;
			
			// Store which holds all performers
			var store = new Ext.data.SimpleStore({
				data: performers.items.map(function(per){
					return [per.fullname, per.type || "", per.description || "", per.uid || ""];
				}),
				fields: ["fullname", "type", "description", "uid"]
			});
			
			// List of all available performers
			var performerTree = new Ext.tree.TreePanel({
				rootVisible: false,
				root: new Ext.tree.AsyncTreeNode({}),
				loader: new Ext.tree.TreeLoader({
					url: this.url,
					requestMethod: "GET",
					listeners: {
						beforeload: function(foo, node){
							if (node.attributes.uid)
								this.baseParams.uid = node.attributes.uid;
						},
						load: function(){
							if (performerTree.root.spinner){
								Ext.get(performerTree.root.ui.wrap).first().remove();
								delete performerTree.root.spinner;
							}
						},
						loadexception: function(){
							var wrap = Ext.get(performerTree.root.ui.wrap);
							wrap.first().remove();
							wrap.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
										 	"<img src='"+Ext.IMAGE_URL+"/famfamfam/error.png' style='margin-right:5px;opacity:0.2;position:relative;top:4px;width:16px;height:16px;'/>" +
										 	"Der SAPERION Server ist nicht erreichbar." +
										 "</div>");
						}
					},
					// Specific mapping of response to node attribute
					createNode: function(attr){
						attr.text = attr.fullname;
						attr.leaf = (self.types[attr.type] || attr.type) === "user";
						attr.cls  = attr.type ? "x-" + (self.types[attr.type] || attr.type) : "";
						return Ext.tree.TreeLoader.prototype.createNode.call(this, attr);
					},
					//@overwrite
					requestData : function(node, callback){
				        if(this.fireEvent("beforeload", this, node, callback) !== false){
				            this.transId = Ext.Ajax.request({
				                method:this.requestMethod,
				                url: this.dataUrl||this.url,
				                success: this.handleResponse,
				                failure: this.handleFailure,
				                scope: this,
				                argument: {callback: callback, node: node},
				                params: this.getParams(node),
				                headers:{Accept: "application/json"}
				            });
				        }else{
				            // if the load is cancelled, make sure we notify
				            // the node that we are done
				            if(typeof callback == "function"){
				                callback();
				            }
				        }
				    }
				}),
				autoScroll: true,
				cls: "x-performer-tree",
				columnWidth: 0.5,
				height: height,
				afterRender	: function(){
					Ext.tree.TreePanel.prototype.afterRender.apply(this, arguments);
					
					// Waiting spinner
					this.root.spinner = this.root.ui.wrap.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
											 	"<img src='/libs/ext-2.0.2/resources/images/default/grid/loading.gif' style='margin-right:5px;opacity:0.4;position:relative;top:4px;'/>" +
											 	"User werden geladen." +
											 "</div>");
				}
			});
			
			
			// Buttons in the middle to add/remove performer
			var selector = new Ext.Panel({
				border: false,
				width: 47,
				height: height,
				cls: "x-performer-selector",
				bodyStyle: "display:table-cell;padding:10px;text-align:center;vertical-align:middle;",
				items: [
					
					// Left -> Right
					new Ext.Button({
						icon: ""+Ext.IMAGE_URL+"/famfamfam/arrow_right.png",
						iconCls: "dummy",
						style: "margin-bottom: 5px", 
						disabled: true,
						handler: function(){
							// Get selected node
							var node = performerTree.getSelectionModel().getSelectedNode();
							if (node){
								// Create a new record and add it
								var attr = node.attributes;
								var addRegular = function(){
									var record = new store.recordType({fullname:node.text, description: attr.description||"", type: attr.type || "", uid: attr.uid || ""});
									store.add(record);
									this.disable();
								}.bind(this);
								
								if (!node.isLeaf() && ["parallel", "sequential"].include((me.facade.getSelection()[0].properties["oryx-looptype"]||"").toLowerCase())){
									Ext.Msg.confirm(Ext.ux.getI18N("panel.no_parallel_title"), Ext.ux.getI18N("panel.no_parallel_description"), function(btn){
										if (btn == "yes"){
											Ext.Ajax.request({
								                method:"get",
								                url: self.url+"&"+Ext.urlEncode(attr),
								                success: function(e){
								                	try {
								                		var json = e.responseText.evalJSON();
								                		if (json instanceof Array){
								                			json = json.findAll(function(child){
								                				return ["GRPMEMBER", "USER"].include(child.type);
								                			});
								                			json.each(function(child){
																store.add(new store.recordType(child));
								                			});
								                		}
								                		if (!(json instanceof Array) || json.length <= 0){
								                			Ext.Msg.alert(Ext.ux.getI18N("panel.no_parallel_title"), Ext.ux.getI18N("panel.no_parallel_no_user")).setIcon(Ext.Msg.INFO).getDialog().syncSize();
								                		}
								                	} catch(err){}
								                	performerList.el.unmask();
								                }.bind(this),
								                failure: function(){
								                	performerList.el.unmask();
								                },
								                headers:{Accept: "application/json"}
								            });
											this.disable();
											performerList.el.mask("Date werden geladen...", "x-mask-loading");
										} else {
											addRegular();
										}
									}.bind(this));
								} else {
									addRegular();
								}
								
							}
						}
					}),
					
					// Right -> Left
					new Ext.Button({
						icon: ""+Ext.IMAGE_URL+"/famfamfam/arrow_left.png",
						iconCls: "dummy",
						disabled: true,
						handler: function(){
							// Remove entry
							performerList.getSelectedRecords().each(function(record){
								store.remove(record);
							});
							// Update the list
							performerList.refresh();
						}
					})
				]
			});
			
			// List of all selected performers
			performerList = new Ext.DataView({
		        store: store,
				prepareData: function(data){
					data = Object.clone(data);
					data.descCls = !data.description || data.description === Ext.ux.getI18N("panel.no_description") ? "x-empty" : "";
					data.description = data.description || Ext.ux.getI18N("panel.no_description");
					data.type = self.types[data.type] || data.type;
					return data;
				},
		        tpl: new Ext.XTemplate(
						    '<tpl for=".">',
						        '<div class="thumb-wrap">',
						        	'<div class="x-fullname x-type-{type}">{fullname}</div>',
									'<div class="x-description {descCls}">{description}</div>',
								'</div>',
						    '</tpl>',
						    '<div class="x-clear"></div>'),
				cls: "x-performer-list",
				columnWidth: 0.5,
				height: height,
				autoScroll: true,
		        multiSelect: true,
		        overClass:'x-view-over',
		        itemSelector:'div.thumb-wrap',
		        emptyText: '<span class="x-default">'+Ext.ux.getI18N("panel.no_performer")+'</span>'
		    });


			// Enable/disable buttons in the middle
			performerTree.getSelectionModel().on("selectionchange", function(foo, node){
				var isFirstLevelNode 	= false; //!node.parentNode || !node.parentNode.parentNode;
				var isAlreadyIncluded 	= store.find("fullname", node.text || "") >= 0;
				selector.items.get(0).setDisabled(isFirstLevelNode || isAlreadyIncluded);
			});
			performerList.on("selectionchange", function(foo, sel){ selector.items.get(1).setDisabled(sel.length == 0);});
			
			
			
			return new Ext.Panel({
						border: false,
						layout: "column",
						bodyStyle: "padding-bottom:10px;padding-left:20px;",
						disabled: enabled,
						items: [performerTree, selector, performerList],
						/**
						 * Returns the set of all selected performers
						 */
						getValue: function(){
							if (store.getCount() > 0) {
								return {
									totalCount: store.getCount(),
									items: store.getRange().map(function(record){
										return {
											uid: record.get("uid"),
											fullname: record.get("fullname"),
											description: record.get("description"),
											type: record.get("type")
										};
									})
								};
							} else {
								return undefined;
							}
						}
					});
		},
		
		/**
		 * Returns the current value
		 * @return {String}
		 */
		extractValue: function(){
			
			if (this.panel.items.get(0).getValue()) {
				// Static perfomers
				var performers = this.panel.items.get(4).getValue();
				if (this.panel.items.get(1).getValue()){
					if (performers)
						performers.selectuser = true;
					else 
						performers = {totalCount:0, items:[], selectuser:true};
					
					performers = Ext.apply({}, performers, this.panel.items.get(3).getValue());
				}
				if (performers){
					performers = Object.toJSON(performers);
				}
				return performers;
			} else {
				// Dynamic business rule
				return this.panel.items.get(6).getValue();
			}
		},
		
		/**
		 * Returns the javascript array of all performers which
		 * are defined through the value.
		 * @param {String} value
		 * @return {Object}
		 */
		parsePerformers: function(value){
			return value ? String(value).evalJSON() : {totalCount:0, items:[]};
		}
		
	});	
	
}());
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {} }

new function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.SaperionSkript = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width:350},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			// Get the script_language property
			var sl = (this.properties||[]).find(function(r){ return r.id().endsWith("script_language") });
			var slvalue = this.facade.getSelection()[0].properties[sl.prefix()+"-"+sl.id()];
			
			// Generate the fields
			this.skripLanguage = new Ext.form.ComboBox({
							value: slvalue,
							fieldLabel: sl.title(),
					        store: new Ext.data.SimpleStore({
							        fields: ['value'],
							        data : sl.items().map(function(r){ return [r.title()]; })
							    }),
					        displayField:'value',
					        typeAhead: true,
					        mode: 'local',
					        triggerAction: 'all',
					        selectOnFocus:true,
					        editable: false,
					        readOnly: true,
							listeners: {
								change : function(foo, language){
									if (language) {
										this.skript.store.baseParams.language = language;
									} else {
										delete this.skript.store.baseParams.language;
									}
									delete this.skript.lastQuery;
								}.bind(this)
							}
					    });
		
			var conf = this.property.autocomplete();
			this.skript = new Ext.ux.form.ComboBox({
							hideTrigger: conf.trigger === false,
							forceSelection: conf.optional === false,
					        typeAhead: conf.optional === false, 
					        url: conf.url,
							allowBlank: this.property.optional(),
							fieldLabel: this.property.title()
					    });
			
			if (slvalue){ // Set the scripting language
				this.skript.store.baseParams.language = slvalue;
			}
						
			return new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "form",
				getValue: function(){
					return this.skript.getValue();
				}.bind(this),
				defaults: {
					width: 200
				},
				items: [this.skripLanguage, this.skript]
			})
		},
		
		onSave: function(oldValue, newValue){
			this.setValue(newValue);
			
			// Check if the scripting language has changed
			var slv = this.skripLanguage.getValue(), key = "oryx-script_language", sel = this.facade.getSelection();
			if (sel.any(function(r){ return r.properties[key] !== slv})) {
				var self = this;			
				// Use a command to set the scripting language
				var Command = ORYX.Core.Command.extend({
					construct: function(){
						this.shapes = sel;
						this.key = key;
						this.value = slv;
						this.oldValues = this.shapes.map(function(e){
							return e.properties[this.key];
						})
					},
					execute: function(){
						this.shapes.invoke("setProperty", this.key, this.value);
						if (!this.executed) {
							self.fireEvent('dialogClosed', this, newValue, oldValue);
						}
						this.executed = true;
						this.update();
					},
					rollback: function(){
						this.shapes.each(function(shape, i){
							shape.setProperty(this.key, this.oldValues[i])
						}.bind(this));
						this.update();
					},
					update: function(){
						if (oldValue == newValue) {
							self.facade.setSelection([]);
							self.facade.setSelection(this.shapes);
						}
					}
				});
				this.facade.executeCommands([new Command()]);
			} else {
				this.fireEvent('dialogClosed', this, newValue, oldValue);
			}
		}
		
	});	
	
}()
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {} }

new function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.SaperionTimeDelay = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width:340, resizable: false},
		
		/**
		 * Returns an array with 7 ints which defined the time (from year to milliseconds).
		 * @param {Object} value
		 */
		parseTimes: function(value){
			return value.split(/(.{2})/g)
						.findAll(function(r){return r; })
						.map(function(r){ return parseInt(r) || 0; });
		},
		
		/**
		 * Returns TRUE if the value is a static time delay value
		 * @param {Object} value
		 */
		isStaticValue: function(value){
			return value.length == 6 && !!String(value).match(/^[0-9]*$/);
		},
		
		/**
		 * Returns TRUE if the value is a dynamic time delay value
		 * @param {Object} value
		 */
		isDynamicValue: function(value){
			return !this.isStaticValue(value);
		},

		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if (this.isStaticValue(value)){
				var get = Ext.ux.getI18N;
				var labels 	= [get("day"),  get("hour"),  get("minute")];
				var labelss = [get("days"), get("hours"), get("minutes")];
				
				return this.parseTimes(value)
						.map(function(val, i){
							return val ? val + " " + (val==1?labels:labelss)[i] : undefined; 
						}).compact().join(", ");
				
			} else {
				return value;
			}
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			value = String(value).trim();
			var ac = {tag: "input", type: "text", size: "20", autocomplete: "off", maxlength: "2"};
			var defaults = {
				style: "margin-right:5px;padding:1px;",
				allowDecimals: false,
				allowNegative: false,
				width: 90,
				validationEvent: false,
				getLabelPrefix: function(num){
					return "";
				},
				initValue: function(){
					Ext.form.NumberField.prototype.initValue.apply(this, arguments);
					this.initialConfig.listeners.blur.call(this);
				},
				listeners: {
					focus: function(){
						this.setRawValue(parseInt(this.getRawValue())||"");
					},
					blur: function(){
						var num = parseInt(this.getRawValue());
						if (num){
							this.setRawValue(num + " " + this.getLabelPrefix(num));
						}
					}
				}
			};
			
			var defaultsLabel = {
				xtype: "label",
				style: "padding:5px 0px 4px 3px;"
			};
			
			var times = [], br = "";
			if (this.isStaticValue(value)){
				times = this.parseTimes(value);
			} else {
				br = value;
			}
			
			// Day
			this.days = new Ext.form.NumberField(Ext.apply({}, {
								value : times[0] || "",
								autoCreate : Object.clone(ac),
								emptyText : Ext.ux.getI18N("days"),
								getLabelPrefix: function(num){
									return num == 1 ? Ext.ux.getI18N("day"): Ext.ux.getI18N("days");
								}
							}, defaults));
			// Hour
			this.hours = new Ext.form.NumberField(Ext.apply({}, {
								value : times[1] || "",
								autoCreate : Object.clone(ac),
								emptyText : Ext.ux.getI18N("hours"),
								getLabelPrefix: function(num){
									return num == 1 ? Ext.ux.getI18N("hour"): Ext.ux.getI18N("hours");
								}
							}, defaults));
			// Minute
			this.minutes = new Ext.form.NumberField(Ext.apply({}, {
								value : times[2] || "",
								autoCreate : Object.clone(ac),
								emptyText : Ext.ux.getI18N("minutes"),
								getLabelPrefix: function(num){
									return num == 1 ? Ext.ux.getI18N("minute"): Ext.ux.getI18N("minutes");
								}
							}, defaults));
			
			var enableStaticValue = !value || this.isStaticValue(value);
			
			this.panel = new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "form",
				cls: "ext-el-mask-no-background",
				hideLabels: true,
				getValue: this.extractValue.bind(this),
				items: [
				        
				    // STATIC
					new Ext.form.Radio({
						boxLabel: Ext.ux.getI18N("panel.static"),
						name: "timedelay",
						checked: enableStaticValue,
						listeners: {
							 check: function(f, checked){
								this.ownerCt.items.get(1).setDisabled(!checked);
							}
						}
					}),
					new Ext.Panel({
						border: false,
						layout: "column",
						bodyStyle: "padding-bottom:10px;padding-left:20px;",
						disabled: !enableStaticValue,
						items: [this.days, 		//Ext.apply({}, defaultsLabel, {width: 40, text: Ext.ux.getI18N("days")+""}),
								this.hours, 	//Ext.apply({}, defaultsLabel, {width: 55, text: Ext.ux.getI18N("hours")+""}), 
								this.minutes]//, 	//Ext.apply({}, defaultsLabel, {width: 55, text: Ext.ux.getI18N("minutes")+""})]
					}),
					
					// DYNAMIC
					new Ext.form.Radio({
						boxLabel:Ext.ux.getI18N("panel.dynamic"),
						name:"timedelay",
						checked: !enableStaticValue,
						listeners: {
							 check: function(f, checked){
								this.ownerCt.items.get(3).setDisabled(!checked);
							}
						}
					}),
//					new Ext.form.TextField({
//						width: 280,
//						emptyText: Ext.ux.getI18N("panel.businessrule"),
//						style: "margin-left:20px;",
//						disabled: enableStaticValue,
//						value: br
//						
//					})
					new Ext.ux.form.ComboBox({
						emptyText: Ext.ux.getI18N("panel.businessrule"),
						exceptionText: "Der SAPERION Server ist nicht erreichbar.",
						hideTrigger: false,
						forceSelection: false,
				        typeAhead: true, 
				        url: "./saperion?proxy=script",
						allowBlank: true,
						width: 280,
						disabled: enableStaticValue,
						value: br,
						afterRender: function(){
							Ext.ux.form.ComboBox.prototype.afterRender.apply(this, arguments);
							this.wrap.setStyle("margin-left", "20px");
						}
				    })
				]
			});
			
			return this.panel;
		},
		
		/**
		 * Returns the value of the selected time delay
		 * 
		 */
		extractValue: function(){
			if (this.panel.items.get(0).getValue()){
				// DDHHMM
				return  this.getStringValueOf(this.days.getValue()) +
						this.getStringValueOf(this.hours.getValue()) +
						this.getStringValueOf(this.minutes.getValue());
			} else {
				// Dynamic business rule
				return this.panel.items.get(3).getValue();
			}
		},
		
		/**
		 * Returns a two diggit string of the number with a leading zero
		 * @param {Number} number
		 */
		getStringValueOf: function(number){
			number = String(number) || "00";
			return number.length == 1 ? "0" + number : number;
		}
		
	});	
	
}()
/**
 *  (c) 2011 Signavio GmbH
 *
 *  @author Philipp Giese
 *
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {

    /**
     * Id of the attribute, that is used to indicate, that no selection has
     * been made.
     */
    var NO_SELECTION = "__no_selection__";
    /**
     * Id of the element, that is inserted as a group header for property
     * categories
     */
    var GROUP_SPACER = "__group_header__";

    /**
     * Name of the category, that should be expanded by default
     */
    var EXPAND_GROUP = Ext.ux.getI18N("attribute.mapper.config.meta_properties");

    var NAMESPACE = "http://www.signavio.com/stencilsets/processdoctemplate#";

    /**
     * List of stencilsets, that must NOT show up in the list.
     */
    var BLACKLIST = [
        "http://www.signavio.com/stencilsets/processdoctemplate#"
    ];

    var CACHE = {
        StencilsetPreview: [],
        StencilsetIcons: {},
        Stencilsets: {},
        MetaAttributes: undefined
    };

    var Record = Ext.data.Record.create([
        { name: "checked", mapping: "checked" },
        { name: "icon", mapping: "icon" },
        { name: "id", mapping: "id" },
        { name: "title", mapping: "title" },
        { name: "group", mapping: "group" },
        { name: "root", mapping: "root" },
        { name: "stencilset", mapping: "stencilset" },
        { name: "stencil", mapping: "stencil" },
        { name: "readonly", mapping: "readonly" },
        { name: "meta", mapping: "meta" },
        { name: "list", mapping: "list" },
        { name: "position", mapping: "position" },
        { name: "roles", mapping: "roles" },
        { name: "propertyGroup", mapping: "propertyGroup" },
        { name: "collapsed", mapping: "collapsed" },
        { name: "stencilsetIcon", mapping: "stencilsetIcon" }
    ]);

    var EVENTS = {
        PANEL_EXPANDED: "attribute.mapper.panel.expanded",
        STENCILSETS_LOADED: "attribute.mapper.stencilsets.loaded",
        STENCILSET_LOADED: "attribute.mapper.stencilset.loaded"
    };

    Signavio.Config.registerEvents("AttributeMapper", {
        StencilsetsLoaded: EVENTS.STENCILSETS_LOADED,
        PanelExpanded: EVENTS.PANEL_EXPANDED,
        StencilsetLoaded: EVENTS.STENCILSET_LOADED
    });

    /**
     * This is a generic editor, that is used to map certain attributes
     * to elements in the process documentation templates. It can be used to:
     *
     *  - Select stencil sets
     *  - Select elements
     *  - Select properties of elements
     *
     * The following configuration options can be set in the stencilset
     * definition:
     *
     *  - hideRootElements: Root elements (e.g. BPMNDiagram) won't be shown
     *  - rootElementsOnly: Only root elements will be visible
     *  - singleSelection: Radio buttons are used instead of checkboxes
     *  - positiveLogic: If true, the selected items will be stored, if false, the
     *                   deselected ones are stored
     *  - stencilsetsOnly: Only stencilsets are shown
     *  - stencilsOnly: Only stencils are shown (but also grouped after stencilset)
     */
    Ext.ux.propertyeditor.AttributeMapper = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {

        windowCreate: {
            height: 600,
            width: 630,
            minWidth: 630,
            minHeight: 600,
            resizable: true,
            cls: "y-attribute-mapper",
            bodyStyle: "background-color: #FFFFFF"
        },

        renderer: function(value) {
            var config = this.getConfig();
            var valueConf = this.evalConfig(value);
            value = this.evalValue(value);

            // filling in default values for manager options
            valueConf = Ext.apply(config.managerConf || {}, valueConf);

            if(config.positiveLogic === false) {
                if(valueConf.allElements) {
                    return Ext.ux.getI18N("attribute.mapper.config.all_elements");
                }

                if(valueConf.flowElements) {
                    return Ext.ux.getI18N("attribute.mapper.config.flow_elements");
                }

                if(valueConf.activities) {
                    return Ext.ux.getI18N("attribute.mapper.config.activities");
                }

                // As you can't tell, how many attributes are selected,
                // because you only know, how many are not selected,
                // a more generic value is shown.
                if(value.length > 0) {
                    return Ext.ux.getI18N('attribute.mapper.exclusion_active');
                }

                return Ext.ux.getI18N('attribute.mapper.excluion_inactive');
            }

            if(valueConf.selectName) {
                return Ext.ux.getI18N('attribute.mapper.config.name');
            }

            if(valueConf.selectDescription) {
                return Ext.ux.getI18N('attribute.mapper.config.description');
            }

            if(valueConf.allAttributes) {
                return Ext.ux.getI18N('attribute.mapper.config.all_attributes');
            }

            if(valueConf.ownAttributes) {
                return Ext.ux.getI18N('attribute.mapper.config.own_attributes');
            }

            var tpl = new Template(Ext.ux.getI18N("attribute.mapper.attributes_selected"));

            return tpl.evaluate({
                count: value.map(function(item) {
                    return item.title;
                }).uniq().length
            });
        },

        parseJSONObject: function(json, key) {
            try {
                return (json || "{}").evalJSON(true)[key];
            } catch(e) {
                // ignore that
                return null;
            }
        },

        /**
         * Parses the current value for an options part, that is used
         * if this panel is going to be a managed one.
         *
         * @param value current editor value
         * @returns {Object}
         */
        evalOptions: function(value) {
            return this.parseJSONObject(value, "options") || {};
        },

        /**
         * Parses the current value for a config part, that is used
         * if this panel is going to be managed one.
         *
         * @param value current editor value
         * @returns {Object}
         */
        evalConfig: function(value) {
            return this.parseJSONObject(value, "config") || {};
        },

        /**
         * Evaluates the string in value to a JSON Object and returns the
         * array under 'items'. If an error occurs, an empty array will
         * be returned.
         *
         * @param value String value
         * @returns Array of items.
         */
        evalValue: function(value) {
            return this.parseJSONObject(value, "items") || [];
        },

        /**
         * Returns the stencilset configuration for this editor
         * @returns
         */
        getConfig: function() {
            return this.property.config();
        },

        getSelection: function() {
            if(this.facade.getSelection) {
                return this.facade.getSelection();
            }

            return [];
        },

        /**
         * If the shape this property is defined on is a child of any shape
         * that can put restrictions on its children, this parent will be found
         * and the restrictions will be read.
         *
         * @returns {Object}
         */
        getRestrictions: function() {
            if(!this.restrictions) {
                var selection = this.getSelection();
                var shape = selection.first();
                var restrictions = {};
                var elementRestrictions = {
                    stencilsets: [],
                    stencils: [],
                    attributes: [],
                    managers: []
                };
                var stencilsetRestrictions = {
                    stencilsets: [],
                    stencils: [],
                    attributes: [],
                    managers: []
                };

                if(this.isRestrictedShape(shape)) {
                    var parent = shape.parent;
                    var parents = [];

                    while(parent) {
                        if(this.isRestrictiveShape(parent)) {
                            parents.push(parent);
                        }

                        parent = parent.parent;
                    }

                    if(parents.size() > 0) {
                        parents.each(function(p) {
                            this.createRestrictions(elementRestrictions, p, "Elements");
                            this.createRestrictions(stencilsetRestrictions, p, "Stencilsets");
                        }.bind(this));
                    }
                }

                restrictions.stencilsets = stencilsetRestrictions;
                restrictions.elements = elementRestrictions;

                this.restrictions = restrictions;
            }

            return this.restrictions;
        },

        /**
         * This method will fill the container parameter with restriction content.
         * If the {element} has the property {property}, restrictions are being set up.
         *
         * @param container Object, that will be filled with restrictions
         * @param element            Element to parse restrictions from
         * @param {String} property  Property, that should be read from the element
         */
        createRestrictions: function(container, element, property) {
            property = (property || "").toLowerCase();
            var positiveLogic = true;

            if(element.hasProperty(property)) {
                positiveLogic = element.getStencil().property("oryx-" + property).config().positiveLogic !== false;

                // fetch actual JSON property
                property = (element.getProperty(property) || "{}").evalJSON(true);

                (property.items || []).each(function(restriction) {
                    container.stencilsets.push(restriction.stencilset);
                    container.stencils.push(restriction.stencil ? restriction.stencilset + restriction.stencil : undefined);
                    container.attributes.push(restriction.id);
                    container.positiveLogic = positiveLogic;
                });

                container.managers.push(property.manager);

                container.stencilsets = container.stencilsets.compact().uniq();
                container.stencils = container.stencils.compact().uniq();
                container.attributes = container.attributes.compact().uniq();
                container.managers.compact().uniq();

                container.config = Ext.apply(container.config || {}, property.config);
            }
        },

        /**
         * Indicates whether a shape can be restricted by another one.
         *
         * @param shape
         * @returns {true} if restriction could be set, {false} otherwise.
         */
        isRestrictedShape: (function() {
            var shapes = [NAMESPACE + "TableElementsAttribute",
                          NAMESPACE + "ListElementsAttribute",
                          NAMESPACE + "TableElementsAttributeMulti",
                          NAMESPACE + "ListElementsAttributeMulti",
                          NAMESPACE + "TableElements",
                          NAMESPACE + "ListElements",
                          NAMESPACE + "DiagramAttribute",
                          NAMESPACE + "DiagramAttributeMulti"];

            return function(shape) {
                if(!shape) {
                    return false;
                }

                var id = shape.getStencil().id();

                return shapes.include(id);
            };
        }()),

        /**
         * Indicates whether a shape is able to put restrictions onto another one.
         *
         * @param shape
         * @returns {true} if the shape can restrict other shapes, {false} otherwise
         */
        isRestrictiveShape: (function() {
            var shapes = [NAMESPACE + "TableElements",
                          NAMESPACE + "ListElements",
                          NAMESPACE + "SectionPerDiagram",
                          NAMESPACE + "SectionPerDirectory"];

            return function(shape) {
                var id = shape.getStencil().id();

                return shapes.include(id);
            };
        }()),

        getEditor: function(currentValue) {
            this.oldItems = this.evalValue(currentValue);
            this.oldConfig = this.evalConfig(currentValue);

            var config = this.getConfig();
            var panel = this.getPanel();

            panel.getValue = this.getEditorValue.bind(panel, this);

            if(config.manager) {
                this.oldConfig = Ext.apply(config.managerConf || {}, this.oldConfig);

                panel = this.registerManager(config.manager, panel, this.oldConfig, this.evalOptions(currentValue));
            }

            if(panel) {
                panel.on("render", this.handleRender.bind(this));
            }

            this.positiveLogic = config.positiveLogic !== false;

            return panel;
        },

        registerManager: function(manager, panel, conf, options) {
            var base = Ext.ux.propertyeditor;

            if(base[manager]) {
                this.isManaged = true;

                var config = this.getConfig();

                panel = new base[manager]({
                    panel: panel,
                    buttonConf: conf || {},
                    options: options || {},
                    config: config.managerConfig || {}
                });

                this.manager = panel;

                return panel;
            }

            return null;
        },

        // scope Panel
        getEditorValue: function(self) {
            var value = [];

            if(this.items.length > 1) {
                // skip empty first panel (dummy)
                var start = 1;
                var end = this.items.indexOf(this.items.last());
                this.items.getRange(start, end).each(function(item) {
                    value = value.concat(item.getValue());
                });
            }

            return $H({
                items: value.concat(self.oldItems || []),
                exclude: !self.positiveLogic
            }).toJSON();
        },

        /**
         * After the initial editor window has been rendered, the available
         * stencilsets are being loaded and the first in the list is expanded,
         * to show its contents.
         *
         * @param panel Then panel, that was rendered.
         */
        handleRender: function(panel) {
            window.setTimeout(function() {
                var title = Ext.ux.getI18N("attribute.mapper.loading") +
                    " " +
                    Ext.ux.getI18N("attribute.mapper.stencilsets");

                panel.getEl().mask(title, "disabled");

                var config = this.getConfig();

                if(config.stencilsetsOnly) {
                    this.getStencilsets(function(stencilsets) {
                        var grid = this.getGrid();
                        var records = [];

                        stencilsets.each(function(stencilset) {
                            records.push(new Record({
                                checked: this.isActive(stencilset.namespace),
                                title: this.getTitle(stencilset),
                                stencilset: stencilset.namespace,
                                icon: stencilset.icon
                            }));
                        }.bind(this));

                        grid.getStore().add(records);

                        var p = new Ext.Panel({
                            title: Ext.ux.getI18N('attribute.mapper.stencilsets').capitalize(),
                            header: true,
                            items: [this.getSelectionHelpers(grid), grid],
                            collapsible: true,
                            collapsed: false,
                            layout: "anchor",
                            cls: "y-custom-groups",
                            border: false
                        });

                        p.getGrid = function() {
                            return grid;
                        };

                        p.getValue = this.getPanelValue.bind(this, p);
                        p.getContainer = this.createGetContainer(panel);

                        panel.add(p);
                        panel.doLayout();

                        p.expanded = true;
                        this.styleExpanded($(p.getEl().first(".x-panel-header", true)));
                        this.stylePanel(p);

                        panel.getEl().unmask();
                    }.bind(this));
                } else {
                    this.getStencilsets(function(stencilsets) {
                        var panels = this.createPanels(stencilsets);
                        var that = this;

                        // a panel is hot wired, if a shortcut is currently active
                        // thus no panel will be expanded, BUT all options have to be
                        // applied to the panel, when it is expanded for the first time.
                        // The touched attribute normally prevents options to be applied
                        // in order to ensure, that old selections are not overridden.
                        // We set the touchy attribute to the hot wired status in order to
                        // apply options only if the panel has been loaded in a hot wired mode.
                        var touchy = panel.hotWired();

                        panels.each(function(p) {
                            p.getContainer = that.createGetContainer(panel);
                            p.touched = touchy;
                        });

                        var p = panels.first();

                        if(p) {
                            p.on("render", function() {
                                panel.getEl().unmask();

                                if(!panel.hotWired()) {
                                    window.setTimeout(function() {
                                        p.expand(true);
                                        p.expanded = true;

                                        that.styleExpanded($(p.getEl().first(".x-panel-header", true)));
                                    }, 0);
                                }

                                that.stylePanel(p);
                            });

                            panel.add(p);

                            panels.slice(1).each(function(item){
                                item.on("render", that.stylePanel.bind(that));

                                panel.add(item);
                            });
                        } else {
                            panel.getEl().unmask();
                        }

                        panel.doLayout();
                    }.bind(this));
                }

                var container = this.createGetContainer(panel)();
                container.getScroll = function() {
                    return container.el.dom.firstChild.firstChild.scrollTop;
                };

                container.setScroll = function(scroll) {
                    container.el.dom.firstChild.firstChild.scrollTop = scroll;
                };

            }.bind(this), 0);
        },

        createGetContainer: function(panel) {
            if(this.isManaged) {
                return function() {
                    return panel.getManagedPanel();
                };
            }

            return function() {
                return panel;
            };
        },

        stylePanel: function(panel) {
            this.makeClickable(panel);
            this.removeExpander(panel);
        },

        removeExpander: function(panel) {
            panel.getEl().select(".x-tool-toggle").each(function(el) {
                el.hide();
            });
        },

        styleCollapsed: function(header) {
            header.setStyle({ backgroundPosition: "10px 5px" });
        },

        styleExpanded: function(header) {
            header.setStyle({ backgroundPosition: "10px -45px" });
        },

        /**
         * Enables the user to click anywhere on the panel to expand it, and
         * not only on the (now hidden) expander button.
         *
         * @param panel
         */
        makeClickable: function(panel) {
            var el = panel.getEl();
            var header = el.first(".x-panel-header");

            header.on("click", function() {
                var head = $(header.dom);

                if(panel.expanded) {
                    panel.collapse(true);
                    panel.expanded = false;

                    this.styleCollapsed(head);
                } else {
                    panel.expand(true);
                    panel.expanded = true;

                    this.styleExpanded(head);
                }
            }.bind(this));
        },

        /**
         * If a panel is expanded the stencilset belonging to it is loaded
         * from the server and the contained attributes/ stencils are shown.
         *
         * @param grid          The grid, that will keep the data
         * @param stencilset    Stencilset information
         * @param panel         Panel, that was expanded
         */
        handleGroupExpand: function(grid, stencilset, panel) {
            var title = Ext.ux.getI18N("attribute.mapper.loading") + " " + this.getTitle(stencilset);

            panel.scrollPosition = panel.getContainer().getScroll();
            panel.ownerCt.getEl().mask(title, "disabled");
            //panel.setTitle(panel.initialTitle);

            if(Ext.isOpera) {
                // as settings the title will already falsify the scroll position
                // in opera we update the scroll here once in order to avoid
                // flickering in the ui.
                panel.updateScroll();
            }

            var that = this;

            // to show the mask immediately the following actions are appended at the
            // end of the executino chain
            Signavio.Utils.defer(function() {
                if(grid.getStore().getCount() === 0) {
                    that.loadStencilData(grid.getStore(), stencilset.uri);
                    grid.getStore().sort("title");
                }
            });
        },

        /**
         * After a panel was expanded the first group of the contained grid
         * should be expanded (if there is a grouping view).
         *
         * @param grid
         * @param panel
         */
        handleAfterExpand: function(grid, panel) {
            if(grid.getStore().getCount() > 0 && !panel.alreadyExpanded) {
                var value = grid.getStore().getAt(0).get("group");
                var id = grid.getView().getGroupId(value);

                grid.getView().toggleGroup(id);

                panel.layoutPropertyCategories(grid);

                if(grid.extended) {
                    // the touched variable prevents the options to be applied
                    // when the editor is loaded for the first time and settings
                    // are about to be restored
                    if(panel.touched) {
                        $H(panel.options || {}).keys().each(function(key) {
                            grid[key].apply(this, panel.options[key]);
                        });
                    } else {
                        panel.touched = true;
                    }
                }

                panel.alreadyExpanded = true;
            }

            panel.adjustHeight(grid);
            panel.updateScroll();

            this.facade.raiseEvent(EVENTS.PANEL_EXPANDED, panel, grid);

            panel.ownerCt.getEl().unmask();
        },

        getExpanderButton: function(groupHeader) {
            // please lord forgive me...
            return groupHeader.firstChild.firstChild.firstChild.firstChild.firstChild.firstChild;
        },

        layoutElement: function(record, el) {
            var className = el.className;

            if(record.get("id") === GROUP_SPACER) {
                var padding = 10; // padding defined in y-attribute-inset
                var expanderButton = this.getExpanderButton(el);

                this.updateExpanderButton(expanderButton, record.get("collapsed"));

                var extEl = Ext.get(el);

                extEl.setWidth(extEl.getWidth() + padding);
            } else {
                if(record.get("collapsed") && !className.include("y-mapper-element-hidden")) {
                    className += " y-mapper-element-hidden";
                }
            }

            if(record.get("id") !== GROUP_SPACER && record.get("id") !== NO_SELECTION) {
                if(!className.include("y-attribute-inset")) {
                    className += " y-attribute-inset";
                }
            }

            if(className !== el.className) {
                el.className = className;
            }
        },

        showPropertyCategories: function() {
            var config = this.getConfig();

            return !config.stencilsetsOnly && !config.stencilsOnly;
        },

        layoutPropertyCategories: function(grid) {
            var that = this;

            if(this.showPropertyCategories()) {
                grid.doSuspended(function() {
                    var rows = grid.getView().getRows();
                    var gridBody = grid.getEl().dom.firstChild;
                    var gridDom = grid.getEl().dom;

                    gridDom.removeChild(gridBody);

                    rows.each(function(el, index) {
                        var record = grid.getStore().getAt(index);

                        if(record.get("propertyGroup") === EXPAND_GROUP) {
                            record.set("collapsed", false);
                        }

                        that.layoutElement(record, el);
                    }, true);

                    gridDom.appendChild(gridBody);
                });
            }
        },

        /**
         * Gathers data from a stencilset and loads it into the store.
         *
         * @param store     Store for the data
         * @param uri       URI of the stencilset
         * @param title     Title of the stencilset
         */
        loadStencilData: function(store, uri) {
            var loadData = function(json) {
                var records = this.createRecordsFromStencilSet(json, uri);

                store.add(records);

                var overflow = this.oldItems.select(function(item) {
                    return item.stencilset === json.namespace;
                });

                if(overflow.length > 0) {
                    // TODO: Inform about missing properties and also remove them from the oldItems list
                }
            }.bind(this);

            if(CACHE.Stencilsets[uri]) {
                loadData(CACHE.Stencilsets[uri]);

                return;
            }

            Signavio.Utils.Request.execute("/stencilsets" + uri, {
                async: true,
                success:function(json) {
                	// this event allows us to modify the content of
                	// the loaded stencilset before it is used
                	// this is necessary if the configured currency has
                	// to be injected into the property titles
                	// the first raiseEvent works with the Editor's mechanism
                	this.facade.raiseEvent({
                        type: EVENTS.STENCILSET_LOADED, 
                        arg: json
                    });
                	// the second raiseEvent has the right parameters for the Explorer's version
                    this.facade.raiseEvent(EVENTS.STENCILSET_LOADED, {
                        arg: json, 
                        callImmediatly: true
                    });
                    
                	loadData(json);

                    CACHE.Stencilsets[uri] = json;
                }.bind(this)
            });
        },

        /**
         * Checks whether a stencilset group is empty
         *
         * @param items
         * @returns {Boolean}
         */
        isEmpty: function(items) {
            return items.getCount() === 1 && !items.first().get("element").title;
        },

        /**
         * Creates the editor panel and adds a first dummy child
         * element to it. This is needed in order for Ext to get the
         * layouting right.
         *
         * @returns {Ext.Panel}
         */
        getPanel: function() {
            return new Ext.Panel({
                anchor: "100% 100%",
                border: false,
                layout: "anchor",
                autoScroll: true,
                cls: "y-content-wrap",
                hotWired: function() {
                    return this.isHotWired;
                },
                items: [this.getDummyPanel()]
            });
        },

        /**
         * Creates the grid, used by the panels to present the data.
         * This method also extends the regular grid with some utility
         * functions, that should ease development
         *
         * @returns {Ext.grid.EditorGridPanel}
         */
        getGrid: function() {
            var view = this.getView();
            var grid = new Ext.grid.GridPanel({
                store: this.getStore(),
                cm: this.getColumnModel(),
                view: view,
                border: false,
                trackMouseOver: false,
                hideHeaders: true,
                cls: "y-grouped-grid",
                stripeRows: true
            });

            if(this.showPropertyCategories()) {
                var that = this;

                view.on("refresh", function() {
                    var rows = grid.getView().getRows();

                    var gridDom = grid.getEl().dom;
                    var gridBody = gridDom.firstChild;

                    grid.scrollPosition = grid.getPanel().getContainer().getScroll();

                    gridDom.removeChild(gridBody);

                    rows.each(function(row, index) {
                        var record = grid.getStore().getAt(index);

                        if(record && row) {
                            that.layoutElement(record,row);
                        }
                    });

                    gridDom.appendChild(gridBody);
                    grid.updateScroll();
                });
            }

            grid.on("rowmousedown", this.handleRowMouseDown.bind(this));

            grid.getNoSelectionID = function() {
                return NO_SELECTION;
            };

            grid.updateScroll = function() {
                grid.getPanel().getContainer().setScroll(grid.scrollPosition || 0);
            };

            // Shortcut, that will retrieve the Ext Element of
            // the group with the provided name
            grid.getGroup = function(name) {
                var id = grid.getView().getGroupId(name);

                return Ext.get(id);
            };

            grid.isGroupCollapsed = function(group) {
                if(!(group instanceof Ext.Element)) {
                    group = grid.getGroup(group);
                }

                return !grid.getView().state[group.dom.id];
            };

            grid.groupIndex = function(group) {
                if(!(group instanceof Ext.Element)) {
                    group = grid.getGroup(group);
                }

                return $A(grid.getView().getGroups()).indexOf(group.dom);
            };

            // This function will perform actions while events on
            // the store are suspended. Thus manipulations on the data
            // won't result in update events. After these actions are
            // done, firing events is resumed and the datachanged Event
            // is fired once, to tell all containers to refresh their
            // views.
            grid.doSuspended = function(fn, blockUpdate) {
                fn = fn instanceof Function ? fn : Ext.emptyFn;

                var store = grid.getStore();

                if(!store.eventsSuspended) {
                    store.suspendEvents();

                    fn();   // do stuff

                    store.commitChanges(true);
                    store.resumeEvents();

                    if(!blockUpdate) {
                        store.fireEvent("datachanged");
                    }
                } else {
                    // if events are already suspended, just execute the function
                    fn();
                }
            };

            return grid;
        },

        /**
         * Creates the sorting function for the grids.
         * Sorting is done the following way:
         *
         * <ul>
         *  <li>Root elements go first (e.g. BPMN Diagrams)</li>
         *  <li>Groups should be sorted alphabetically</li>
         *  <li>The "no selection" items should go first in every list</li>
         *  <li>The list items are sorted alphabetically</li>
         * </ul>
         * @returns {Function}
         */
        getSortingFunction: function() {
            return function(f, direction) {
                if(f === "title") {
                    direction = direction || "ASC";

                    var st = this.fields.get(f).sortType;
                    var fn = function(r1, r2) {
//                        Ordering like in shape menu -> take ordering from stencilset file
//                        var t1 = r1.get(f);
//                        var t2 = r2.get(f);

                        var g1 = st(r1.get("position"));
                        var g2 = st(r2.get("position"));

                        var root1 = st(r1.get("root"));
                        var root2 = st(r2.get("root"));

                        var id1 = st(r1.get("id"));
                        var id2 = st(r2.get("id"));

                        var down = 1;
                        var up = -1;

                        return root1 && !root2 ? down :                 // Root elements on top
                               root2 && !root1 ? up :
                                   g1 < g2 ? down :                     // Sort groups and group values
                                   g1 > g2 ? up :
                                        id1 === NO_SELECTION ? down :   // No selection button should always
                                        id2 === NO_SELECTION ? up :     // be on top
                                           // t1 < t2 ? down :
                                           // t1 > t2 ? up :            // Then sort items in groups
                                                0;
                    };

                    this.data.sort(direction, fn);

                    if(this.snapshot && this.snapshot !== this.data) {
                        this.snapshot.sort(direction, fn);
                    }
                }
            };
        },

        /**
         * Creates a view, that is used by a grid in order to present its data.
         *
         * @returns {Ext.grid.GridView}
         */
        getView: function() {
            var config = this.getConfig();
            var view, tpl;

            var viewConfig = $H({
                emptyText: "<i>" + Ext.ux.getI18N("attribute.mapper.no_attributes") + "</i>"
            });

            if(config.stencilsetsOnly) {
                return new Ext.grid.GridView(viewConfig);
            }

            if(config.rootElementsOnly) {
                tpl = "<span class='y-mapper-title y-title-image' style='background-image:url({[values.rs.first().data.stencilsetIcon]}); padding-top: 0px'>" +
                        "{[values.rs.first().data.group]}" +
                        " " +
                        (config.singleSelection ? "" : "{[Ext.ux.propertyeditor.AttributeMapper.getGroupInfo(values)]}") +
                      "</span>";
            } else {
                if(config.stencilsOnly) {
                    tpl = "<span class='y-mapper-title'>" +
                            "{[values.rs.first().data.group]}" +
                            " " +
                            "{[Ext.ux.propertyeditor.AttributeMapper.getGroupInfo(values)]}" +
                          "</span>";
                } else {
                    if(config.singleSelection) {
                        tpl = "<span class='y-mapper-title y-title-image' style='background-image:url({[values.rs.first().data.icon]}); padding-top: 0px'>" +
                                "{[values.rs.first().data.group]}" +
                              "</span>";
                    } else {
                        tpl = "<span class='y-mapper-title y-title-image' style='background-image:url({[values.rs.first().data.icon]}); padding-top: 0px'>" +
                                "{[values.rs.first().data.group]}" +
                                " " +
                                "{[Ext.ux.propertyeditor.AttributeMapper.getGroupInfo(values)]}" +
                              "</span>";
                    }
                }
            }

            viewConfig = viewConfig.merge({
                startCollapsed: true,
                groupTextTpl: tpl
            });

            if(viewConfig.toObject) {
                viewConfig = viewConfig.toObject();
            }

            return new Ext.grid.GroupingView(viewConfig);
        },

        /**
         * Creates the ColumnModel, that will be used by the grids.
         *
         * @returns {Ext.grid.ColumnModel}
         */
        getColumnModel: function() {
            var config = this.getConfig();

            return new Ext.grid.ColumnModel([
                {
                    menuDisabled: true,
                    hideable: false,
                    sortable: false,
                    dataIndex: 'checked',
                    readonly: true,
                    width: 25,
                    fixed: true,
                    renderer: function(checked, meta, record) {
                        var type = "checkbox";
                        var group = "y-attribute-group-" + record.get("stencilset") + record.get("stencil");
                        var disabled = record.get("readonly") ? "disabled='disabled'" : "";
                        checked = checked ? "checked='checked'" : "";

                        if(config.singleSelection) {
                            type = "radio";
                        }

                        if(record.get("id") === GROUP_SPACER) {
                            return "<span class='y-attribute-expander y-attribute-mapper-group-expanded" +
                                    (record.get("collapsed") ? " y-attribute-mapper-group-collapsed" : "") +
                                    "'></span>";
                        }

                        return "<input type='" + type + "' "
                                + "name='" + group + "' "
                                + "class='y-mapper-switch' "
                                + checked + " "
                                + disabled + " />";
                    }
                },
                {
                    menuDisabled: true,
                    hideable: false,
                    sortable: false,
                    dataIndex: "title",
                    readonly: true,
                    fixed: true,
                    width: 500,
                    renderer: function(title, meta, record) {
                        if(record.get("id") === GROUP_SPACER) {
                            return "<span class='y-attribute-mapper-group-spacer'>" + record.get("title") + "</span>";
                        }

                        if(config.stencilsOnly || config.stencilsetsOnly) {
                            title = "<span style='background-image:url(" + record.get("icon") + ")' class='y-mapper-title y-title-image'>" + title + "</span>";
                        }

                        if(record.get("list")) {
                            title = title + " <span class='y-mapper-tip'>(" + Ext.ux.getI18N('attribute.mapper.list') + ")</span>";
                        }

                        return title;
                    }
                },
                {
                    hidden: true,
                    dataIndex: 'group'
                }
            ]);
        },

        /**
         * Creates a store, that will be used by the grids.
         *
         * @returns {Ext.data.GroupingStore}
         */
        getStore: function() {
            var store = new Ext.data.GroupingStore({
                reader: this.getReader(),
                fields: this.getFields(),
                data: [],
                groupField: "group",
                sortInfo: {
                    field: "title",
                    direction: "ASC"
                }
            });

            /**
             * @Override
             *
             * Custom sorting function for the store, so that root elements
             * are sorted to the top, then items are grouped and in these
             * groups regular sorting is applied.
             */
            store.sortData = this.getSortingFunction();
            /**
             * @Override
             *
             * Custom afterEdit function, that does not fire
             * the update event, if suspendEvents() has been
             * called beforehand on the store.
             *
             * @param {Object} record
             */
            store.afterEdit = function(record){
                if(this.modified.indexOf(record) === -1){
                    this.modified.push(record);
                }

                if(!this.eventsSuspended) {
                    this.fireEvent("update", this, record, Ext.data.Record.EDIT);
                }
            };
            /**
             * @Override
             *
             * Custom commit changes function, that commits records
             * silently to prevent the update event to be fired.
             *
             * To update views, that are using the store, fire the
             * 'datachanged' event.
             */
            store.commitChanges = function(silent){
                var m = this.modified.slice(0), i, len;
                this.modified = [];
                for(i = 0, len = m.length; i < len; i = i + 1){
                    m[i].commit(silent === true);
                }
            };

            return store;
        },

        /**
         * This function can be used to define a "default" stencilset.
         * This stencilset will appear as the first item in the list
         * of stencilset. It is identified by its namespace.
         *
         * @returns {String}
         */
        getDefaultStencilSet: function() {
            return "http://b3mn.org/stencilset/bpmn2.0#";
        },

        /**
         * Whenever the collapsed panels were created there was a layouting error
         * when one was expanded. Ext could not manage to resize the first Panel to
         * a width, so that no vertical scrollbar was shown.
         *
         * This is why an empty Panel has to be inserted as the first element in order
         * to avoid this behaviour.
         */
        getDummyPanel: function() {
            return new Ext.Panel({
                border: false,
                collapsed: true,
                collapsible: true,
                width: 200
            });
        },

        /**
         * This method will create a panel for each stencilset. The panels
         * are set up to be extendable and will handle the actions needed in
         * order to present their corresponding data correctly themselves.
         *
         * @param stencilsets List of stencilsets availlable.
         *
         * @returns {Array}
         */
        createPanels: function(stencilsets) {
            var panels = [];

            stencilsets.each(function(stencilset) {
                var grid = this.getGrid();
                var config = this.getConfig();

                grid.getView().on("refresh", function() {
                    if(!config.singleSelection) {
                        this.addSelectionHelpersToGroups(grid);
                    }
                }.bind(this));

                var selectionHelpers = this.getSelectionHelpers(grid);

                var panel = new Ext.Panel({
                    title: this.getTitle(stencilset),
                    initialTitle: this.getTitle(stencilset),
                    collapsible: true,
                    collapsed: true,
                    items: [selectionHelpers, grid],
                    cls: "y-custom-groups",
                    border: false,
                    listeners: {
                        beforeexpand: this.handleGroupExpand.bind(this, grid, stencilset),
                        expand: this.handleAfterExpand.bind(this, grid),
                        collapse: this.handleCollapse.bind(this, stencilset)
                    }
                });

                var that = this;

                // to get the layout correctly, we need to
                // recalculate the height of the grid panel after
                // a group is expanded.
                // As Ext lacks an event for that, we just extend the original
                // a little bit.
                grid.getView().toggleGroup = function(id) {
                    grid.scrollPosition = panel.getContainer().getScroll();

                    Ext.grid.GroupingView.prototype.toggleGroup.apply(grid.getView(), arguments);

                    var group = Ext.get(id);
                    var index = grid.groupIndex(group);
                    var expanded = !grid.isGroupCollapsed(group);
                    var selectionHelpers = (grid.groupHelpers || [])[index];
                    var head = group.child(".x-grid-group-hd");

                    if(selectionHelpers) {
                        if(expanded) {
                            selectionHelpers.show();
                            head.addClass("y-selection-helpers-hide-border");
                        } else {
                            selectionHelpers.hide();
                            head.removeClass("y-selection-helpers-hide-border");
                        }
                    }

                    that.adjustGridHeight(grid);
                };

                grid.getPanel = function() {
                    return panel;
                };

                if(this.isManaged) {
                    panel.options = panel.options || this.manager.getOptions() || {};
                }

                panel.getValue = this.getPanelValue.bind(this, panel);
                panel.getGrid = function() {
                    return grid;
                };

                panel.getSelectionHelpers = function() {
                    return {
                        selectionHelpers: selectionHelpers,
                        addToGroups: this.addSelectionHelpersToGroups.bind(this)
                    };
                }.bind(this);

                panel.updateScroll = function() {
                    panel.getContainer().setScroll(panel.scrollPosition || 0);
                };

                panel.adjustHeight = this.adjustGridHeight.bind(this);
                panel.layoutPropertyCategories = this.layoutPropertyCategories.bind(this);

                panels.push(panel);
            }.bind(this));

            return panels;
        },

        adjustGridHeight: function(grid) {
            var gridBody = Ext.get(grid.getGridEl().child(".x-grid3-body", true));
            var padding = 40; // just for safety reasons

            grid.setHeight(gridBody.getHeight() + padding);
            grid.updateScroll();
        },

        /**
         * Creates the buttons for the selection helpers. If {all} is set to true,
         * this method will create the "Select all" button, otherwise an "Select None"
         * button is created.
         *
         * @param grid  The grid, these buttons should operate on
         * @param all   Indicator, whether an "Select All" or "Select None" button should be created
         * @returns {Ext.Panel}
         */
        getSelectionButton: function(grid, all, checkFn) {
            var checkbox = "<input type='checkbox' " + (all ? "checked='checked'" : "") + " readonly='readonly' />";
            checkFn = checkFn instanceof Function ? checkFn : Ext.emptyFn;

            var enabled = true;

            var button = new Ext.Panel({
                border: false,
                cls: "y-attribute-mapper-helper-button",
                items: [
                    new Ext.Button({
                        text: all ? Ext.ux.getI18N('glossary.mapper.select_all') : Ext.ux.getI18N('glossary.mapper.select_none'),
                        handler: function() {
                            if(grid.readonly) {
                                return;
                            }

                            grid.doSuspended(function() {
                                var store = grid.getStore();

                                store.each(function(record) {
                                    if(checkFn(record) !== false) {
                                        record.set("checked", all);
                                    }
                                });
                            });

                            if(all) {
                                var record = grid.getStore().getAt(0);
                                var stencilset = record.get("stencilset");

                                this.oldItems = this.oldItems.select(function(value) {
                                    if(value.stencilset === stencilset) {
                                        return false;
                                    }

                                    return true;
                                });
                            }
                        }.bind(this),
                        template: new Ext.Template("<span>" + checkbox + " <a href='#'>{0}</a></span>"),
                        onRender: function() {
                            this.el = Ext.get(this.template.overwrite(this.container.dom, [this.text]));
                            this.el.on("click", function(e){
                                if(enabled) {
                                    this.handler.apply(this, arguments);
                                }

                                e.stopEvent();
                                return false;
                            }.bind(this));
                        }
                    })
                ]
            });

            button.disable = function() {
                enabled = false;

                button.getEl().setStyle({
                    opacity: 0.5
                });
            };

            button.enable = function() {
                enabled = true;

                button.getEl().setStyle({
                    opacity: 1
                });
            };

            return button;
        },

        /**
         * Selection helpers are two buttons, that enable the user
         * to either select all contents of a grid or nothing.
         *
         * @param grid The grid, to operate on.
         * @returns
         */
        getSelectionHelpers: function(grid) {
            var config = this.getConfig();

            if(config.singleSelection || config.rootElementsOnly) {
                return this.getDummyPanel();
            }

            var selectFn = function(record) {
                return record.get("id") !== GROUP_SPACER;
            };

            var selectAll = this.getSelectionButton(grid, true, selectFn);
            var selectNone = this.getSelectionButton(grid, false, selectFn);

            var helpers = new Ext.Panel({
                items: [selectAll, selectNone],
                collapsible: false,
                anchor: "-75",
                border: false,
                layout: "column",
                cls: "y-selection-helpers"
            });

            helpers.disable = function() {
                selectAll.disable();
                selectNone.disable();
            };

            helpers.enable = function() {
                selectAll.enable();
                selectNone.enable();
            };

            return helpers;
        },

        getGroups: function(grid) {
            var groups = [];

            grid.getStore().each(function(record) {
                if(!groups.include(record.get("group"))) {
                    groups.push(record.get("group"));
                }
            });

            return groups;
        },

        addSelectionHelpersToGroup: function(grid, group) {
            if(!grid.groupHelpers) {
                grid.groupHelpers = [];
            }

            var groupEl = grid.getGroup(group);
            var index = grid.groupIndex(groupEl);

            var selectFn = function(record) {
                return record.get("group") === group && record.get("id") !== GROUP_SPACER;
            };

            var selectAll = this.getSelectionButton(grid, true, selectFn);
            var selectNone = this.getSelectionButton(grid, false, selectFn);

            var helpers = new Ext.Panel({
                items: [selectAll, selectNone],
                collapsible: false,
                anchor: "-75",
                border: false,
                layout: "column",
                cls: "y-selection-helpers y-selection-helpers-inline" + (Ext.isChrome ? " y-selection-helpers-chrome" : "")
            });

            var head = groupEl.child(".x-grid-group-hd");

            helpers.render(head.dom.firstChild);

            $(helpers.getEl().dom).observe("mousedown", function(e) {
                Event.stop(e);
            });

            if(grid.isGroupCollapsed(groupEl)) {
                helpers.hide();
            } else {
                head.addClass("y-selection-helpers-hide-border");
            }

            grid.groupHelpers[index] = helpers;
        },

        addSelectionHelpersToGroups: function(grid) {
            if(grid.readonly) {
                grid.groupHelpers = [];
                return;
            }

            this.getGroups(grid).each(this.addSelectionHelpersToGroup.bind(this, grid));
        },

        /**
         * If a panel is collapes a small indicator will show how many elements
         * are selected inside of it.
         *
         * @param stencilset    Stencilset information of this panel
         * @param panel
         */
        handleCollapse: function(stencilset, panel) {
            if(!this.evaluateOptions(panel)) {
                // Only show info in header, if options do not render
                // the information useless.
                panel.setTitle(panel.initialTitle);
                return;
            }

            var value = this.getPanelValue(panel);

            if(value.length > 0) {
                panel.setTitle(panel.initialTitle + " " + this.getTitleInfo(value.length));
            } else {
                var deselectedProperties = 0;

                this.oldItems.each(function(item) {
                    if(item.stencilset === stencilset.namespace) {
                        ++deselectedProperties;
                    }
                });

                if(deselectedProperties > 0) {
                    panel.setTitle(panel.initialTitle + " " + this.getTitleInfo(deselectedProperties));
                } else {
                    panel.setTitle(panel.initialTitle);
                }
            }
        },

        /**
         * If certain options are set on a panel, no info message
         * should be displayed in its header. This method is used
         * to evaluate the options of a panel.
         *
         * @param panel
         * @returns {Boolean}
         */
        evaluateOptions: function(panel) {
            var options = panel.options || {};

            if(options.selectAll instanceof Array) {
                return false;
            }

            if(options.selectOwn instanceof Array) {
                return false;
            }

            return true;
        },

        /**
         * The title info shows how many children of a
         * panel are selected or deselected depending on the
         * type of logic this mapper operates on.
         *
         * @param count
         * @returns {String}
         */
        getTitleInfo: function(count) {
            var selectionInfo = new Template(Ext.ux.getI18N("attribute.mapper.deselected"));

            if(this.positiveLogic) {
                selectionInfo = new Template(Ext.ux.getI18N("attribute.mapper.selected"));
            }

            return "<span class='y-attribute-mapper-panel-info'> - " + selectionInfo.evaluate({ count: count }) + "</span>";
        },

        getPanelValue: function(panel) {
            var grid = panel.getGrid();

            return this.getGridValue(grid);
        },

        /**
         * Gathers the information of a grid and stores it as a JSON object
         * in the result array.
         *
         * @param grid      Grid, from which the data should be gathered
         * @returns {Array}
         */
        getGridValue: function(grid) {
            var store = grid.getStore();
            var records = store.query("checked", this.positiveLogic);
            var values = [];

            records.each(function(record) {
                if(record.get("id") === NO_SELECTION) {
                    return;
                }

                values.push({
                    stencilset: record.get("stencilset"),
                    stencil: record.get("stencil"),
                    id: record.get("id"),
                    title: record.get("title")
                });
            });

            return values;
        },

        /**
         * Parses an element for its title in the correct language.
         * Assuming, that there are "title_languagecode" properties.
         *
         * @param el
         * @returns
         */
        getTitle: function(el) {
            return this.getI18Nattribute(el, "title");
        },

        getGroup: function(stencil) {
            return this.getI18Nattribute(stencil, "groups").first() || Ext.ux.getI18N("attribute.mapper.untitled_group");
        },

        getI18Nattribute: (function() {
            var language = Ext.ux.getLang();

            return function(stencil, attr) {
                return stencil[attr + "_" + language] || stencil[attr];
            };
        }()),

        handleRowMouseDown: function(grid, index) {
            if(!this.handleClick(grid, index)) {
                return false;
            }
        },

        /**
         * Will set the checked value of the correct record in the store
         * and also update the checkbox.
         *
         * @param store
         * @param index
         * @returns {Boolean}
         */
        handleClick: function(grid, index) {
            var store = grid.getStore();
            var record = store.getAt(index);

            if(record.get("id") === GROUP_SPACER) {
                this.handlePropertyGroupClick(grid, index);

                return false;
            }

            if(record.get("readonly")) {
                return false;
            }

            var status = record.get("checked");
            var config = this.getConfig();
            var id = record.get("id");

            grid.doSuspended(function() {
                if(config.singleSelection) {
                    if(!status) {
                        record.set("checked", true);

                        var records = store.query("group", record.get("group"));

                        records.each(function(r) {
                            if(r.get("id") !== id) {
                                r.set("checked", false);
                            }
                        });
                    }
                } else {
                    record.set("checked", !status);
                }

                if(grid.getView() instanceof Ext.grid.GroupingView && !config.singleSelection) {
                    this.updateGroupHeader(grid, record.get("group"));
                }
            }.bind(this));

            return false;
        },

        handlePropertyGroupClick: function(grid, index) {
            var that = this;

            grid.doSuspended(function() {
                var pos = 0;
                var indices = [];
                var store = grid.getStore();
                var record = store.getAt(index);
                var group = record.get("title");
                var rows = grid.getView().getRows();
                var stencilGroup = record.get("group");
                var stencilset = record.get("stencilset");

                store.each(function(r) {
                    if(r.get("propertyGroup") === group
                        && r.get("group") === stencilGroup
                        && r.get("stencilset") === stencilset) {

                        indices.push(pos);
                        r.set("collapsed", !r.get("collapsed"));
                    }

                    pos++;
                });

                var collapsed = store.getAt(indices.first()).get("collapsed");
                var groupHeader = rows[indices.first()];

                var expander = that.getExpanderButton(groupHeader);

                that.updateExpanderButton(expander, collapsed);

                indices = indices.slice(1);

                rows = rows.slice(indices.first() - 1, indices.last());

                rows.each(function(row) {
                    if(collapsed) {
                        row.style.visibility = "hidden";
                        row.style.display = "none";
                    } else {
                        row.style.visibility = "visible";
                        row.style.display = "block";
                    }
                });
            });

            this.adjustGridHeight(grid);
        },

        updateExpanderButton: function(expander, collapsed) {
            var className = expander.className;

            if(!collapsed && className.include("y-attribute-mapper-group-collapsed")) {
                className = className.sub("y-attribute-mapper-group-collapsed", "");
            } else if(collapsed && !className.include("y-attribute-mapper-group-collapsed")) {
                className += "y-attribute-mapper-group-collapsed";
            }

            if(className !== expander.className) {
                expander.className = className;
            }
        },

        updateGroupHeader: function(grid, group) {
            var el = grid.getGroup(group);
            var headerContainer = el.child(".x-grid-group-hd");
            var title = $(headerContainer.dom.firstChild);
            var selectedCount = this.selectedCount(grid.getStore(), group);

            if(selectedCount) {
                title.update(group
                    + " "
                    + "<span class='y-attribute-group-info'>("
                        + (new Template(Ext.ux.getI18N('attribute.mapper.selected'))).evaluate({
                              count: selectedCount
                          })
                    + ")</span>");
            } else {
                title.update(group);
            }

            var config = this.getConfig();

            this.updateParentTitle(grid, group);

            if(!config.singleSelection) {
                this.addSelectionHelpersToGroup(grid, group);
            }
        },

        updateParentTitle: function(grid, group) {
            var panel = grid.ownerCt;
            var selectedCount = this.getPanelValue(panel).length;

            if(selectedCount) {
                panel.setTitle(panel.initialTitle + " " + this.getTitleInfo(selectedCount));
            } else {
                panel.setTitle(panel.initialTitle);
            }
        },

        selectedCount: function(store, group) {
            var selectedCount = 0;

            store.each(function(record) {
                if(record.get("group") === group && record.get("checked")) {
                    selectedCount++;
                }
            });

            return selectedCount;
        },

        /**
         * Selection function used to determine, if a stencil should
         * go into a result set or not.
         *
         * @param stencil
         * @returns {Boolean}
         */
        isAllowedStencil: function(stencilset, stencil) {
            var config = this.getConfig();
            var restrictions = this.getRestrictions().elements;
            var allowed = stencil.type === "node";

            if(config.rootElementsOnly) {
                allowed = allowed && !!stencil.mayBeRoot;
            }

            if(config.hideRootElements) {
                allowed = allowed && !stencil.mayBeRoot;
            }

            if(!config.rootElementsOnly || config.hideRootElements) {
                allowed = allowed && (config.enforceRootElements || !stencil.hide);
            }

            if(restrictions.stencils.length > 0) {
                if(restrictions.positiveLogic) {
                    allowed = allowed && restrictions.stencils.include(stencilset + stencil.id);
                } else {
                    allowed = allowed && !restrictions.stencils.include(stencilset + stencil.id); // NOT
                }
            }

            restrictions.managers.each(function(manager) {
                allowed = allowed && Ext.ux.propertyeditor.AbstractConfigurationPanel.isAllowedStencil(manager, stencilset, stencil, restrictions.config);
            });

            return allowed;
        },

        /**
         * Parses a stencil for all properties needed to create a new record
         * for the store.
         *
         * @param stencilset    Complete stencilset.
         * @param title         Title of the stencilset
         * @param uri           URI of the stencilset
         * @returns {Array}
         */
        createRecordsFromStencilSet: function(stencilset, uri) {
            var records = [];
            var config = this.getConfig();
            var addedStencils = [];

            this.sortStencils(stencilset.stencils
                      .select(this.isAllowedStencil.bind(this, stencilset.namespace)))
                      .each(function(stencil) {

                var newRecords = [];

                var stencilIdentfier = stencilset.namespace + "#" + this.getGroup(stencil) + "#" + this.getTitle(stencil);

                if(addedStencils.include(stencilIdentfier)) {
                    return;
                }

                addedStencils.push(stencilIdentfier);

                if(config.stencilsOnly) {
                    newRecords = this.createRecordFromStencil(stencil, stencilset.namespace, this.parseBaseURI(uri));
                } else {
                    newRecords = this.createRecordsFromProperties(stencil, stencilset, this.parseBaseURI(uri));
                }

                records = records.concat(newRecords);
            }.bind(this));

            return records;
        },

        sortStencils: function(stencils) {
            var knownGroups = [];
            var groupMap = {};
            var sortedStencils = [];

            stencils.each(function(stencil) {
                var group = stencil.groups.first();

                if(!knownGroups.include(group)) {
                    knownGroups.push(group);
                    groupMap[group] = [stencil];
                } else {
                    groupMap[group].push(stencil);
                }
            });

            knownGroups.each(function(group) {
                sortedStencils = sortedStencils.concat(groupMap[group]);
            });

            return sortedStencils;
        },

        /**
         * Selection function used to determine, if a property should
         * go into a result set or not.
         *
         * @param property
         * @returns {Boolean}
         */
        isAllowedProperty: function(property) {
            var restrictions = this.getRestrictions().elements;

            var allowed = true;

            if(property.visible === false) {
                allowed = false;
            }

            if(restrictions.attributes.length > 0) {
                allowed = allowed && restrictions.attributes.include(property.id);
            }

            return allowed && this.validProperty(property);
        },

        validProperty: function() {
            return true;
        },

        parseBaseURI: function(uri) {
            return "/stencilsets" + uri.substr(0, uri.lastIndexOf("/"));
        },

        /**
         * Creates a record for the store directly from a stencil and not
         * from a property.
         *
         * @param stencil
         * @param stencilset
         * @param baseURI
         * @returns {Record}
         */
        createRecordFromStencil: function(stencil, stencilset, baseURI) {
            return new Record({
                checked : this.isActive(stencilset, stencil, null),
                icon: baseURI + "/icons/" + stencil.icon,
                stencilset: stencilset,
                title: this.getTitle(stencil),
                group: this.getGroup(stencil),
                stencil: stencil.id,
                roles: stencil.roles,
                stencilsetIcon: CACHE.StencilsetIcons[stencilset.namespace],
                root: stencil.mayBeRoot
            });
        },

        createRecordsFromProperties: function(stencil, stencilset, baseURI) {
            var allProperties = this.mergeProperties(stencil, stencilset.propertyPackages, stencilset.namespace);
            var records = [];
            var config = this.getConfig();

            if(config.singleSelection) {
                // If single selection is active a dummy record is
                // pushed first, to generate the "none" button on
                // top of each group

                if(allProperties.size() > 0) {
                    records.push(new Record({
                        checked: this.initialNoneSelection(stencil.id),
                        id: NO_SELECTION,
                        title: "<i style='color:#717171'>" + Ext.ux.getI18N("attribute.mapper.no_selection") + "</i>",
                        group: this.getTitle(stencil),
                        root: stencil.mayBeRoot,
                        icon: baseURI + "/icons/" + stencil.icon,
                        stencilset: stencilset.namespace,
                        stencil: stencil.id,
                        stencilsetIcon: CACHE.StencilsetIcons[stencilset.namespace],
                        position: stencilset.stencils.indexOf(stencil)
                    }));
                }
            }

            var currentGroup = "";

            allProperties
                .select(this.isAllowedProperty.bind(this))
                .sort(this.sortProperties.bind(this))
                .each(function(property) {

                var group = this.getPropertyCategory(property);

                if(currentGroup !== group) {
                    currentGroup = group;

                    records.push(new Record({
                        id: GROUP_SPACER,
                        title: group,
                        group: this.getTitle(stencil),
                        propertyGroup: group,
                        collapsed: true,
                        root: stencil.mayBeRoot,
                        position: stencilset.stencils.indexOf(stencil),
                        stencil: stencil.id,
                        stencilset: stencilset.namespace,
                        stencilsetIcon: CACHE.StencilsetIcons[stencilset.namespace],
                        icon: baseURI + "/icons/" + stencil.icon
                    }));
                }

                records.push(new Record({
                    checked: this.isActive(stencilset.namespace, stencil, property),
                    icon: baseURI + "/icons/" + stencil.icon,
                    id: property.id,
                    stencilset: stencilset.namespace,
                    title: this.getTitle(property),
                    group: this.getTitle(stencil),
                    stencil: stencil.id,
                    propertyGroup: group,
                    collapsed: true,
                    root: stencil.mayBeRoot,
                    position: stencilset.stencils.indexOf(stencil),
                    meta: property.meta === true,
                    list: property.list === true,
                    stencilsetIcon: CACHE.StencilsetIcons[stencilset.namespace]
                }));
            }.bind(this));

            return records;
        },

        getPropertyCategory: function(property) {
            if(property.popular || this.parseRefToView(property)) {
                return Ext.ux.getI18N("attribute.mapper.config.main_properties");
            }

            if(property.meta) {
                return Ext.ux.getI18N("attribute.mapper.config.meta_properties");
            }

            return Ext.ux.getI18N("attribute.mapper.config.more_properties");
        },

        sortProperties: function(a, b) {
            var refA = this.parseRefToView(a);
            var refB = this.parseRefToView(b);

            return a.meta && !b.meta ? -1 :                                 // Custom Attributes
                   !a.meta && b.meta ? 1 :
                       a.popular && !b.popular ? -1 :                       // Main Attributes
                       !a.popular && b.popular ? 1 :
                            refA && !refB ? -1 :
                            !refA && refB ? 1 :
                                this.getTitle(a) < this.getTitle(b) ? -1 :  // Other Attributes
                                this.getTitle(a) > this.getTitle(b) ? 1 :
                                    0;
        },

        parseRefToView: function(prop) {
            if(prop.refToView) {
                return true;
            }

            if((prop.type || "").toLowerCase() === Signavio.Config.TYPE_CHOICE) {
                var flag = false;

                prop.items.each(function(item) {
                    if(item.refToView) {
                        flag = true;

                        throw $break;
                    }
                });

                return flag;
            }

            return false;
        },

        /**
         * This method checks for each stencil if an
         * attribute is already selected.
         *
         * @param stencil
         * @returns {Boolean}
         */
        initialNoneSelection: function(stencil) {
            var active = true;

            this.oldItems.each(function(item) {
                if(item.stencil === stencil) {
                    active = false;

                    throw $break;
                }
            });

            return active;
        },

        /**
         * Checks whether an entry should be initially selected in
         * the grid or not.
         *
         * @param stencilset
         * @param stencil
         * @param property
         * @returns {Boolean}
         */
        isActive: function(stencilset, stencil, property) {
            var active = !this.positiveLogic;
            var found = null;

            (this.oldItems || []).each(function(value, index) {
                if(value.stencilset === stencilset
                    && (!stencil || value.stencil === stencil.id)
                    && (!property || value.id === property.id)) {

                    active = !active;
                    found = index;
                    throw $break;
                }
            });

            if((this.positiveLogic && active) || (!this.positiveLogic && !active)) {
                this.oldItems[found] = undefined;
                this.oldItems = this.oldItems.compact();
            }

            return active;
        },

        /**
         * Merges all properties of a stencil into one list. This list then
         * also contains all properties, that were referenced by a property
         * package.
         *
         * @param stencil
         * @param propertyPackages
         * @returns {Array}
         */
        mergeProperties: function(stencil, propertyPackages, stencilset) {
            var me = this;
            var readProperties = [];
            var properties = [];

            (stencil.properties || []).each(function(property) {
                if (!me.isHiddenProperty(property)) {
                    readProperties.push(property.id);
                    properties.push(property);
                }
            });

            (stencil.propertyPackages || []).each(function(propertyPackage) {
                var packedProperties = propertyPackages.map(function(p) {
                    if(p.name === propertyPackage) {
                        return p.properties;
                    }
                }).compact();

                // flattens the property list
                packedProperties.each(function(p) {
                    p.each(function(prop) {
                        if(!readProperties.include(prop.id) && !me.isHiddenProperty(prop)) {
                            properties.push(prop);
                        }
                    });
                });
            });

            ((this.metaAttributes[stencilset] || [])[stencil.id] || []).each(function(meta) {
                if (!me.isHiddenProperty(meta)) {
                    properties.push(meta);
                }
            });

            return properties;
        },

        
        /**
         * Checks for properties to be hidden in Portal
         * 
         * Hidden property are:
         * <ul>
         *  <li>Black lists: Signavio.Portal.Config.HIDDEN_PROPERTIES, Signavio.Portal.Config.HIDDEN_PROPERTY_TYPES</li>
         *  <li>properties having a refToView defined</li>
         *  <li>properties/stencils having a flag hideInPortal set to true</li>
         * </ul>
         *
         * @return {Boolean} Return
         */
        isHiddenProperty: function(prop) {
            if (!prop) {
                return false;
            }

            var id = (prop.id?prop.id.toLowerCase():undefined), type = (prop.type?prop.type.toLowerCase():undefined);

            return Signavio.Config.HIDDEN_PROPERTIES.include(id) 
                || Signavio.Config.HIDDEN_PROPERTY_TYPES.include(type);
                //|| prop.hideInPortal
                //|| prop.refToView;
        },

        /**
         * Selection function to determine, if a stencilset is allowed in
         * a result set or not.
         *
         * @param stencilset
         * @returns {Boolean}
         */
        isAllowedStencilSet: function(stencilset) {
            var restrictions = this.getRestrictions().stencilsets;
            var allowed = !BLACKLIST.include(stencilset.namespace);

            if(restrictions.stencilsets.length > 0) {
                if(restrictions.positiveLogic) {
                    return allowed && restrictions.stencilsets.include(stencilset.namespace);
                }

                return allowed && !restrictions.stencilsets.include(stencilset.namespace);  // NOT
            }

            return allowed;
        },

        /**
         * Retrieve all stencilsets, that are allowed for a user. The finish
         * callback will then be called, with all panels, that have been
         * created.
         *
         * @param callback
         */
        getStencilsets: function(callback) {
            if(CACHE.StencilsetPreview.length > 0) {
                this.getMetaAttributes();

                callback(CACHE.StencilsetPreview.select(this.isAllowedStencilSet.bind(this)));

                this.facade.raiseEvent(EVENTS.STENCILSETS_LOADED);

                return;
            }

            Signavio.Utils.Request.execute(Signavio.Config.STENCILSET_URI, {
                async: true,
                success: function(response) {
                    (response || []).each(function(stencilset) {
                        CACHE.StencilsetPreview.push({
                            title: this.getTitle(stencilset),
                            uri: stencilset.uri,
                            namespace: stencilset.namespace,
                            icon: Signavio.Config.IMAGE_PATH + stencilset.icon_url
                        });

                        CACHE.StencilsetIcons[stencilset.namespace] = Signavio.Config.IMAGE_PATH + stencilset.icon_url;
                    }.bind(this));

                    CACHE.StencilsetPreview.sort(function(a, b) {
                        if(a.namespace === this.getDefaultStencilSet()) {
                            return -1;
                        }

                        if(b.namespace === this.getDefaultStencilSet()) {
                            return 1;
                        }

                        return a.title < b.title ? -1 :
                               a.title > b.title ? 1 :
                                   0;
                    }.bind(this));

                    this.getStencilsets(callback);
                }.bind(this)
            });
        },

        /**
         * Retrieves attributes, that were defined by the user
         * and adds them to list of known meta attribuets,
         * so that they can be used, if the mapper is shown.
         */
        getMetaAttributes: function() {
            var meta = {};

            if(CACHE.MetaAttributes) {
                this.metaAttributes = CACHE.MetaAttributes;

                return;
            }

            Signavio.Utils.Request.execute("/p/meta", {
                success: function(response) {
                    (response || []).each(function(item) {
                        var bindings = item.rep.stencilsetBindings;

                        bindings.each(function(binding) {
                            if(!meta[binding.namespace]) {
                                meta[binding.namespace] = {};
                            }

                            if(!meta[binding.namespace][binding.stencil]) {
                                meta[binding.namespace][binding.stencil] = [];
                            }

                            meta[binding.namespace][binding.stencil].push({
                                id: item.rep.id,
                                title: item.rep.name,
                                list: item.rep.isList,
                                meta: true,
                                type: item.rep.type,
                                lineWrap: item.rep.lineWrap
                            });
                        });
                    });

                    CACHE.MetaAttributes = meta;
                }
            });

            this.metaAttributes = meta;
        },

        getReader: function() {
            return new Ext.data.ArrayReader({}, this.getFields());
        },

        getFields: function() {
            return [
                { name: "checked" },
                { name: "icon" },
                { name: "id" },
                { name: "title" },
                { name: "group" },
                { name: "stencilset" },
                { name: "stencil" },
                { name: "root" },
                { name: "readonly" },
                { name: "meta" },
                { name: "list" },
                { name: "position" },
                { name: "roles" },
                { name: "propertyGroup" },
                { name: "collapsed" },
                { name: "stencilsetIcon" }
            ];
        }

    });

    Ext.ux.propertyeditor.AttributeMapper.getGroupInfo = function(values) {
        var selectedCount = 0;

        values.rs.each(function(record) {
            if(record.get("group") === values.group && record.get("checked")) {
                selectedCount++;
            }
        });

        if(selectedCount) {
            return "<span class='y-attribute-group-info'>("
                + (new Template(Ext.ux.getI18N('attribute.mapper.selected'))).evaluate({
                      count: selectedCount
                  })
                + ")</span>";
        }

        return "";
    };

}());
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Philipp Giese
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {
	    
    var Record = Ext.data.Record.create([
        { name: "checked", mapping: "checked" },
        { name: "title", mapping: "title" },
        { name: "type", mapping: "type" }
	]);
    
    Ext.ux.propertyeditor.GlossaryMapper = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
    	
    	possibleCategories: 0,
    	
    	windowCreate: {
    		height: 300,
    		width: 250,
    		resizable: false
    	},
    	
    	renderer: function(value) {
    		value = this.evalValue(value);
    		
    		if(!this.possibleCategories
    				|| value.length === 0) {
    			
    			return Ext.ux.getI18N("glossary.mapper.all_categories");
    		}
    		
    		return this.possibleCategories - value.length 
    				+ " / " 
    				+ this.possibleCategories 
    				+ " " 
    				+ Ext.ux.getI18N('glossary.mapper.categories_chosen');
    	},
    	
    	getEditor: function(currentValue) {
    		var panel = this.getPanel();
    		
    		this.excludedValues = this.evalValue(currentValue);
    		
    		panel.on("render", this.handleRender.bind(this));
    		panel.getValue = this.getEditorValue.bind(panel, this);
    		
    		return panel;
    	},
    	
    	evalValue: function(value) {
    		try {
    			var json = (value.toString()
    					|| "{}").evalJSON(true);
    			
    			value = json.exclude || [];
    			this.possibleCategories = json.categoryCount;
    		} catch(e) {
    			value = [];
    		}
    		
    		return value;
    	},
    	
    	// scope: panel
    	getEditorValue: function(self) {
    		var values = [];
    		
    		var grid = this.items.get(1);
    		var store = grid.getStore();
    		
    		store.each(function(record) {
    			if(!record.get("checked")) {
    				values.push(record.get("type"));
    			}
    		});
    		
    		values = values.concat(self.excludedValues || []);
    		
//    		if(values.length === store.getCount()) {
//    			values = [];
//    		}
    		
    		return $H({
    			exclude: values,
    			categoryCount: store.getCount()
    		}).toJSON();
    	},
    	
    	getPanel: function() {
    		return new Ext.Panel({
                anchor: "100% 100%",
                border: false,
                layout: "fit",
                autoScroll: true,
                items: [this.getDummyPanel()] 
            });
    	},
    	
    	getDummyPanel: function() {
            return new Ext.Panel({
                border: false,
                collapsed: true,
                collapsible: true,
                width: 200
            });
        },
        
        handleRender: function(panel) {
        	window.setTimeout(function() {
        		
        		panel.getEl().mask(Ext.ux.getI18N('glossary.mapper.loading_groups'));
        		
        		var grid = this.getGrid();
        		grid.on("rowmousedown", this.handleClick);
        		grid.on("mousedown", this.removeCellSelection.bind(this, grid));
        		
        		panel.add(grid);
        		
        		this.getItems(function(items) {
        			grid.getStore().add(items);
        			
        			panel.doLayout();
        			panel.getEl().unmask();
        		});
        		
        	}.bind(this), 100);
        },
        
        handleClick: function(grid, index) {
        	var store = grid.getStore();
        	var record = store.getAt(index);
        	var status = record.get("checked");
        	
        	record.set("checked", !status);
        	store.commitChanges();
        	
        	return false;
        },
        
        removeCellSelection: function(grid) {
        	grid.getEl().select(".x-grid3-cell-selected").each(function(el) {
                el.addClass("y-mapper-grid-no-background");
            });
        },
        
        getItems: function(fn) {
        	var records = [];
        	
        	Signavio.Utils.Request.execute("/p/glossary", {
                async: true,
                success: function(response) {
                	var available = response.map(function(el){return el.rep.id;}).compact();
                	this.excludedValues = this.excludedValues.findAll(function(el) {return available.include(el);});
            		(response || []).each(function(item) {
            			var rep = item.rep;
            			if (item.rel === "cat") {
//            				if(rep.type) {
//            					records.push(new Record({
//                					checked: this.isActive(rep),
//                					title: Ext.ux.getI18N("glossary.mapper.type." + rep.type),
////                					type: rep.id
//                					type: rep.type
//                				}));
//            				} else {
            					records.push(new Record({
            						checked: this.isActive(rep),
            						title: rep.name, //Ext.ux.getI18N("glossary.mapper.type." + rep.type),
            						type: rep.id
            					}));
//            				}
            			}
            		}.bind(this));
            		
            		fn(records);
            	}.bind(this)
            });
        },
        
        isActive: function(rep) {
        	var active = true;
        	var found = undefined;
        	
        	(this.excludedValues || []).each(function(item, index) {
        		if(item === rep.id) {
        			active = false;
        			found = index;
        			
        			throw $break;
        		}
        	});
        	
        	if(!active) {
        		this.excludedValues[found] = undefined;
        		this.excludedValues = this.excludedValues.compact();
        	}        	
        	
        	return active;
        },
        
        getGrid: function() {
        	return new Ext.grid.EditorGridPanel({
        		store: this.getStore(),
        		cm: this.getColumnModel(),
        		border: false,
        		hideHeaders: true,
        		stripeRows: true,
        		anchor: "100% 100%"
        	});
        },
        
        getColumnModel: function() {
        	return new Ext.grid.ColumnModel([
        	    {
        	    	menuDisabled: true,
        	    	hideable: false,
        	    	sortable: false,
        	    	dataIndex: 'checked',
        	    	readonly: true,
        	    	width: 25,
        	    	fixed: true,
        	    	renderer: function(checked) {
        	    		return "<input type='checkbox' " + (checked ? "checked='checked'" : "") + "/>";
        	    	}
        	    },
        	    {
        	    	menuDisabled: true,
        	    	hideable: false,
        	    	sortable: false,
        	    	dataIndex: 'title',
        	    	width: 180,
        	    	readonly: true,
        	    	fixed: true
        	    }
        	]);
        },
        
        getStore: function() {
        	return new Ext.data.SimpleStore({
        		reader: this.getReader(),
        		fields: this.getFields(),
        		data: [],
        		sortInfo: {
        			field: "title",
        			direction: "ASC"
        		}
        	});
        },
        
        getReader: function() {
        	return new Ext.data.ArrayReader({}, this.getFields());
        },
        
        getFields: function() {
        	return [
        	    { name: "checked" },
        	    { name: "title" },
        	    { name: "type" }
        	];
        }
    	
    });
	
})();
/**
 *  (c) 2011 Signavio GmbH
 *
 *  @author Philipp Giese
 *
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {

    var $notImplementedException = {};
    var knownImplementors = [];

    Ext.ux.propertyeditor.AbstractConfigurationPanel = function(attr) {
        attr = attr || {};

        var configurationHeight = 0;
        var that = this;

        if(attr.topPanel) {
            configurationHeight += attr.topPanel.initialConfig.height;
        }

        if(attr.bottomPanel) {
            configurationHeight += attr.bottomPanel.initialConfig.height;
        }

        // wrapper panel, so that configuration of panel
        // handed in via attributes does not affect layouting
        var managedPanel = new Ext.Panel({
            anchor: "100% -" + configurationHeight,
            layout: "anchor",
            border: false,
            header: false,
            items: attr.panel
        });

        this.extendPanel(attr.panel);

        attr.panel.getEl = this.getEl.bind(this);

        attr.anchor = "100% 100%";
        attr.layout = "anchor",
        attr.border = false;
        attr.header = false;
        attr.items = [
            attr.topPanel,
            managedPanel,
            attr.bottomPanel
        ].compact();

        var addReadonlyCapability = function(component, mixins) {
            if(!component) {
                return;
            }

            if(!component.setReadonly) {
                component.setReadonly = Ext.emptyFn;
            }

            var handler = component.setReadonly;

            component.setReadonly = function(value, complete) {
                // the complete flag indicates, that the whole
                // component should be readonly and not only
                // the display panel and the grid.
                if(!complete) {
                    return;
                }

                // to stop standard behaviour, return false
                // in any implementation of the setReadonly
                // method.
                if(handler(value, complete) === false) {
                    return;
                }

                mixins = mixins || [];

                if(value) {
                    mixins.invoke("disable");

                    return;
                }

                mixins.invoke("enable");
            };
        };

        addReadonlyCapability(attr.topPanel, attr.topPanelMixins);
        addReadonlyCapability(attr.bottomPanel, attr.bottomPanelMixins);

        var processMixins = function(component, mixins) {
            if(component) {
                (mixins || []).each(function(mixin) {
                    component.add(mixin);
                });
            }
        };

        this.topMixins = attr.topPanelMixins || [];
        this.bottomMixins = attr.bottomPanelMixins || [];

        processMixins(attr.topPanel, attr.topPanelMixins);
        processMixins(attr.bottomPanel, attr.bottomPanelMixins);

        this.controlPanels = [attr.topPanel, attr.bottomPanel].compact();

        this.getManagedPanel = function() {
        	return attr.panel;
        };

        this.hotWired = function() {
        	return attr.panel.hotWired();
        };

        Ext.ux.propertyeditor.AbstractConfigurationPanel.superclass.constructor.call(this, attr);

        /**
         * Adding an element to this panel, will actually add it to the
         * managed panel. This is needed in order to keep the original code
         * working, not knowing that there is magic going on.
         *
         * @Override
         */
        this.add = function() {
            attr.panel.add.apply(attr.panel, arguments);

            if(arguments.length === 1) {
                var panel = arguments[0];

                panel.on("expand", this.handleChildExpand.bind(this, panel, attr.panel));
            }
        };

        /**
         * As add, this function does not only layout this panel, but
         * also the managed one.
         *
         * @Override
         */
        this.doLayout = function() {
            Ext.ux.propertyeditor.StencilConfigurationPanel.superclass.doLayout.apply(this, arguments);
            attr.panel.doLayout.apply(attr.panel, arguments);
        };
    };

    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager = function(manager) {
    	if(!knownImplementors.include(manager)) {
    		knownImplementors.push(manager);
    	}
    };

    Ext.ux.propertyeditor.AbstractConfigurationPanel.isAllowedStencil = function() {
        var manager = arguments[0] || "";

        if(knownImplementors.include(manager)) {
            manager = eval(manager);

            if(manager.isAllowedStencil && manager.isAllowedStencil instanceof Function) {
                return manager.isAllowedStencil.apply(this, $A(arguments).slice(1));
            }
        }

        return true;
    };

    Ext.extend(Ext.ux.propertyeditor.AbstractConfigurationPanel, Ext.Panel, {

        getComponentHeight: function(entryHeight, items, mixins) {
            var padding = 35;

            return (items.length * entryHeight) + ((mixins || []).length * entryHeight) + padding;
        },

    	getRadio: function(option) {
    		return new Ext.form.Radio(Ext.apply({
    			name: "x-attr-selection",
    			height: 20,
    			cls: "y-attribute-mapper-checkbox"
    		}, option || {}));
    	},

        getOptions: function() {
            throw $notImplementedException;
        },

        getValue: function() {
            throw $notImplementedException;
        },

        /**
         * This method extends a panel object with additional methods,
         * that are necessary in order to work correctly with the
         * control panels.
         *
         * @param panel
         * @param buttonConf
         */
        extendPanel: function(panel) {
            /**
             * This method will execute a given command
             * on the grid elements of each panel, that is
             * a direct child of the parent panel.
             *
             * It also stores the command/ argument
             * information in the options field of each panel,
             * so that also currently collapsed panels
             * know the correct configuration, when they
             * are expanded.
             */
            panel.execute = function(cmd) {
                var start = 1;
                var end = panel.items.indexOf(panel.items.last());
                var args = $A(arguments).slice(1);

                if(panel.items.length > 1) {
                    panel.items.getRange(start, end).each(function(p) {
                        // remove old options
                        p.options = {};
                        // set a flag on each panel, even if currently
                        // not expanded
                        p.options[cmd] = args;

                        var grid = this.extendGrid(p.getGrid());

                        if(cmd === "setReadonly") {
                            var value = args.first();
                            var helpers = p.getSelectionHelpers();

                            grid.readonly = value;
                            panel.isHotWired = value;

                            if(value) {
                                helpers.selectionHelpers.disable();
                            } else {
                                helpers.selectionHelpers.enable();
                                helpers.addToGroups(grid);
                            }
                        } else {
                        	if(p.expanded || p.alreadyExpanded) {
                        		grid[cmd].apply(this, args);
                        	}
                        }

                        p.adjustHeight(grid);
                    }.bind(this));
                }
            };

            /**
             * Removes the info section from each panel
             * header.
             */
            panel.revertTitle = function() {
                var start = 1;
                var end = panel.items.indexOf(panel.items.last());

                if(panel.items.length > 1) {
                    panel.items.getRange(start, end).each(function(p) {
                        p.setTitle(p.initialTitle);
                    });
                }
            };

            panel.setReadonly = function(value, complete) {
                panel.execute.call(this, "setReadonly", value, complete);

                this.controlPanels.each(function(c) {
                    c.setReadonly(value, complete);
                });
            }.bind(this);

            panel.isHotWired = this.isReadonly();

            panel.on("add", this.handleAdd.bind(this));
        },

        handleAdd: function(panel, child) {
            this.extendGrid(child.getGrid());
        },

        handleChildExpand: Ext.emptyFn,

        isReadonly: function() {
            return false;
        },

        /**
         * Extends a grid object with additional functionality, that
         * is needed in order for the control panels to work
         * correctly.
         *
         * Extension is only done, if the grid hasn't been already extended
         * in the past.
         *
         * @param grid
         * @returns
         */
        extendGrid: function(grid) {
            if(!grid.extended) {
                grid.extended = true;

                grid.each = function(iterator) {
                    var store = grid.getStore();

                    grid.doSuspended(function() {
                    	store.each(iterator);
                    });
                };

                /**
                 * Do a bulk change on all records in
                 * the grids store.
                 */
                grid.changeAllValues = function(key, value, readonly) {
                    grid.each(function(record) {
                        record.set(key, value);
                        record.set("readonly", !!readonly);
                    });
                };

                grid.setReadonly = function(value) {
                    grid.each(function(record) {
                        record.set("readonly", value);
                    });
                };
            }

            return grid;
        },

        isAllowedStencil: function() {
            return true;
        }

    });

}());/**
 *  (c) 2011 Signavio GmbH
 *
 *  @author Philipp Giese
 *
 */

if(!window.Ext) { window.Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.propertyeditor) { Ext.ux.propertyeditor = {}; }

(function() {

    var ENTRY_HEIGHT = 20;

	Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel = function(attr) {
		attr = attr || {};

		this.createConfiguration(attr.buttonConf);

        var allAttributes = new Ext.form.Radio({
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.all_attributes'),
            name: "x-attr-selection",
            height: ENTRY_HEIGHT,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectAll(),
            listeners: {
                check: this.useAllAttributes.bind(this, attr.panel)
            }
        });

        var ownAttributes = new Ext.form.Radio({
        	fieldLabel: Ext.ux.getI18N('attribute.mapper.config.own_attributes'),
            name: "x-attr-selection",
            height: ENTRY_HEIGHT,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectOwn(),
            listeners: {
                check: this.useOwnAttributes.bind(this, attr.panel)
            }
        });

        var selectAttributes = new Ext.form.Radio({
        	fieldLabel: Ext.ux.getI18N('attribute.mapper.config.select_attributes'),
            name: "x-attr-selection",
            height: ENTRY_HEIGHT,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectCustom(),
            listeners: {
                check: this.selectAttributes.bind(this, attr.panel)
            }
        });

        var items = [allAttributes, ownAttributes, selectAttributes].compact();

        if(attr.buttonConf.hideAll) {
            items = [];
        }

        var configPanel = new Ext.Panel(Ext.apply(items.length ? {items: items} : {html: ""}, {
        	anchor: "100%",
        	height: this.getComponentHeight(ENTRY_HEIGHT, items, attr.topPanelMixins),
        	layout: "form",
        	cls: "y-attribute-selection y-attribute-selection-top",
        	header: false,
        	border: false,
        	labelWidth: 180,
            setReadonly: function(value) {
                if(value) {
                    items.invoke("disable");

                    return;
                }

                items.invoke("enable");
            }})
        );

        /**
         * Proxy method to mix in some extra attributes to the
         * old getValue function of the original panel
         */
        this.getValue = function() {
        	var value = {};

        	if(selectAttributes.getValue() || attr.buttonConf.hideAll) {
        		// only store items, if the user selected them
        		value = attr.panel.getValue().evalJSON(true);
        	}

        	value.config = {
        		allAttributes: allAttributes.getValue(),
        		ownAttributes: ownAttributes.getValue(),
        		selectAttributes: selectAttributes.getValue() || attr.buttonConf.hideAll
        	};

        	return $H(value).toJSON();
        };

        attr.topPanel = configPanel;

		Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel.superclass.constructor.call(this, attr);
	};

	Ext.extend(Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel, Ext.ux.propertyeditor.AbstractConfigurationPanel, {

		/**
         * This method can be called by each panel with a configuration
         * in order to acquire a set-up options object.
         *
         * @param config
         * @returns {Object}
         */
        getOptions: function() {
            var options = {};

            if(this.isSelectAll()) {
                options.setReadonly = [true];
                options.selectAll = [];
            }

            if(this.isSelectOwn()) {
                options.setReadonly = [true];
                options.selectOwn = [];
            }

            if(this.isSelectCustom()) {
                options.setReadonly = [false];
                options.selectNone = [];
            }

            return options;
        },

		createConfiguration: function(conf) {
            conf = conf || {};

            // To change the default value of the config selection, change
            // the logic here
            this.conf = {
                selectAll: !!conf.allAttributes,
                selectOwn: !!conf.ownAttributes,
                selectCustom: !!conf.selectAttributes || (!conf.allAttributes && !conf.ownAttributes)
            };
        },

        createCustomSetValue: function(label) {
            return function(v){
                var text = v;
                var displayText = "";
                if(this.valueField){
                    var r = this.findRecord(this.valueField, v);
                    if(r){
                        text = r.data[this.displayField];
                    }else if(this.valueNotFoundText !== undefined){
                        text = this.valueNotFoundText;
                    }

                    var tpl = new Template(label);
                    displayText = tpl.evaluate({
                        value: text
                    });
                }
                this.lastSelectionText = text;
                if(this.hiddenField){
                    this.hiddenField.value = v;
                }
                Ext.form.ComboBox.superclass.setValue.call(this, displayText);
                this.value = v;
            };
        },

    	handleChildExpand: function(panel, parent) {
			if(this.isSelectAll()) {
    			this.useAllAttributes(parent, this, true);
    		} else if(this.isSelectOwn()) {
    			this.useOwnAttributes(parent, this, true);
    		} else {
    			this.selectAttributes(parent, this, true);
    		}
    	},

    	isSelectAll: function() {
    		return this.conf.selectAll;
    	},

    	isSelectOwn: function() {
    		return this.conf.selectOwn;
    	},

    	isSelectCustom: function() {
    		return this.conf.selectCustom;
    	},

    	updateConf: function(all, own, custom) {
    		this.conf.selectAll = all;
            this.conf.selectOwn = own;
            this.conf.selectCustom = custom;
    	},

        useAllAttributes: function(panel, self, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectAll();
                panel.revertTitle();
                panel.customAttributes = false;

                this.updateConf(true, false, false);
            }
        },

        useOwnAttributes: function(panel, self, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectOwnAttributes();
                panel.revertTitle();
                panel.customAttributes = false;

                this.updateConf(false, true, false);
            }
        },

        selectAttributes: function(panel, self, value) {
            if(value && !panel.customAttributes) {
            	panel.setReadonly(false);
                panel.selectNone();
                panel.customAttributes = true;

                this.updateConf(false, false, true);
            }
        },

        extendPanel: function(panel) {
            Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel.superclass.extendPanel.call(this, panel);

            panel.selectAll = panel.execute.bind(this, "selectAll");
            panel.selectNone = panel.execute.bind(this, "selectNone");
            panel.selectOwnAttributes = panel.execute.bind(this, "selectOwn");
        },

        isReadonly: function() {
        	return this.isSelectAll() || this.isSelectOwn();
        },

        /**
         * Extends a grid object with additional functionality, that
         * is needed in order for the control panels to work
         * correctly.
         *
         * Extension is only done, if the grid hasn't been already extended
         * in the past.
         *
         * @param grid
         * @returns
         */
        extendGrid: function(grid) {
        	if(!grid.extended) {
        		Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel.superclass.extendGrid.call(this, grid);

                grid.selectAll = grid.changeAllValues.bind(this, "checked", true, true);
                grid.selectNone = grid.changeAllValues.bind(this, "checked", false);
                grid.selectOwn = this.gridSelectOwnValues.bind(this, grid);
        	}

        	return grid;
        },

        gridSelectOwnValues: function(grid) {
            var store = grid.getStore();

            grid.doSuspended(function() {
            	store.query("meta", true).each(function(record) {
        			record.set("checked", true);
        			record.set("readonly", true);
                });

                store.query("meta", false).each(function(record) {
                	record.set("checked", false);
                	record.set("readonly", true);
                });
            });
        }

	});

}());/**
 *  (c) 2011 Signavio GmbH
 *
 *  @author Philipp Giese
 *
 */

if (!Ext){ var Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {

    /**
     * This class can be used together with an Ext.ux.propertyeditor.AttributeMapper.
     * It will add two extra above and under the attribute selection.
     *
     * The top panel yields the possibility to instantly select all attributes or
     * the meta attributes, the uses has defined.
     *
     * It is also possible to hide empty attributes and to decide how multiple
     * attributes should be separated.
     *
     * @param attr
     */
    Ext.ux.propertyeditor.AttributeConfigurationPanel = function(attr) {
        attr = attr || {};

        var hideEmptyAttributes = new Ext.form.Checkbox({
            checked: typeof attr.options.hideEmptyAttributes !== 'undefined' ? attr.options.hideEmptyAttributes : true, //default value: checked,
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.hide_empty_attributes')
        });

        var showAttributeLabel = new Ext.form.Checkbox({
            checked: attr.options.showAttributeLabel,
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.show_attribute_label')
        });

        var separateBy = new Ext.form.ComboBox({
            mode: "local",
            triggerAction: "all",
            editable: false,
            readOnly: true,
            cls: "y-attribute-mapper-form-element",
            emptyText: Ext.ux.getI18N("attribute.mapper.config.separate_labels") + "...",
            store: new Ext.data.SimpleStore({
                data: [
                    [Ext.ux.getI18N("attribute.mapper.config.separator_comma"), ", "],
                    [Ext.ux.getI18N("attribute.mapper.config.separator_space"), " "],
                    [Ext.ux.getI18N("attribute.mapper.config.separator_linebreak"), "\n"]
                ],
                fields: [
                    { name: "title" },
                    { name: "value" }
                ]
            }),
            displayField: "title",
            valueField: "value",
            value: attr.options.separateBy || "\n",
            width: 400,
            fieldLabel: Ext.ux.getI18N("attribute.mapper.config.separate_labels")
        });

        var options = new Ext.Panel({
            border: false,
            header: false,
            layout: "form",
            anchor: "100%",
            defaultType: "textfield",
            labelWidth: 180,
            height: 100,
            cls: "y-attribute-selection y-attribute-selection-bottom",
            items: [
                hideEmptyAttributes,
                showAttributeLabel,
                separateBy
            ]
        });

        if(!attr.config.hideBottom) {
            attr.bottomPanel = options;
        }

        Ext.ux.propertyeditor.AttributeConfigurationPanel.superclass.constructor.call(this, attr, "Ext.ux.propertyeditor.AttributeConfigurationPanel");

        var getValue = this.getValue;

        /**
         * Proxy method to mix in some extra attributes to the
         * old getValue function of the original panel
         */
        this.getValue = function() {
            var value = getValue();

            value = value.evalJSON(true);

            value.options = {
                hideEmptyAttributes: hideEmptyAttributes.getValue(),
                separateBy: separateBy.getValue(),
                showAttributeLabel: showAttributeLabel.getValue()
            };

            value.manager = "Ext.ux.propertyeditor.AttributeConfigurationPanel";

            return $H(value).toJSON();
        };
    };

    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager("Ext.ux.propertyeditor.AttributeConfigurationPanel");

    Ext.extend(Ext.ux.propertyeditor.AttributeConfigurationPanel, Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel);

}());if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.propertyeditor) { Ext.ux.propertyeditor = {}; }

(function() {

    Ext.ux.propertyeditor.ModellingsGuidelinesManager = function(attr) {
        attr = attr || {};

        attr.topPanelMixins = attr.topPanelMixins || [];

        var name = new Ext.form.TextField({
            allowBlank: false,
            emptyText: Ext.ux.getI18N('attribute.mapper.config.name'),
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.name'),
            value: attr.config.name || "",
            height: 20,
            width: 300
        });
        
        attr.topPanelMixins.push(new Ext.form.Label({
        	text: attr.config.description,
        	style: "margin-bottom:10px;display: block;"
        }));
        attr.topPanelMixins.push(name);
        attr.buttonConf.hideAll = true;

        Ext.ux.propertyeditor.ModellingsGuidelinesManager.superclass.constructor.call(this, attr);

        var getValue = this.getValue;

        this.getValue = function() {
            var value = getValue();

            value = value.evalJSON(true);
            value.config.name = name.getValue();

            value.manager = "Ext.ux.propertyeditor.ModellingsGuidelinesManager";

            return $H(value).toJSON();
        };
    };

    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager("Ext.ux.propertyeditor.ModellingsGuidelinesManager");

    Ext.extend(Ext.ux.propertyeditor.ModellingsGuidelinesManager, Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel, {
    	getComponentHeight: function(entryHeight, items, mixins) {
            var padding = 30;

            return (items.length * entryHeight) + ((mixins || []).length * entryHeight) + padding;
        },
        extendPanel: function(panel){
        	Ext.ux.propertyeditor.ModellingsGuidelinesManager.superclass.extendPanel.apply(this,arguments);
        	panel.customAttributes = true;
        }
    });

}());/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Philipp Giese
 *  
 */

if (!Ext){ var Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {
    
    var IDENTIFIERS = {
        NAME: ["name"],
        DESCRIPTION: ["documentation"]
    };
    
    Ext.ux.propertyeditor.SingleAttributeConfigurationPanel = function(attr) {
        attr = attr || {};
        
        this.createConfiguration(attr.buttonConf);
        
        var descriptionOnly = new Ext.form.Radio({
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.description'),
            name: "x-attr-selection",
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectDescription(),
            listeners: {
                check: this.selectDescription.bind(this, attr.panel)
            }
        });
        
        var nameOnly = new Ext.form.Radio({
        	fieldLabel: Ext.ux.getI18N('attribute.mapper.config.name'),
            name: "x-attr-selection",
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectName(),
            listeners: {
                check: this.selectName.bind(this, attr.panel)
            }
        });
        
        var custom = new Ext.form.Radio({
        	fieldLabel: Ext.ux.getI18N("attribute.mapper.config.select_attributes"),
            name: "x-attr-selection",
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectCustom(),
            listeners: {
                check: this.selectCustom.bind(this, attr.panel)
            }
        });
        
        var configPanel = new Ext.Panel({
            anchor: "100%",
            height: 95,
            layout: "form",
            labelWidth: 180,
            cls: "y-attribute-selection y-attribute-selection-top",
            header: false,
            border: false,
            items: [
                nameOnly,
                descriptionOnly,
                custom
            ]
        });
        
        var hideEmptyAttributes = new Ext.form.Checkbox({
        	checked: typeof attr.options.hideEmptyAttributes !== 'undefined' ? attr.options.hideEmptyAttributes : true, //default value: checked,
            height: 20,
            cls: "y-attribute-mapper-checkbox",
	    	fieldLabel: Ext.ux.getI18N('attribute.mapper.config.hide_empty_attributes')
	    });
        
        var showAttributeLabel = new Ext.form.Checkbox({
        	checked: attr.options.showAttributeLabel,
            height: 20,
            cls: "y-attribute-mapper-checkbox",
	    	fieldLabel: Ext.ux.getI18N('attribute.mapper.config.show_attribute_label')
	    });
        
        var options = new Ext.Panel({
        	border: false,
        	header: false,
        	layout: "form",
        	anchor: "100%",
            defaultType: "textfield",
            labelWidth: 180,
        	height: 80,
        	cls: "y-attribute-selection y-attribute-selection-bottom",
        	items: [
        	    hideEmptyAttributes,
        	    showAttributeLabel
        	]
        });
        
        this.getValue = function() {
            var value = {};
            
            if(custom.getValue()) {
                value = attr.panel.getValue().evalJSON(true);
            }
            
            value.config = {
                selectName: nameOnly.getValue(),
                selectDescription: descriptionOnly.getValue(),
                selectCustom: custom.getValue()
            };
            
            value.options = {
        		hideEmptyAttributes: hideEmptyAttributes.getValue(),
        		showAttributeLabel: showAttributeLabel.getValue()
            };
            
            value.manager = "Ext.ux.propertyeditor.SingleAttributeConfigurationPanel";
            
            return $H(value).toJSON();
        };
        
        attr.topPanel = configPanel;
        attr.bottomPanel = options;
        
        Ext.ux.propertyeditor.SingleAttributeConfigurationPanel.superclass.constructor.call(this, attr);
    }; 
    
    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager("Ext.ux.propertyeditor.SingleAttributeConfigurationPanel");
    
    Ext.extend(Ext.ux.propertyeditor.SingleAttributeConfigurationPanel, Ext.ux.propertyeditor.AbstractConfigurationPanel, {
    
        getOptions: function() {
            var options = {};
            
            if(this.isSelectName()) {
                options.selectName = [];
            } else if(this.isSelectDescription()) {
                options.selectDescription = [];
            } else if(this.isSelectCustom()) {
                options.selectCustom = [];
            }
            
            return options;
        },
        
        handleChildExpand: function(panel, parent) {
        	if(panel.alreadyExpanded) {
        		return;
        	}
        	
            if(this.isSelectName()) {
                this.selectName(parent, this, true);
            } else if(this.isSelectDescription()) {
                this.selectDescription(parent, this, true);
            } else {
                this.selectCustom(parent, this, true);
            }
        },
        
        createConfiguration: function(conf) {
            conf = conf || {};
            
            this.conf = {
                selectName: !!conf.selectName,
                selectDescription: !!conf.selectDescription,
                selectCustom: !!conf.selectCustom || (!conf.selectName && !conf.selectDescription)
            };
        },
        
        isSelectName: function() {
            return this.conf.selectName;
        },
        
        isSelectDescription: function() {
            return this.conf.selectDescription;
        },
        
        isSelectCustom: function() {
            return this.conf.selectCustom;
        },
        
        isReadonly: function() {
        	return this.isSelectName() || this.isSelectDescription();
        },
        
        updateConf: function(name, description, custom) {
            this.conf.selectName = name;
            this.conf.selectDescription = description;
            this.conf.selectCustom = custom;
        },
        
        selectName: function(panel, self, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectName();
                panel.revertTitle();
                panel.customAttributes = false;
                
                this.updateConf(true, false, false);
            }
        },
        
        selectDescription: function(panel, self, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectDescription();
                panel.revertTitle();
                panel.customAttributes = false;
                
                this.updateConf(false, true, false);
            }
        },
        
        selectCustom: function(panel, self, value) {
            if(value && !panel.customAttributes) {
            	panel.setReadonly(false);
                panel.selectCustom();
                panel.customAttributes = true;
                
                this.updateConf(false, false, true);
            }
        },
        
        extendPanel: function(panel) {
            Ext.ux.propertyeditor.SingleAttributeConfigurationPanel.superclass.extendPanel.call(this, panel);
            
            panel.selectName = panel.execute.bind(this, "selectName");
            panel.selectDescription = panel.execute.bind(this, "selectDescription");
            panel.selectCustom = panel.execute.bind(this, "selectCustom");
        },
        
        extendGrid: function(grid) {
            if(!grid.extended) {
                Ext.ux.propertyeditor.SingleAttributeConfigurationPanel.superclass.extendGrid.call(this, grid);
                
                grid.selectName = this.checkIfContained.bind(this, IDENTIFIERS.NAME, grid);
                grid.selectDescription = this.checkIfContained.bind(this, IDENTIFIERS.DESCRIPTION, grid);
                grid.selectCustom = this.checkCustom.bind(this, grid);
            }
            
            return grid;
        },
        
        checkCustom: function(grid) {
        	//console.log("grid each - check custom");
        	
            grid.each(function(record) {
                if(record.get("id") === grid.getNoSelectionID()) {
                    record.set("checked", true);
                } else {
                	record.set("checked", false);
                }
                
                record.set("readonly", false);
            });
        },
        
        checkIfContained: function(whiteList, grid) {
        	//console.log("grid each - check if contained");
        	
            grid.each(function(record) {
                if(whiteList.include(record.get("id"))) {
                    record.set("checked", true);
                } else {
                	record.set("checked", false);
                }
                
                record.set("readonly", true);
            });
        }
    
    });
    
}());/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Philipp Giese
 *  
 */
 
if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {
    
    var SEQUENCE_FLOW_ELEMENTS = {
        "http://b3mn.org/stencilset/bpmn1.1#" : [
            "sequence_start",
            "sequence_end",
            "Exclusive_Eventbased_Gateway",
            "FromEventbasedGateway"
        ],
        "http://b3mn.org/stencilset/bpmn2.0#" : [
            "sequence_start",
            "sequence_end",
            "choreography_sequence_start",
            "choreography_sequence_end",
            "Exclusive_Eventbased_Gateway",
            "FromEventbasedGateway",
            "EventbasedGateway"
        ],
        "http://b3mn.org/stencilset/bpmn2.0choreography#": [
            "sequence_start",
            "sequence_end",
            "choreography_sequence_start",
            "choreography_sequence_end",
            "Exclusive_Eventbased_Gateway",
            "FromEventbasedGateway",
            "EventbasedGateway"
        ]
    };
    
    var ACTIVITIES = {
    	"http://b3mn.org/stencilset/bpmn1.1#" : [
            "Task",
            "CollapsedSubprocess",
            "Subprocess"
        ],
    	"http://b3mn.org/stencilset/bpmn2.0#": [
            "Task",
            "CollapsedSubprocess",
            "Subprocess",
            "CollapsedEventSubprocess",
            "EventSubprocess"
	    ]
    };

    var isActivity = function(stencilset, stencil) {
    	var hasActvities = ACTIVITIES[stencilset];
    	
    	if(hasActvities) {
    		return ACTIVITIES[stencilset].include(stencil);
    	}
    	
    	return false;
    };
    
    var isFlowElement = function(stencilset, roles) {
        var connectingStencilsRoles = SEQUENCE_FLOW_ELEMENTS[stencilset];
        var accept = false;
        
        if(connectingStencilsRoles) {
            (roles || []).each(function(role) {
                if(connectingStencilsRoles.include(role)) {
                    accept = true;
                    
                    throw $break;
                }
            });
        }
        
        return accept;
    };
    
    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager("Ext.ux.propertyeditor.StencilConfigurationPanel");
    
    Ext.ux.propertyeditor.StencilConfigurationPanel = function(attr) {
        attr = attr || {};
        
        this.createConfiguration(attr.buttonConf);
        
        var selectAll = this.getRadio({
            fieldLabel: Ext.ux.getI18N("attribute.mapper.config.all_elements"),
            checked: this.isSelectAll(),
            listeners: {
                check: this.selectAll.bind(this, attr.panel)
            }
        });
        
        var selectFlowElements = this.getRadio({
        	fieldLabel: Ext.ux.getI18N("attribute.mapper.config.flow_elements"),
            checked: this.isSelectFlow(),
            listeners: {
                check: this.selectFlow.bind(this, attr.panel)
            }
        });
        
        var selectActivities = this.getRadio({
        	fieldLabel: Ext.ux.getI18N("attribute.mapper.config.activities"),
        	checked: this.isSelectActivities(),
        	listeners: {
        		check: this.selectActivies.bind(this, attr.panel)
        	}
        });
        
        var selectCustom = this.getRadio({
        	fieldLabel: Ext.ux.getI18N("attribute.mapper.config.select_elements"),
            checked: this.isSelectCustom(),
            listeners: {
                check: this.selectCustom.bind(this, attr.panel)
            }
        });
        
        var configPanel = new Ext.Panel({
            anchor: "100%",
            height: 130,
            layout: "form",
            labelWidth: 180,
            cls: "y-attribute-selection y-attribute-selection-top",
            header: false,
            border: false,
            items: [
                selectAll,
                selectFlowElements,
                selectActivities,
                selectCustom
            ]        
        });
        
        this.getValue = function() {
            var value = {};
            
            if(selectCustom.getValue()) {
                value = attr.panel.getValue().evalJSON(true);
            }
            
            value.config = {
                allElements: selectAll.getValue(),
                flowElements: selectFlowElements.getValue(),
                activities: selectActivities.getValue(),
                customElements: selectCustom.getValue()
            };
            
            value.manager = "Ext.ux.propertyeditor.StencilConfigurationPanel";
            
            return $H(value).toJSON();
        };
        
        attr.topPanel = configPanel;
        
        Ext.ux.propertyeditor.StencilConfigurationPanel.superclass.constructor.call(this, attr, "Ext.ux.propertyeditor.StencilConfigurationPanel");
    };
    
    Ext.ux.propertyeditor.StencilConfigurationPanel.isAllowedStencil = function(stencilset, stencil, restrictions) {
        if(restrictions.flowElements) {
            return isFlowElement(stencilset, stencil.roles);
        }
        
        if(restrictions.activities) {
        	return isActivity(stencilset, stencil.id);
        }
        
        return true;
    };
    
    Ext.extend(Ext.ux.propertyeditor.StencilConfigurationPanel, Ext.ux.propertyeditor.AbstractConfigurationPanel, {
        
        handleChildExpand: function(panel, parent) {
            if(this.isSelectAll()) {
                this.selectAll(parent, this, true);
            } else if(this.isSelectFlow()) {
                this.selectFlow(parent, this, true);
            } else if(this.isSelectActivities()) {
            	this.selectActivies(parent, this, true);
            } else {
                this.selectCustom(parent, this, true);
            }
        },
        
        /**
         * This method can be called by each panel with a configuration
         * in order to acquire a set-up options object. 
         * 
         * @param config
         * @returns {Object}
         */
        getOptions: function() {
            var options = {};
            
            if(this.isSelectAll()) {
                options.setReadonly = [true];
                options.selectAll = [];
            }
            
            if(this.isSelectFlow()) {
                options.setReadonly = [true];
                options.selectFlow = [];
            }
            
            if(this.isSelectActivities()) {
            	options.setReadonly = [true];
            	options.selectActivities = [];
            }
            
            if(this.isSelectCustom()) {
                options.setReadonly = [false];
                options.selectCustom = [];
            }
            
            return options;
        },
        
        createConfiguration: function(conf) {
            conf = conf || {};
            
            this.conf = {
                allElements: !!conf.allElements,
                flowElements: !!conf.flowElements,
                activities: (typeof conf.activities === "undefined") ? true : conf.activities,
                customElements: conf.customElements || (!conf.allElements && !conf.flowElements && conf.actvities === false)
            };  
        },
        
        updateConfiguration: function(all, flow, activities, custom) {
            this.conf.allElements = all;
            this.conf.flowElements = flow;
            this.conf.activities = activities;
            this.conf.customElements = custom;
        },
        
        selectAll: function(panel, that, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectAll();
                panel.customAttributes = false;
                
                this.updateConfiguration(true, false, false, false);
            }
        },
        
        selectFlow: function(panel, that, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectFlow();
                panel.customAttributes = false;
                
                this.updateConfiguration(false, true, false, false);
            }
        },
        
        selectActivies: function(panel, that, value) {
        	if(value) {
        		panel.setReadonly(true);
        		panel.selectActivities();
        		panel.customAttributes = false;
        		
        		this.updateConfiguration(false, false, true, false);
        	}
        },
        
        selectCustom: function(panel, that, value) {
            if(value && !panel.customAttributes) {
            	panel.setReadonly(false);
                panel.selectCustom();
                panel.customAttributes = true;
                
                this.updateConfiguration(false, false, false, true);
            }
        },
        
        isSelectAll: function() {
            return this.conf.allElements;
        },
        
        isSelectFlow: function() {
            return this.conf.flowElements;
        },
        
        isSelectActivities: function() {
        	return this.conf.activities;
        },
        
        isSelectCustom: function() {
            return this.conf.customElements;
        },
        
        isReadonly: function() {
        	return this.isSelectAll() || this.isSelectFlow() || this.isSelectActivities();
        },
        
        extendPanel: function(panel) {
            Ext.ux.propertyeditor.StencilConfigurationPanel.superclass.extendPanel.call(this, panel);
            
            panel.selectAll = panel.execute.bind(this, "selectAll");
            panel.selectFlow = panel.execute.bind(this, "selectFlow");
            panel.selectActivities = panel.execute.bind(this, "selectActivities");
            panel.selectCustom = panel.execute.bind(this, "selectCustom");
        },
        
        extendGrid: function(grid) {
            if(!grid.extended) {
                Ext.ux.propertyeditor.StencilConfigurationPanel.superclass.extendGrid.call(this, grid);
                
                grid.selectAll = grid.changeAllValues.bind(this, "checked", true, true);
                grid.selectFlow = this.selectFlowElements.bind(this, grid);
                grid.selectActivities = this.selectActivites.bind(this, grid);
                grid.selectCustom = grid.changeAllValues.bind(this, "checked", true);
            }
            
            return grid;
        },
        
        selectActivites: function(grid) {
        	grid.each(function(record) {
    			record.set("checked", isActivity(record.get("stencilset"), record.get("stencil")));
        		record.set("readonly", true);
        	});
        },
        
        selectFlowElements: function(grid) {
            grid.each(function(record) {
                record.set("checked", isFlowElement(record.get("stencilset"), record.get("roles")));
                record.set("readonly", true);
            });
        }
        
    });

}());/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand, Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { window.Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }

new function() {
	
	Ext.ux.Richtext = {
			
			/**
			 * A list of the allowed tag names
			 */
			_allowedNodes : $w("blockquote span div p font h1 h2 h3 hr li ul ol b i u br a"),
			
			/**
			 * A list of the allowed attribute names
			 */
			_allowedAttributes : $w("href style"),
			
			/**
			 * A list of the allowed css attribute names
			 */
			_allowedCSSAttributes : $w("color font-size font-weight text-align margin-left background background-color"),
			
			/**
			 * A list of the attribute names defining styles which are not css attributes
			 */
			_styleAttributes : $w("color size fontWeight align"),
			
			/**
			 * A map of style attribute names and valid css tags
			 * maps css tag -> style tag
			 */
			_mappedStyles : $H({
				color		: "color",
				size		: "font-size",
				fontWeight	: "font-weight",
				align		: "text-align"
			}),
			
			/**
			 * A list of all attributes which imply a line break
			 */
			_blockAttributes : $w("h1 h2 h3 hr li br div blockquote"),
			
			/**
			 * A map of valid css font sizes to transform the size attribute 
			 */
			_fontSizes : $w("8px 10px 12px 16px 18px 24px 32px 48px"),
			
			/**
			 * A map of tag names, which should be used instead
			 */
			_nodeMapping: {
				"#comment"		: "#text",
//				"span"			: "font",
				"p"				: "div",
				"blockquote"	: "div",
				"strong" 		: "b",
				"em" 			: "i"
			},
			
			_encodeNodeMapping : {
				"div"			: "blockquote"
			},
			
			/**
			 * Encodes the given text with the richtext attributes provided in a json
			 * @param {String} text The given text to encode
			 * @param {Object[]} format The richtext attributes
			 * @returns {String} The formatted text with proper escaped text content
			 */
			encode : function(text, format) {
				// If no text is provided, return
				if ("string" != typeof text) return;
				text = text.replace(/[\r]/g, ""); // Replace all \r, becuase of Opera is added those to the string
				
				
				if ("undefined" === typeof format) {
					// If no format is defined, just return the escaped text
					return this._encode(text, []);
				} else if ("string" === typeof json) {
					// If the format is given as a string, try to parse it to an array
					try {
						format = Ext.decode(format);
					} catch(e) {
						// If it's not possible to parse the string, just return the escaped text
						return this._encode(text, []);
					}
				}
				
				// Clone the format object
				if (format instanceof Array){
					format = format.map(function(r){ return Object.clone(r); });
				} else {
					return this._encode(text, []);
				}
				
				// Copy
				//format = Ext.decode(Ext.encode(format));
				
				format.filter(function(f) {
					return this._blockAttributes.include(f.tag);
				}.bind(this))
				// Get all end positions
				.pluck("to")
				// Sort
				.sortBy(function(pos) {
				    return Number(pos);
				})
				// Remove new lines at the given positions
				.each(function(pos) {
					if (text.charAt(pos) === "\n") {
						text = text.substr(0, pos) + text.substr(pos+1);
					}
				});
				
				//if (!Ext.isIE6 && !Ext.isIE7 && !Ext.isIE8) {
					// Encode the modified text with the given format
					return this._encode(text, format);
//				} else {
//					var found=0, newlinePositions = [];
//					format = [].concat(format); // Clone formats
//					
//					// Find all \n linefeeds and replace with whitespaces, remember all positions
//					while(text.indexOf("\n") !== -1) {
//					    found = text.indexOf("\n", found||0);
//					    newlinePositions.push(found);
//					    text = text.substr(0, found) + " " + text.substr(found+1);
//					}
//					// Create a new format definition object for each newline and append it to the
//					// existing format definitions
//					newlinePositions.reverse().each(function(pos) {
//					    format.push({from:pos, to:pos, tag:"br"});
//					});
//					
//					// Encode the modified text with the given format
//					return this._encode(text, format);
//				}
				
			},
			
			/**
			 * Private function to encode the given text and format
			 * @param {String} text The given text to encode
			 * @param {Object[]} format the richtext attributes
			 * @returns {String} The formatted text with proper escaped text content
			 */
			_encode : function(text, format) {
				
				// Create the root node (helper div)
				var root = document.createElement("div");
				// Add the text to the root node
				root.appendChild(document.createTextNode(text));
				
				var prevLength = 0, cachedNodes = {};
				// Iterate over all richtext attributes
				
				for (var i = 0, size = format.length; i < size; ++i){
					// The current text position
					var att = format[i],
						index = {pos:att.from};
					
					// Get the surrounding node of the current text element
					var node = this.findNode(root, index, att.from === att.to);
					
					if (node) {
						
						// Check if the node needs another kind of element being created
						if ((Ext.isChrome || Ext.isSafari) && att.tag ==="div" && att.style && att.style["margin-left"]) {
							att.tag = this.getEncodeNodeName(att.tag);
						}
						
						// Create a new node according to the given tag,
						// cache it because of performance (it is a little faster (around 30%) 
						// to copy than to create)
						var newNode = cachedNodes[att.tag];
						if (!newNode){
							newNode = cachedNodes[att.tag] = document.createElement(att.tag);
						} 
						newNode = newNode.cloneNode(false);
						
						// Filter all allowed attributes and the style object from the json
						for (var key in att){
							if (this._allowedAttributes.include(key) && key != "style"){

								// If the node is a link, add some attributes for safety
								if (key === "href") {
									newNode.setAttribute("target", "_blank");
									newNode.setAttribute("rel", "external");
								}

								// Append all allowed attributes to the new node 
								newNode.setAttribute(key, att[key]);
							}
						}

						
						// Get a hash map of the valid css attributes
						var nodeAtts = {};
						var styleAtts = {};
						/*
						 * Iterate over all incoming styles and check if they should
						 * be added as a node attribute or a style attribute
						 */
						$H(att.style).keys().each(function(key) {
							var validKey;
							/*
							 * Look-up the key of the entry in the list of the valid css
							 * attributes where the value is the key of the provided style
							 */
							if (this.isValidCSSAttribute(key)) {
								/* 
								 * Check if the style attribute should be added as a node attribute
								 * for compatibility issues. This only needs to be done in FF 11 or previous OR IE
								 */ 
								if (this.isNodeAttribute(key)&&(Ext.isIE || (Ext.isFF&&Ext.getBrowserVersion()<12))) { 
									validKey = this.getNodeStyleKey(key);
									/*
									 * Push the found key/value pair to the list of the attributes
									 * which should be added to the node
									 */
									var value = att.style[key];
									if (!value) return;
									
									// Translate RGB -> HEX for color attributes
									if (value.startsWith("rgb(")){
										value = this.rgb2hex(value);
									}

									if (validKey === "size") {
										value = this.getValidFontSize(value);
									}
									// If the attribute is the font size attribute, look-up the browser-defined font size
									nodeAtts[validKey] = value;
								}
								/*
								 * If the found style attribute should not be added to the node,
								 * keep it as a style attribute.
								 */
								else {
									// Add the attribute as a css value
									styleAtts[key] = att.style[key];
								}
							}
						}.bind(this));

						// Add the additional style attributes to the node
						for (var key in nodeAtts){
							if (Object.prototype[key] !== nodeAtts[key]) {
								newNode.setAttribute(key, nodeAtts[key]);							
							}
						}

						var styleString = this.serializeCSSAttributes(styleAtts);
						
						if (styleString) {
							if (Ext.isIE7 || Ext.isIE6){
								newNode.style.setAttribute("cssText", styleString);
							} else {
								newNode.setAttribute("style", styleString);
							}
						}
						
						var tc = this._getTextContent(node),
							from = tc.length + index.pos,
							to = from + att.to-att.from;

						// Slice the text content of the surrounding node
						var prefix  = tc.slice(0, from);
						var newText = tc.slice(from, to);
						var suffix  = tc.slice(to); //((Ext.isIE6 || Ext.isIE7 || Ext.isIE8) && att.tag === "br" ? to+1 : to)
						
						// Create the new text node
						if (att.from !== att.to)
							newNode.appendChild(document.createTextNode(newText));
						
						node.nodeValue = prefix;
						
						// If the current tag is a non child containing block 
						// element,append those after all similar elements.
						if (att.from === att.to && ["br","hr"].include(att.tag)){
							while(node.nextSibling && 1 == node.nextSibling.nodeType && ["br","hr"].include(node.nextSibling.tagName.toLowerCase())) {
								node = node.nextSibling;
							}
						}
						
						// Push the new node to the end of the old node
						node.parentNode.insertBefore(newNode, node.nextSibling);
						// Push the suffix to the end of the old node
						node.parentNode.insertBefore(document.createTextNode(suffix), newNode.nextSibling);
						prevLength = (newText.length > 0 && newText.length || 0);
					}
				}
				
				// Handle linebreaks differently in ie7 and ie8
				if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
					return root.innerHTML.replace(/[\n\r]/g, "");	
				}
				// return the inner HTML of the helper div, convert \n line feeds to xml-valid br tags
				return root.innerHTML
						.replace(/\n/ig, "<br/>")
						.replace(/<hr[^>]*>/ig, "<hr/>");
			},

			/**
			 * Returns the text content of the node
			 * @param {HTMLElement} node
			 * @returns {String}
			 */
			_getTextContent: function(node){
				return Signavio.Utils.unescapeHTML(node.textContent||node.nodeValue||"");
			},


			/**
			 * Decodes a given Node to a json array
			 * @param {HTMLElement} root The node to decode
			 * @param @private {Object} length for internal use only
			 * @param @private {Object[]} res for internal use only
			 * @returns {JSON[]}
			 */
			decode : function(root) {
				
				// Check if the given root is a html element
				if (root && 1 === root.nodeType) {
					// Use a working copy for the decode
					root = root.cloneNode(true);
					// remove style elements
					$A(root.getElementsByTagName("style")).each(function(node) {
						node.parentElement.removeChild(node);
					});
					// Strip all illegal line breaks
					var inHTML = root.innerHTML
						// first replace line breaks between two words with one space
						.replace(/([^\s<>]){1}(\n)+([^\s<>]){1}/g, function(match, g1, g2, g3) {
							return g1.concat(" ", g3)
						})
						// finally strip the remaining line breaks
						.replace(/\n/ig, "");

					root.innerHTML = inHTML;

					// Get the plain text
					var text = this._getTextContent(root);
					var format = [];
				} else {
					// If root is not a HTMLElement, just return the text without any format
					return {text: String(root), format: []};
				}

				// Remember all positions for line breaks
				this.insertBreaks = new Hash();
				
				// Get the decoded node
				this._decode(root, {pos : 0}, format);

				// Remove all forbidden/unneeded nodes
				format = format.findAll(function(node){

					// Convert spans to other tags
					this.convertSpanTag(node);
					
					// If a style is defined
					if (node.style) {
						// Filter all forbidden style attributes
						// TODO: check specifically allowed attributes for each node
						node.style = this.getValidStyles(node.style);
					}
					
					if (node.tag === "div" && node.from === node.to){
						node.tag = "br";
					}
					
					
					// Remove all divs which have no margin, remove them from the list of breaks as well
					if (node.tag === "div" && !node.style) {
						if (this.insertBreaks[node.to].include("div")) {
							this.insertBreaks[node.to].remove("div");
						}
						return false;
					}
					
					// Filter spans without any style attributes
					if (["span"].include(node.tag) && !node.style) {
						return false;
					}
					
					// Filter all non-block elements which have no content and no style definition
					if (["font", "span", "b", "i", "u", "h1", "h2", "h3"].include(node.tag) && node.from === node.to) {
						return false;
					}
					
					return true;
				}.bind(this));
				
				// Get all positions of elements which force a line break
				var insertBreakPositions = [];
				for (var key in this.insertBreaks) {
				    if (!isNaN(Number(key))) {
				    	insertBreakPositions.push(Number(key));
				    }
				}
				
				// Sort them ascending
				insertBreakPositions.sortBy(function(pos) {
					return Number(pos);
				})
				// Invert range
				.reverse()
				// Insert new line for each block element
				.each(function(pos) {
					text = text.substr(0, pos) + "\n".times(this.insertBreaks[pos].length) + text.substr(pos);
				}.bind(this));

				return {text: text, format: format};
			},
			
			/**
			 * Private function to actually decode a given root
			 * @param {HTMLElement} root The node to decode
			 * @param {Object} length The current position of the carret, must be an object to be altered without return
			 * @param {Object[]} res The result set
			 * @returns The decoded node as {text:text, format:format}
			 */
			_decode : function(root, length, res) {

				// Unify the DOM in all browsers
				this.unifyRootStructure(root);
				
				$A(root.childNodes).each(function(node) {
					if (!node) return;
					
					if ("undefined" === typeof length) length = {pos : 0};
					if ("undefined" === typeof res) {
						res = [];
					}
					
					// Get the name of the node
					var nN = this.getNodeName(node);
					
					if (node.nodeType === 1) {						
						if (this.isAllowedNode(nN)) {
							// Generate the representation of the tag for the json
							var rep = {
									from: length.pos,
									to	: length.pos + this._getTextContent(node).length,
									tag	: nN
							};
							
							if (this._blockAttributes.include(nN)) {
								if (!this.insertBreaks[rep.to]) {
									this.insertBreaks[rep.to] = [];
								}
								this.insertBreaks[rep.to].push(nN);
							}
							
							// Get the attributes of the node
							var attributes = $A(node.attributes);

							// Prepare a json to store style information
							var style = {};
							
							var styleAttribute = attributes.find(function(att) {
								return this.isStyle(att.nodeName);
							}.bind(this));
							
							// If a style attribute exists, serialize it
							if (styleAttribute) {
								Ext.apply(style, this.getStyleFromString(styleAttribute.nodeValue));
							}
							
							// Check all other attributes if they need to be serialized
							attributes.without(styleAttribute).each(function(att) {

								// Get the attribute name
								var aN = att.nodeName.toLowerCase();

								// If the given attribute is permitted to save
								if (this.isAllowedAttribute(aN) && !this.isLinkAttribute(aN)) {
									rep[aN] = att.nodeValue;
								} else if (this.isLinkAttribute(aN)) {
									// Filter all javascript functions or forbidden characters (whitespace, tabs, null)
									rep[aN] = att.nodeValue.replace(/[\s\0]/ig, "").replace(/(javascript:)(.*)/ig, "$2");
								}
								// If the given attribute is a style attribute
								else if (this.isStyleAttribute(aN)) {
									var styleObject = this.getCSSPair(att);
									if (styleObject.key && styleObject.value) {
										/*
										 *  Overwrites existing style attributes because it can be taken for granted that
										 *  dedicated style attributes are newer than any definitions in the style attribute.
										 */
										style[styleObject.key] = styleObject.value;	
									}
								}
							}.bind(this));
							
							
							if (nN === "span" && style && (style["background"] || style["background-color"])){
								this.handleHiliteColor(style);
							}
							
//							var additionalRepresentations = [];
//							// Check for text background
//							if (nN === "span") {
//								var hiliteRep = this.handleHiliteText(rep, style);
//								if (hiliteRep) {
//									additionalRepresentations.push(hiliteRep);
//								}
//							}
							
							// If in chrome, handle indention separately
							if ((Ext.isChrome || Ext.isSafari) && nN === "div") {
								this.handleIndentText(style);
							}
							
							// If styles exist, add them to the serialization
							if ($H(style).keys().length > 0) {
								rep["style"] = style;
							}
							// Add the representation
							res.push(rep);

							// Add additional representations after the current one
//							additionalRepresentations.each(function(r) {
//								res.push(r);
//							});
						} 
						
						// Go recursively 
						this._decode(node, length, res);
						
					} else if (node.nodeType === 3) {
						length.pos += this._getTextContent(node).length;
					}
				}.bind(this));
			},
			
			
			/**
			 * 
			 * @param node
			 */
			convertSpanTag: function(node){
				if (node.tag == "span"){
					var style = $H(node.style);
					if (style.keys().length == 1){
						// IF <span style="font-weight:bold;">...  use   <b>
						if (node.style["font-weight"] == "bold"){
							delete node.style;
							node.tag = "b";
						
						// IF <span style="font-style:italic;">...  use   <i>
						} else if (node.style["font-style"] == "italic"){
							delete node.style;
							node.tag = "i";
							
						// IF <span style="color:#..;">...  use   <font style...
						} else if (node.style["color"]){
							node.tag = "font";
						}
					}
				}
				return node;
			},
			
			/**
			 * Unifies the structure of the given node to be the same in all browsers
			 * @param {HTMLElement}root
			 */
			unifyRootStructure : function(root) {
				if (!root) return;
				$A(root.childNodes).each(function(node) {
					if (!node || node.nodeType !== 1) return;
					
					var nN = this.getNodeName(node);
					
					// Remove the last br inside the div
					if (nN === "div" && this.isLastChildBR(node)) {
						node.removeChild($A(node.childNodes).last());
					// Add a br if it's needed
					} else if (node.nodeName.toLowerCase() === "p" && !this.isLastChildBlockElement(node) && !this.isNodeFollowedByBlockElement(node)) {
						node.appendChild(document.createElement("br"));
					}
					
					if ((Ext.isChrome || Ext.isSafari) && nN === "div" && node.previousSibling && !this._blockAttributes.include(this.getNodeName(node.previousSibling)) && !["ul", "ol"].include(this.getNodeName(node.previousSibling))) {
						root.insertBefore(document.createElement("br"), node);
					}
					
					if ((Ext.isChrome || Ext.isSafari) && nN === "div" && node.nodeName.toLowerCase() !== "blockquote" && !node.getAttribute("align") && node.nextSibling && this._blockAttributes.without("br").include(this.getNodeName(node.nextSibling))) {
						root.insertBefore(document.createElement("br"), node.nextSibling);
					}
				}.bind(this));

			},			
			
			/**
			 * Serializes a given object representing css-styles
			 * @param {Object} attributes
			 * @returns {String} The serialized object
			 */
			serializeCSSAttributes : function(atts) {
				var styleString = "";
				$H(atts).keys().each(function(key) {
					if (atts[key]) {
						var value = atts[key];
						if (value.startsWith("rgb(")) {
							// use RGB->HEX colors
							value = this.rgb2hex(value); 
						}
						styleString += key+":"+value+";";
					}
				}.bind(this));
				return styleString;
			},
			
			handleHiliteColor : function(style) {
				var key = (style["background-color"] ? "background-color" : "background");
				style[key] = this.rgb2hex($A(style[key].split("rgb")).last());
			},
			
			/**
			 * Checks if the given font node has a background defined, if so, strip it from the definition and create
			 * a separate representation
			 * @param @callByReference {Object} style
			 * @returns {rep}
			 */
			handleHiliteText : function(rep, style) {
				if (style && (style["background-color"] || style["background"])) {
					
					// get the key which should be deleted later
					var delKey = style["background-color"] ? "background-color" : "background";
					
					var spanRep = {
							from: rep.from,
							to	: rep.to,
							tag	: "span",
							style : {background : this.rgb2hex($A(style[delKey].split("rgb")).last())}
					};
					delete style[delKey];
				}
				
				return spanRep;
				
			},
			
			/**
			 * Checks if the given div node has a margin, if so, get only the margin-left information, store them and
			 * discard the old margin information
			 * @param @callByReference {Object} style
			 */
			handleIndentText : function(style) {
				if (style && style["margin"]) {
					var value = style["margin"];
					// Get the left part
					value = value.split(" ").last();
					// Set margin left
					style["margin-left"] = value;
					// Delete the old style
					delete style["margin"];
				}
			},
			
			/**
			 * Returns the node containing the current text position
			 * @param {DOM Node} root The root node
			 * @param {Object} index The text position
			 * @returns {DOM Node} The node containing the text position
			 */
			findNode : function(root, index, isEmpty) {
			    var result, cn = root.childNodes;
			    
			    for (var i = 0, size = cn.length; i < size; ++i){
			    	var node = cn[i];
			    	if (node.nodeType === 1){
			            result = this.findNode(node, index);
			            if (result) 
			                return result;
			        } else if(node.nodeType === 3 && this._getTextContent(node).length) {
			            index.pos -= this._getTextContent(node).length;
			            if (!isEmpty && index.pos < 0 ||
			            	isEmpty && index.pos <= 0){
			                return node;
			            }
			        }	
			    }
			    return result;
			},
			
			/**
			 * Returns a browser compatible font size definition (Number in range 0 to 7)
			 * @param {String} fontSize
			 * @returns
			 */
			getValidFontSize : function(fontSize) {
				// If the font string is malformed, return the default size
				if (!["string", "number"].include(typeof fontSize)) {
					return 2; 
				}
				
				if ("number" === typeof fontSize) {
					// If the given font size is in the correct form and a valid font size, return it. else return the default size
					return fontSize > 0 && fontSize < 8 && fontSize || 2;
					
				} else if (fontSize.endsWith("px")) {
					// Parse to Number
					fontSize = fontSize.split("px")[0];
				} else if (fontSize.endsWith("pt")) {
					// Parse to Number
					fontSize = Number(fontSize.split("pt")[0]);
					// Translate from pt -> px
					fontSize *= 4/3;
				} else {
					// If the font size could not be determined, return the default size
					return 2;
				}
				
				var closestFS = 2, distance = Infinity, currDistance;
				// Get the closest defined font size
				this._fontSizes.each(function(size, index) {
				    // inline assignment for current distance, inline parsing from string to number
					if ((currDistance = Math.abs(fontSize - Number(size.split("px")[0]))) < distance) {
				        distance = currDistance;
				        closestFS = index;
				    }
				});
				// Return the font size
				return closestFS;
			},
			
			/**
			 * Get a cleaned up styles object to filter all forbidden style attributes.
			 * @param {Array} styles
			 */
			getValidStyles : function(styles) {
				var allowedStyles;
				styles = $H(styles||[]).each(function(pair) {
					if (this.isValidCSSAttribute(pair.key)) {
						var value = this.getValidCSSValue(pair);
						if (value && value != "0px" && value != "0pt") {
							// Initialize only if a valid css entry was found
							if (!allowedStyles) {
								allowedStyles = {};
							}
							allowedStyles[pair.key] = value;
						}
					}
				}.bind(this));
				
				return allowedStyles;
			},
			
			/**
			 * Returns true if the given node name is in the list of the allowed tag names
			 * @param {String} nodeName The name of the node
			 * @returns {Boolean}
			 */
			isAllowedNode : function(nodeName) {
				nodeName = (nodeName||"").toLowerCase();
				return this._allowedNodes.include(nodeName);
			},
			
			/**
			 * Returns true if the given attribute name is in the list of the allowed attribute names
			 * @param {String} attName The name of the attribute
			 * @returns {Boolean}
			 */
			isAllowedAttribute : function(attName) {
				attName = (attName||"").toLowerCase();
				return this._allowedAttributes.include(attName);
			},
			
			/**
			 * Returns true if the last child of the given node is a block element
			 * @param {HTMLElement} node
			 * @returns {Boolean}
			 */
			isLastChildBlockElement : function(node) {
				if (!node) return false;
				
				return this._blockAttributes.include(this.getNodeName($A(node.childNodes).last()));
			},
			
			/**
			 * Returns true if the last child of the given node is a line break
			 * @param {HTMLElement} node
			 * @returns {Boolean}
			 */
			isLastChildBR : function(node) {
				if (!node) return false;
				
				return this.getNodeName($A(node.childNodes).last()) === "br";
			},
			
			/**
			 * Returns true if the given attribute name is href
			 * @param {String} attName The name of the attribute
			 * @returns {Boolean}
			 */
			isLinkAttribute : function(attName) {
				attName = (attName||"").toLowerCase();
				return attName === "href";
			},
			
			/**
			 * Returns true if the given attribute name is an allowed node key
			 * @param {String} attName
			 * @returns {Boolean}
			 */
			isNodeAttribute : function(attName) {
				attName = (attName||"").toLowerCase();
				return this._mappedStyles.values().include(attName); 
			},
			
			/**
			 * Returns true if the following node after the given one is a block element.
			 * @param {HTMLElement} node
			 * @returns {Boolean}
			 */
			isNodeFollowedByBlockElement : function(node) {
				if (!node) return false;
				
				return node.nextSibling && this._blockAttributes.include(node.nextSibling.nodeName);
			},
			
			/**
			 * Returns true if the given attribute is the style attribute.
			 * @param {String} attName
			 * @returns {Boolean}
			 */
			isStyle : function(attName) {
				attName = (attName||"").toLowerCase();
				return attName === "style";
			},
			
			/**
			 * Returns true if the given attribute name defines a style
			 * @param {String} attName
			 * @returns {Boolean}
			 */
			isStyleAttribute : function(attName) {
				attName = (attName||"").toLowerCase();
				return this._styleAttributes.include(attName);
			},
			
			/**
			 * Returns true if the given attribute name is an allowed css key
			 * @param {String} attName
			 * @returns {Boolean}
			 */
			isValidCSSAttribute : function(attName) {
				attName = (attName||"").toLowerCase();
				return this._allowedCSSAttributes.include(attName); 
			},
			
			/**
			 * Finds all occurences of br tags in the given string.
			 * @param string
			 * @returns {{tag : "br", start: Number, end: Number}[]}
			 */
			getBreakPositions : function(string) {
				var car, ind = [];
				
				while((car = string.search(/<br[^>]*>/i)) !== -1) {
					ind.push(car);
					// Slice out the <br/> tag
					string = string.slice(car + string.match(/<br[^>]*>/i)[0].length);
				}
				ind.each(function(foo, i) {
					ind[i] += (i > 0 ? ind[i-1] : 0);
				});
				
				return ind;
			},
			
			/**
			 * Returns the css representation of the given attribute key
			 * @param {String} attName The name of the given attribute
			 * @returns {String} The valid css key
			 */
			getCSSKey : function(attName) {
				attName = (attName||"").toLowerCase();
				return this._mappedStyles[attName] || this._mappedStyles.get instanceof Function && this._mappedStyles.get(attName);
			},
			
			/**
			 * Returns a key/value object with a css compatible key
			 * @param {Object} att
			 * @returns {Object}
			 */
			getCSSPair : function(att) {
				var attName = att.nodeName.toLowerCase();
				// If the given node is a size attribute, handle it differently
				if (attName === "size") {
					return {key: "font-size", value: this._fontSizes[att.nodeValue] || this._fontSizes.get instanceof Function && this._fontSizes.get(att.nodeValue)};
				}

				return {key: this.getCSSKey(attName), value: att.nodeValue};
			},
			
			getMarginLeft : function(att) {
				var value = att.nodeValue;
				
			},
			
			/**
			 * Transforms rgb -> hex values and filters expressions
			 * @param {String} value
			 * @returns {String}
			 */
			getValidCSSValue : function(pair) {
				if (!pair) return;
				
				if (pair.value.include("expression(")) {
					return;
				}
				if (pair.value.startsWith("rgb(")){
					return this.rgb2hex(pair.value);
				}
				
				if (pair.key === "background") {
					return pair.value.split(/!important(;)?/ig)[0].trim().split(" ").last();
				}
				return pair.value;
			},
			
			/**
			 * Returns the valid node attribute key for the given css attribute name. 
			 * @param {String} attName
			 * @returns {String}
			 */
			getNodeStyleKey : function(attName) {
				attName = (attName||"").toLowerCase();
				return this._mappedStyles.keys()[this._mappedStyles.values().indexOf(attName)];
			},
			
			/**
			 * Returns a JSON object representing the given style string
			 * @param {String} string The style string
			 * @returns {JSON}
			 */
			getStyleFromString : function(string) {
				var parsedStyle = {};
				if (typeof string === "string" && string.length > 0) {
					// If the style string contains 
					if (!string.endsWith(";")) {
						string += ";";
					}
					string.split(";").each(function(style) {
						if (style.length > 0 && style.indexOf(":") !== -1) {
							var stylePair = style.split(":");
							var key = stylePair[0].trim(), value = stylePair[1].trim();
							parsedStyle[key] = value;	
						}
					});	
				}
				
				return parsedStyle;
			},
			
			/**
			 * Applies style attributes to a string and returns a divString
			 * @param {ORYX.Core.Label} label
			 * @param {String} value
			 * @returns divString
			 */
			applyStyleToPlainText : function(label, value, styles) {
		    	
		    	// if label.style is set, create div string, else return plain value //
		    	
		    	if ("string" === typeof styles) {
		    		var validText = this.getValidLineFeeds(value);
		    		//this.getStyle(label);
		    		return "<div "+ "style='" + styles + "'>" +
		    				validText +
		    				"</div>";
		    	} else {
		    		return value;
		    	}
		    },
		    
		    /**
		     * Returns an array of tspans representing the lines of the given div
		     * @param divString
		     */
		    getTspansFromDiv : function(ownerDocument, divString) {
		    	
		    	if (divString !== "" && ownerDocument) {
		    		var style = divString.split("<div style='")[1].split("'>")[0]; 
		    		
		        	var value = divString.slice(divString.indexOf(">") + 1).split("</div")[0];
		        	value = this.getValidLineFeeds(value);
		        	var lines = value.split(/<br\/>/g);
		        	
		        	return this.createTspans(lines, style, ownerDocument);
		    	}
		    	return [];
		    	
		    },
		    
		    /**
		     * Updates a given divString with the new style attributes
		     * @param {String} label The divString
		     * @param {String} styles The new style attributes
		     * @returns {String} The new divString
		     */
		    updateStylesOnDiv : function(label, styles) {
		    	var divString = label.text(), value;
		    	if (divString !== "") {
		    		value = divString.replace(/<br\/>/g, "\n").stripTags();	
		    		divString = this.applyStyleToPlainText(label, value, styles);
		    	}
		    	label.text(divString);
		    	label.update(true);
		    	return divString;
		    },
		    
		    /**
		     * Applies the given style value to every given line and returns an array of tspans
		     * @param {String[]} lines
		     * @param {String} style
		     * @returns {tspan[]}
		     */
		    createTspans : function(lines, style, ownerDocument) {
		    	return lines.map(function(line) {
	        		var tspan = ownerDocument.createElementNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
	            	tspan.nodeValue = line.trim();
	            	if ("undefined" !== typeof style) {
	            		tspan.setAttributeNS(null, 'style', style);	
	            	}
	            	return tspan;
	        	});
		    },
		    
		    /**
		     * Returns valid xhtml tags for line feeds 
		     * @param {String} value The value to escape
		     * @returns {String}
		     */
		    getValidLineFeeds : function(value) {
		    	return value.replace(/\n/g, "<br/>").replace(/<br>/g, "<br/>");
		    },
		    
		    /**
		     * Returns the hex representation of a color attribute for rgb representations
		     * e.g. rgb(255,33,0) returns #ff3300
		     * @param {String} rgb The RGB-Value
		     * @returns {String}
		     */
		    rgb2hex: function(rgb){
		    	var hex = "#"+(rgb.replace(/[^0-9,]/gi, "").split(",").slice(0,3).map(function(n){
		    					// RGB to HEX
				    			n = Math.max(Math.min(parseInt(n, 10), 255), 0).toString(16);
				    			return (n.length == 1 ? "0" : "") + n;
				    		}).join(""));
		    	
		    	return hex.length == 7 ? hex : rgb;
		    },
		    
		    /**
		     * Returns the name of the given node
		     * @param {HTMLElement} node
		     * @returns {String}
		     */
		    getNodeName: function(node){
		    	var name = String(node && node.nodeName||"").toLowerCase();
		    	if (name && this._nodeMapping[name]){
		    		return this._nodeMapping[name];
		    	}
		    	return name;
		    },
		    
		    /**
		     * Returns a mapped name of the given node name
		     * @param {String} nodeName
		     * @returns {Boolean}
		     */
		    getEncodeNodeName : function(nodeName) {
		    	return this._encodeNodeMapping[nodeName] || nodeName;
		    },
		    
		    /**
		     * Returns the html string representing the richtexted attribute including a preview stub.
		     * @param {String} label The label for classes nstuff 
		     * @param {String} innerText The richtexted text
		     * @param {Number} length The length of the text after which should be the break
		     * @param {Boolean} enablePrint If true renders a link to open the full text in a new window
		     * @returns {String} The String representing the html of the richtexted text
		     */
		    getShortRichtextHtmlFrame : function(label, innerText, maxLength, enablePrint, showPrintButtonWithoutMoreLink, printLabel) {
		    	printLabel = printLabel || Ext.ux.getI18N("richtext.stub.openprint");
		    	var hideMoreLink = showPrintButtonWithoutMoreLink || false;
		    	
		    	if (innerText.stripTags().length < maxLength && hideMoreLink === false) {
		    		return innerText;
		    	} 
		    	
		    	// If the description is too long, create a truncated version and display options to collapse the text
	            else { 
		    	
            		// Create a container to iterate over the DOM elements
			    	var div = document.createElement("div");
			    	div.innerHTML = innerText;
			    	
			    	// Create the container to generate the truncated text
			    	var target = document.createElement("div");
			    	var shortText = innerText;
		            
			    	// Append all nodes while the size of the containing
			    	// text nodes are smaller than the given length.
			    	if (this.truncateTextNodes(div.childNodes, target, {count:maxLength || 500}) === true){
			    		shortText = target.innerHTML + "...";
			    	}
	            	
	            	// Appends the 'more' button
	                if (hideMoreLink === true){
	                	shortText = innerText;
	                }else{
	                	shortText = this.appendHTMLToLastNode(shortText, "<span class='y-richtext-more'>(<a href='#' class='y-toggle-more y-toggle-"+label+"'>"+Ext.ux.getI18N("richtext.stub.more")+"</a>)</span>");
	                }			    	
	                
	                // Return a new HTML structure to display the given text with a preview stub, the full text and buttons to expand
	                return ["<div class='y-richtext-frame y-richtext-frame-"+label+"'>",
	                        	"<div class='y-richtext-short-text y-richtext-short-text-"+label+" y-isCollapsed'>",
	                        		shortText,
	                        		(enablePrint ? [
	                        		"<br/><span class='y-richtext-more-"+label+" y-richtext-more'>",
	                        			"<a href='#' class='y-new-window-link y-window-"+label+"'>"+printLabel+"</a>",
	                        		"</span>"].join('') : ""),
	                        	"</div> ",
	    	    			
	                        	"<div class='y-richtext-content y-richtext-content-"+label+" y-isHidden'>",
	                        		innerText,
	                        		"<span class='y-richtext-more-"+label+" y-richtext-more y-richtext-less'>",
	                        			"(<a href='#' class='y-toggle-less y-toggle-"+label+"'>"+Ext.ux.getI18N("richtext.stub.less")+"</a>)<br/>"+
	                        				(enablePrint ? "<a href='#' class='y-new-window-link y-window-"+label+"'>"+printLabel+"</a>" : ""),
	                        		"</span>",
	                        	"</div>",
	                        "</div>"
	                       ].join("");
	            }
	            
	            // If the text is short enough
	            return innerText;
		    },
		    		    
		    /**
		     * Returns text nodes to generate a stub of the original text with style attributes according to the desired count.
		     * The nodes are prepended to the target.
		     * @param nodes
		     * @param target
		     * @param count
		     * @returns {Boolean} Returns TRUE if the target has been the truncated text, otherwise FALSE
		     */
		    truncateTextNodes : function(nodes, target, count) {
		    	var result = false;
		    	$A(nodes).each(function(node) {
		    		if (node.nodeType === 3) {
		    			if (count.count - this._getTextContent(node).length <= 0) {
		    				result = true;
		    				node.nodeValue = this._getTextContent(node).slice(0, count.count);
		    				target.appendChild(node);
		    				throw $break;
		    			} else {
		    				count.count -= this._getTextContent(node).length;
		    				target.appendChild(node);	
		    			}
		    		} else if (node.nodeType === 1) {
		    			if (this.truncateTextNodes(node.childNodes, target.appendChild(node.cloneNode(false)), count) === true) {
		    				result = true;
		    				throw $break;
		    			};
		    		}
		    	}.bind(this));
		    	return result === true;
		    },
		    
		    /**
		     * Appends the given html snipped to the last child of text snipped
		     * @param text
		     * @param html
		     * @returns
		     */
		    appendHTMLToLastNode: function(text, html){
		    	var node = $j("<div/>").html(text),
		    		cnode = node.get(0),
		    		last = cnode.lastChild;
		    	while (last && 1 == last.nodeType){
		    		last = last.lastChild;
		    	}
		    	if (last){
		    		last.parentNode.innerHTML = last.parentNode.innerHTML+""+html;
		    		return node.html();
		    	} else {
		    		return text+""+html;
		    	}
		    }
	};
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { window.Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if (!Ext.ux.Richtext) {Ext.ux.Richtext = {}; }

new function() {
	Ext.ux.Richtext.Test = {
			/**
			 * Tests for richtext encode / decode functionality.
			 * A sample text and format json object are used to check if the encoder/decoder output matches the expected values.
			 * 
			 * @param {Boolean} verbose Set true for further information on each test
			 */
			encodeDecode : function(verbose) {
				try {
					var ff36textout = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata \nsajdklasjdklasjkldjlakasdasd\nsadasdsajdlkajsdljdaklsjdkla\nsanctus est Lorem ipsum dolor sit amet.\nDuis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. \n\nUt wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. \nNam liber tempor\ncum soluta nobis\neleifend option conguenihil\nimperdiet doming id quo\nmazim placerat facer possim assum.\nLorem ipsum dolor sit amet, consectetuer\nadipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. \n\nDuis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis. \n";
					var ff36formats = [{"from": 0, "to": 26, "tag": "b"}, {"from": 16, "to": 26, "tag": "font", "style": {"color": "#ff0000"}}, {"from": 26, "to": 28, "tag": "font", "style": {"color": "#ff0000"}}, {"from": 28, "to": 255, "tag": "i"}, {"from": 28, "to": 45, "tag": "font", "style": {"color": "#ff0000"}}, {"from": 257, "to": 285, "tag": "h2"}, {"from": 314, "to": 353, "tag": "h1"}, {"from": 353, "to": 770, "tag": "div", "style": {"margin-left": "40px"}}, {"from": 353, "to": 769, "tag": "span", "style": {"background-color": "rgb(255, 255, 0)"}}, {"from": 486, "to": 511, "tag": "font", "style": {"color": "#ff0000"}}, {"from": 503, "to": 511, "tag": "b"}, {"from": 511, "to": 520, "tag": "b"}, {"from": 771, "to": 1171, "tag": "div", "style": {"margin-left": "80px"}}, {"from": 1171, "to": 1253, "tag": "ol"}, {"from": 1171, "to": 1187, "tag": "li"}, {"from": 1187, "to": 1203, "tag": "li"}, {"from": 1203, "to": 1230, "tag": "li"}, {"from": 1230, "to": 1253, "tag": "li"}, {"from": 1253, "to": 1327, "tag": "ul"}, {"from": 1253, "to": 1287, "tag": "li"}, {"from": 1287, "to": 1327, "tag": "li"}];
					var ff36serialDOM = '<b>Lorem ipsum dolo<font color="#ff0000">r sit amet</font></b><font color="#ff0000">, </font><i><font color="#ff0000">consetetur sadips</font>cing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata</i> <br><h2>sajdklasjdklasjkldjlakasdasd</h2>sadasdsajdlkajsdljdaklsjdkla<br><h1>sanctus est Lorem ipsum dolor sit amet.</h1><div style="margin-left: 40px;"><span style="background-color: rgb(255, 255, 0);">Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis <font color="#ff0000">at vero eros et a<b>ccumsan </b></font><b>et iusto </b>odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. </span><br></div><br><div style="margin-left: 80px;">Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. <br></div><ol><li>Nam liber tempor</li><li>cum soluta nobis</li><li>eleifend option conguenihil</li><li>imperdiet doming id quo</li></ol><ul><li>mazim placerat facer possim assum.</li><li>Lorem ipsum dolor sit amet, consectetuer</li></ul>adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. <br><br>Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis. <br>';
					
					
					
					var root = document.createElement("div");
					root.innerHTML = ('<h1>H1</h1>Normal<br /><b>Bold</b><b></b><br /><i>Italic</i><i></i><br /><i></i><i><b>Bold</b></i><br /><b></b><i></i><hr /><u>UNDERLINE</u><br /><font>RED</font><font></font><b><font>RED</font></b><br /><span style="background-color: rgb(255, 153, 0);"><font>HIGHLIGHTTEXT</font></span><br /><font><span style="background-color: rgb(153, 204, 0);">HIGHLIGHTTEXTWITHTEXTCOLOR</span></font><br /><br /><ol><li>geordnete Liste</li></ol><ul><li>ungeordnete Liste</li></ul>');//.replace(/<br>/ig, "<br/>").replace(/<hr([^>]*)>/ig, "<hr$1/>");
					
					var expectedJSONString = '[{"from": 91, "to": 108, "tag": "ul"}, {"from": 91, "to": 108, "tag": "li"}, {"from": 76, "to": 91, "tag": "ol"}, {"from": 76, "to": 91, "tag": "li"}, {"from": 76, "to": 76, "tag": "br"}, {"from": 76, "to": 76, "tag": "br"}, {"from": 50, "to": 76, "tag": "font"}, {"from": 50, "to": 76, "tag": "span", "style": {"background-color": "rgb(153, 204, 0)"}}, {"from": 50, "to": 50, "tag": "br"}, {"from": 37, "to": 50, "tag": "span", "style": {"background-color": "rgb(255, 153, 0)"}}, {"from": 37, "to": 50, "tag": "font"}, {"from": 37, "to": 37, "tag": "br"}, {"from": 34, "to": 37, "tag": "b"}, {"from": 34, "to": 37, "tag": "font"}, {"from": 34, "to": 34, "tag": "font"}, {"from": 31, "to": 34, "tag": "font"}, {"from": 31, "to": 31, "tag": "br"}, {"from": 22, "to": 31, "tag": "u"}, {"from": 22, "to": 22, "tag": "hr"}, {"from": 22, "to": 22, "tag": "i"}, {"from": 22, "to": 22, "tag": "b"}, {"from": 22, "to": 22, "tag": "br"}, {"from": 18, "to": 22, "tag": "i"}, {"from": 18, "to": 22, "tag": "b"}, {"from": 18, "to": 18, "tag": "i"}, {"from": 18, "to": 18, "tag": "br"}, {"from": 18, "to": 18, "tag": "i"}, {"from": 12, "to": 18, "tag": "i"}, {"from": 12, "to": 12, "tag": "br"}, {"from": 12, "to": 12, "tag": "b"}, {"from": 8, "to": 12, "tag": "b"}, {"from": 8, "to": 8, "tag": "br"}, {"from": 0, "to": 2, "tag": "h1"}]';
					var calculated = Ext.ux.Richtext.decode(root);
					var calculatedJSONString = calculated.format.toJSON();
					
					if (expectedJSONString !== calculatedJSONString) {
						console.warn("Calculated JSON String differs from expected JSON String!");
						console.log("expectedJSONString  : ", expectedJSONString);
						console.log("calculatedJSONString: ", calculatedJSONString);
					} else {
						console.info("Calculated JSON String matches expected JSON String");
						if (verbose) console.log("JSONString: ", JSON.parse(expectedJSONString));
					}
					
					var expectedText = "H1NormalBoldItalicBoldUNDERLINEREDREDHIGHLIGHTTEXTHIGHLIGHTTEXTWITHTEXTCOLORgeordnete Listeungeordnete Liste";
					var calculatedText = calculated.text;
					
					if (expectedText !== calculatedText) {
						console.warn("Calculated Text differs from expected Text");
						console.log("expectedText  : ", expectedText);
						console.log("calculatedText: ", calculatedText);
					} else {
						console.info("Calculated Text matches expected Text");
						if (verbose) console.log("Text: ", expectedText);
					}
					
					var expectedNode = root;
					var calculatedNode = document.createElement("div");
					calculatedNode.innerHTML = Ext.ux.Richtext.encode(expectedText, JSON.parse(expectedJSONString));
					
					if (expectedNode.innerHTML.replace(/ xmlns="http:\/\/www.w3.org\/1999\/xhtml"/ig, "") !== calculatedNode.innerHTML.replace(/ xmlns="http:\/\/www.w3.org\/1999\/xhtml"/ig, "")) {
						console.warn("Calculated Node differs from expected Node!");
						console.log("expected node  : ", expectedNode.innerHTML.replace(/ xmlns="http:\/\/www.w3.org\/1999\/xhtml"/ig, ""), expectedNode);
						console.log("calculated node: ", calculatedNode.innerHTML.replace(/ xmlns="http:\/\/www.w3.org\/1999\/xhtml"/ig, ""), calculatedNode);
					} else {
						console.info("Calculated Node matches expected Node");
						if (verbose) console.log(expectedNode, calculatedNode);
					}	
				} catch(e) {
					console.log(e);
					console.log(root.innerHTML);
					console.log(expectedText);
				}
					
			}
	};
}();

/**
 * Class Ext.ux.SlideZone
 * @author Jared Gisin
 * @version $Id: Ext.ux.SlideZone.js 93 2007-12-12 04:41:40Z jaredgisin $
 * @license http://www.opensource.org/licenses/mit-license.php
 * 
 * TODO: make sure slider limits work when snap = 1 or snap < slider width/height
 * TODO: API to dynamically modify the snap 
 * TODO: zone with slider zone responds to click and keypress
 * TODO: API to programatically set slider value with animation
 *
 */

Ext.ux.SlideZone = function(config) {
    Ext.apply(this, config); 
    Ext.ux.SlideZone.superclass.constructor.call(this);
} 

Ext.extend(Ext.ux.SlideZone, Ext.BoxComponent, {
	size: 100,
	sliderSnap: [0],
	type: 'horizontal',
	sliderWidth: 20,
	sliderHeight: 20,
	cls: null,
	minValue: 0,
	maxValue: 100,
	allowSliderCrossing: true,
	value: null,
    defaultAutoCreate : {tag: "div", id: Ext.id() },
    sliders: [],
	  
	onRender: function(ct, position) { 
        //alert('SlideZone onRender');
        Ext.ux.SlideZone.superclass.onRender.call(this,ct,position);
		this.size = this.size instanceof Array ? this.size : [this.size];
		this.minValue = this.minValue instanceof Array ? this.minValue : [this.minValue];
		this.maxValue = this.maxValue instanceof Array ? this.maxValue : [this.maxValue];
		this.sliderSnap = this.sliderSnap instanceof Array ? this.sliderSnap : [this.sliderSnap];

        if(!this.el){
            var cfg = this.getAutoCreate();
            if(!cfg.name){
                cfg.name = this.name || this.id;
            }
            this.el = ct.createChild(cfg, position);
        }
		this.el.addClass('x-slide-zone-' + this.type);
		this.el.addClass(this.cls);
		
		switch(this.type) {
			case 'horizontal':
				this.sliderSize = [this.sliderWidth];
				this.el.applyStyles({width:this.size[0] + 'px'});
				this.el.lowLimit = [this.el.getX()];
				this.el.highLimit = [this.el.getRight()];
				break;
							
			case 'vertical':
				this.sliderSize = [this.sliderHeight]
				this.el.applyStyles({height:this.size[0] + 'px'});
				this.el.lowLimit = [this.el.getY()];
				this.el.highLimit = [this.el.getBottom()];
				break;
							
			case 'area':
				this.sliderSize = [this.sliderWidth, this.sliderHeight];
				this.el.applyStyles({width:this.size[0] + 'px'});
				this.el.applyStyles({height:this.size[1] + 'px'});
				this.el.lowLimit = this.el.getXY();
				this.el.highLimit = [this.el.getRight(), this.el.getBottom()];
				break
		}

		//normalize width/height for slider centering calculations
		var l = this.sliderSize.length;
		for(var i = 0; i < l; i++) {
			this.sliderSize[i] = this.sliderSize[i] % 2 ? this.sliderSize[i] + 1: this.sliderSize[i] 
		}


		var s = this.sliders;
	    this.sliders = new Ext.util.MixedCollection();
	    if(s){
	        this.add.apply(this, s);
	    }

	},

    addSlider: function(slider) {
        this.sliders.push(slider);
    },
	
	add: function(){
		var a = arguments, l = a.length
		for(var i = 0; i < l; i++){
			var el = a[i];
			if (el instanceof Ext.ux.Slider) {
				this.initSlider(el);
				this.sliders.add(el)
			} else if (typeof el == 'object') {
				//initalize new slider and add to the items list
				var s = new Ext.ux.ThumbSlider(el);
				this.initSlider(s);
				this.sliders.add(s)
			}
		}
		this.updateValues();
		this.updateConstraints();
 	},
	
	enableCrossing: function() {
		this.allowSliderCrossing = true;
		this.updateConstraints();
	},
	
	disableCrossing: function() {
		this.allowSliderCrossing = false;
		this.updateConstraints();		
	},
	
	getSlider: function(selector) {
		/* Given a slider index or name, returns a slider object
		 * @selector   slider index|name
		 */
		switch (typeof selector)  {
			case 'number':
				return this.sliders.items[selector];
				break;
				
			case 'string':
				var l = this.sliders.length;
				for(var i = 0; i < l; i++){
					if(this.sliders.items[i].name ==  selector) return this.sliders.items[i];
				}
				break;
		}
	},


	updateConstraints: function() {
		if(!this.allowSliderCrossing && this.sliders.length > 1 && this.type != 'area') {
			// multiple sliders exists and sliders can't cross,
			// so we have to take into account the
			// positions of all sliders
			sortFN = function(a,b){
				var v1 = a.value instanceof Array ? a.value[0] : a.value;
				var v2 = b.value instanceof Array ? b.value[0] : b.value;
	            return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
			}
			this.sliders.sort('asc',sortFN);//put in order by their value
			
			var l = this.sliders.length; 
			for (var i=0; i< l; i++) { //forloop required, as we have to get -1 and +1 slider positions
				var leftTravel = 0, rightTravel = 0;
				var sliderL = this.sliders.get(i-1);
				var slider = this.sliders.get(i);
				var sliderR = this.sliders.get(i+1);

				
				if (sliderL && sliderR) {
					if (sliderL instanceof Ext.ux.ThumbSlider) {
						var leftTravel = slider.getTL()[0] - sliderL.getTL()[0] - this.sliderSnap[0];
					}
					if (sliderL instanceof Ext.ux.RangeSlider) {
						var leftTravel = slider.getTL()[0] - sliderL.getBR()[0] - this.sliderSnap[0];					
					}
					if (sliderR instanceof Ext.ux.ThumbSlider) {
						var rightTravel = sliderR.getTL()[0] - slider.getTL()[0] - this.sliderSnap[0];	
					}
					if (sliderR instanceof Ext.ux.RangeSlider) {
						var rightTravel = sliderR.getTL()[0] - slider.getBR()[0] - this.sliderSnap[0] ;							
					}
				} else if(sliderL) {
					if (sliderL instanceof Ext.ux.ThumbSlider) {
						var rightTravel = this.el.highLimit[0] - slider.getTL()[0] - ( 0.5 * this.sliderSize[0]) ;	
						var leftTravel = slider.getTL()[0] - sliderL.getTL()[0] - this.sliderSnap[0];
					}
					if (sliderL instanceof Ext.ux.RangeSlider) {
						var rightTravel = this.el.highLimit[0] - slider.getBR()[0];	
						var leftTravel = slider.getTL()[0] - sliderL.getBR()[0] - this.sliderSnap[0];
					}
				} else if(sliderR) {
					if (sliderR instanceof Ext.ux.ThumbSlider) {
						var leftTravel = slider.getTL()[0] - this.el.lowLimit[0] + ( 0.5 * this.sliderSize[0]);
						var rightTravel = sliderR.getTL()[0] - slider.getTL()[0] - this.sliderSnap[0] ;
					}
					if (sliderR instanceof Ext.ux.RangeSlider) {
						var leftTravel = slider.getTL()[0] - this.el.lowLimit[0];
						var rightTravel = sliderR.getTL()[0] - slider.getBR()[0] - this.sliderSnap[0] ;					
					}
				}
				if(slider instanceof Ext.ux.RangeSlider) {
					slider.resizable.leftTravel = [leftTravel];
					slider.resizable.rightTravel = [rightTravel];
				}
				slider.setConstraint([leftTravel], [rightTravel], this.sliderSnap);
			}
		} else {
			var l = this.sliders.length;
			for (var i=0; i< l; i++) {
				var slider = this.sliders.get(i);
				if (slider instanceof Ext.ux.ThumbSlider ) {
					slider.setConstraint([slider.getTL()[0]-this.el.lowLimit[0]  + ( 1/2 * this.sliderSize[0]),
										  slider.getTL()[1]-this.el.lowLimit[1]  + ( 1/2 * this.sliderSize[1])], 
								[this.el.highLimit[0]- (slider.getTL()[0] + this.sliderSize[0]) + ( 1/2 * this.sliderSize[0]),
								 this.el.highLimit[1]- (slider.getTL()[1] + this.sliderSize[1]) + ( 1/2 * this.sliderSize[1]) ],
								this.sliderSnap)
				}
				if (slider instanceof Ext.ux.RangeSlider) {
					slider.setConstraint([slider.getTL()[0] - this.el.lowLimit[0],
										  slider.getTL()[1] - this.el.lowLimit[1]], 
								[this.el.highLimit[0] - slider.getBR()[0],
								 this.el.highLimit[1] - slider.getBR()[1] ],
								this.sliderSnap)				
				}
			}
		}
	},
	
	updateValues: function() {
		var that = this;
		var vals = {};
		this.sliders.each(function(i) {

			if(this.type == 'area') {
				if (i instanceof Ext.ux.ThumbSlider) {
					i.value = [(i.getTL()[0] + 1/2 * that.sliderSize[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0],
							   (i.getTL()[1] + 1/2 * that.sliderSize[1] - that.el.lowLimit[1]) / (that.size[1]) * (that.maxValue[1] - that.minValue[1]) + that.minValue[1]];
					i.percent = [parseFloat((i.getTL()[0]  + 1/2 * that.sliderSize[0] - that.el.lowLimit[0]) / (that.size[0]) * 100),
								 parseFloat((i.getTL()[1]  + 1/2 * that.sliderSize[1] - that.el.lowLimit[1]) / (that.size[1]) * 100)];
				} 
				if (i instanceof Ext.ux.RangeSlider) {
					i.value = [[
								(i.getTL()[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0],
							    (i.getBR()[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0]


							   ],[
								(i.getTL()[1]  - that.el.lowLimit[1]) / (that.size[1]) * (that.maxValue[1] - that.minValue[1]) + that.minValue[1],
							    (i.getBR()[1]  - that.el.lowLimit[1]) / (that.size[1]) * (that.maxValue[1] - that.minValue[1]) + that.minValue[1]
							   ]];
					i.percent = [[
								  parseFloat((i.getTL()[0] - that.el.lowLimit[0]) / (that.size[0]) * 100).toFixed(2),
								  parseFloat((i.getBR()[0] - that.el.lowLimit[0]) / (that.size[0]) * 100).toFixed(2)
								],[
								  parseFloat((i.getTL()[1] - that.el.lowLimit[1]) / (that.size[1]) * 100).toFixed(2),
								  parseFloat((i.getBR()[1] - that.el.lowLimit[1]) / (that.size[1]) * 100).toFixed(2)
								 ]];
				}
			} else {
				if (i instanceof Ext.ux.ThumbSlider) {
					i.value = (i.getTL()[0] + 1/2 * that.sliderSize[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0];
					i.percent = parseFloat((i.getTL()[0]  + 1/2 * that.sliderSize[0] - that.el.lowLimit[0]) / (that.size[0]) * 100);
				} 
				if (i instanceof Ext.ux.RangeSlider) {
					i.value =  [(i.getTL()[0]  - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0],
							   (i.getBR()[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0]];
					i.percent = [  parseFloat((i.getTL()[0]  - that.el.lowLimit[0]) / (that.size[0]) * 100),
								   parseFloat((i.getBR()[0] - that.el.lowLimit[0]) / (that.size[0]) * 100)];	
				}
			}
			vals[this.name] = this.value;
		});

		this.value = vals;
	},
	
	initSliderPosition: function(slider) {
		/* Sets a sliders's initial position within the slide zone.
		 * If slideZone has a sliderSnap set, the slider 
		 * is positioned at a multiple of the sliderSnap value that is
		 * closest where the slider's value would otherwise position it.
		 * After positioning, the slider's actual value will be modified
		 * in Ext.ux.SlideZone.updateValues()
		 * to jibe with the actual position in the slide zone given the 
		 * sliderSnap constraint.
		 */
		var initialPosition = [0,0];
		slider.repositionDelta = [0,0];
		var l = this.type == 'area' ? 2 : 1;
		for(var i=0; i < l; i++ ) {
			/* Make sure initial value is in slider bar range, 
			   if it's outside, set to closest limit.
			   The slider value is modified if it's out of range. */
			if(slider.value instanceof Array) {
				if (slider instanceof Ext.ux.ThumbSlider) {

					slider.value[i] = Number(slider.value[i]).constrain(this.minValue[i], this.maxValue[i]);
					initialPosition[i] = parseInt((slider.value[i] - this.minValue[i]) / (this.maxValue[i] - this.minValue[i]) * this.size[i] + this.el.lowLimit[i]);
				}
				if (slider instanceof Ext.ux.RangeSlider) {
					switch (this.type) {
						case 'horizontal':
						case 'vertical':
							slider.value[i] = Number(slider.value[i]).constrain(this.minValue[i], this.maxValue[i]);
							initialPosition[i] = parseInt((slider.value[i] - this.minValue[i]) / (this.maxValue[i] - this.minValue[i]) * this.size[i] + this.el.lowLimit[i]);
							break;
						
						case 'area':
							slider.value[i][0] = Number(slider.value[i][0]).constrain(this.minValue[i], this.maxValue[i]);
							slider.value[i][1] = Number(slider.value[i][1]).constrain(this.minValue[i], this.maxValue[i]);
							
							initialPosition[i] = parseInt((slider.value[i][0] - this.minValue[i]) / (this.maxValue[i] - this.minValue[i]) * this.size[i] + this.el.lowLimit[i]);

							break;
					}
				}
			} else {
				slider.value = Number(slider.value).constrain(this.minValue[i], this.maxValue[i]);
				initialPosition[i] = parseInt((slider.value - this.minValue[i]) / (this.maxValue[i] - this.minValue[i]) * this.size[i] + this.el.lowLimit[i]);
			}
			
			/* Calculate slider value versus closest snap-to location,
			   and calculate an offset value to apply when positioning it. */
			if (this.sliderSnap[i] > 1) {
				var positionToSnapDiff = [0,0];
				positionToSnapDiff[i] = (initialPosition[i] - this.el.lowLimit[i]) % this.sliderSnap[i];
				if (positionToSnapDiff[i]) {
					if(positionToSnapDiff[i] < 1/2 * this.sliderSnap[i]) {
						slider.repositionDelta[i] = -positionToSnapDiff[i];
					} else {
						slider.repositionDelta[i] = this.sliderSnap[i] - positionToSnapDiff[i];
					} 
				}
			} 
		}

		if (slider instanceof Ext.ux.ThumbSlider) {
			slider.setPosition([initialPosition[0] + slider.repositionDelta[0] - (0.5 * this.sliderSize[0]),
								initialPosition[1] + slider.repositionDelta[1] - (0.5 * this.sliderSize[1])]);
		}
		if (slider instanceof Ext.ux.RangeSlider) {

			slider.setPosition([initialPosition[0] + slider.repositionDelta[0],
								initialPosition[1] + slider.repositionDelta[1]]);
		}
	},
	
	initSlider: function(slider) {		
		slider.init(this);
		this.initSliderPosition(slider);
	} 

});  


Ext.ux.Slider = function(config) {

	Ext.apply(this, config);
	
	this.addEvents( {
		"dragstart" : true,
		"dragend" : true,
		"drag" : true,
		"mouseover":true, 
		"mouseout":true
	});	
    Ext.ux.Slider.superclass.constructor.call(this);
}

Ext.extend(Ext.ux.Slider, Ext.BoxComponent, {
	value: 0,
	ddEl: null,
	name: null,
	cls: null,
	
	init: function() {
		//Do nothing
	},

	getTL: function() {
		switch(this.type) {
			case 'horizontal':
				return [this.el.getX()];
				break;
				
			case 'vertical':
				return [this.el.getY()];
				break;
				
			case 'area':
				return this.el.getXY();
				break;
		}
	},
	
	getBR: function() {
		switch(this.type) {
			case 'horizontal':
				return [this.el.getRight()];
				break;
				
			case 'vertical':
				return [this.el.getBottom()];
				break;
				
			case 'area':
				return [this.el.getRight(), this.el.getBottom()];
				break;
		}
		
	},
	
	setPosition: function(position) {
		var l = position.length;
		for (i=0; i<l; i++) {
			position[i] = parseInt(position[i]);
		}

		switch(this.type) {
			case 'horizontal':
				this.el.setX(position[0]);
				break;
				
			case 'vertical':
				this.el.setY(position[0]);
				break;
				
			case 'area':
				this.el.setX(position[0]);
				this.el.setY(position[1]);
				break;
		}		
	},
	
	setConstraint: function(low, high, snap) {
		var l = low.length;
		for (i=0; i<l; i++) {
			low[i] = parseInt(low[i] = low[i] < 0 ? 0 : low[i]);
			high[i] = parseInt(high[i] = high[i] < 0 ? 0 : high[i]);				
		}


		switch(this.type) {
			case 'horizontal':
				this.ddEl.setXConstraint(low[0], high[0], snap[0]);
				this.ddEl.setYConstraint(0, 0);
				break;
				
			case 'vertical':
				this.ddEl.clearConstraints();
				this.ddEl.setXConstraint(0, 0);
				this.ddEl.setYConstraint(low[0], high[0], snap[0]);
				break;
				
			case 'area':
				this.ddEl.setXConstraint(low[0], high[0], snap[0]);
				this.ddEl.setYConstraint(low[1], high[1], snap[1]);
				break;
		}		
		this.ddEl.resetConstraints(true);
	}
	

});

Ext.ux.ThumbSlider = function(config) { 
    Ext.apply(this,config);
	Ext.ux.ThumbSlider.superclass.constructor.call(this, config);	
};


Ext.ux.RangeSlider = function(config) {
	Ext.apply(this,config);
	Ext.ux.RangeSlider.superclass.constructor.call(this, config);	
};

Ext.extend(Ext.ux.ThumbSlider, Ext.ux.Slider, {

	//init must be passed an instance of a SliderZone
	init: function(parentSlideZone) {
		this.type = parentSlideZone.type;

		this.pointer = this.type == 'horizontal' ? 'w-resize' : this.type == 'vertical' ? 'n-resize' : 'move';
		
		this.el = Ext.DomHelper.append(parentSlideZone.el,  { 
						tag: 'div', 
						id: Ext.id(),
						style: 'position:absolute;'+
								'overflow: hidden;'
								}, true);
		this.el.addClass('x-thumb-slider-' + this.type);
		this.el.addClass(parentSlideZone.cls);

		this.ddEl = new Ext.dd.DD(this.el); 

		var sliderInstance = this;
		var slideZoneInstance = parentSlideZone;

		this.el.on('mouseover', function() {
			sliderInstance.fireEvent('mouseover', sliderInstance);
			sliderInstance.el.setStyle('cursor', sliderInstance.pointer); 
		}); 
		this.el.on('mouseout', function() { 
			sliderInstance.fireEvent('mouseout', sliderInstance);
			sliderInstance.el.setStyle('cursor', 'default'); 
		}); 
		this.ddEl.onMouseDown = function(x, y) { 
			sliderInstance.fireEvent('dragstart', sliderInstance);
		}; 
		this.ddEl.onMouseUp = function(x, y) { 
			slideZoneInstance.updateConstraints();
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('dragend', sliderInstance)
		}; 
		this.ddEl.onDrag = function(e) { 
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('drag', sliderInstance);
		}; 

		Ext.ux.ThumbSlider.superclass.init.call(parentSlideZone);
	}
});

Ext.extend(Ext.ux.RangeSlider, Ext.ux.Slider, {
	init: function(parentSlideZone) {
		this.type = parentSlideZone.type;
		
		var el = Ext.DomHelper.append(parentSlideZone.el,  { 
						tag: 'div', 
						id: Ext.id(),
						style: 'position:absolute;'+
								'overflow: hidden;'
								}, true);

		//this.el.addClass(parentSlideZone.cls);
		switch(this.type) {
			case 'horizontal':
				var w = Math.abs(this.value[0] - this.value[1]) / (parentSlideZone.maxValue - parentSlideZone.minValue) * parentSlideZone.size;
				var h = parentSlideZone.sliderHeight;
				var handles = 'e,w';
				this.pointer = 'w-resize';
				break;
				
			case 'vertical':
				var w = parentSlideZone.sliderWidth;
				var h = Math.abs(this.value[0] - this.value[1]) / (parentSlideZone.maxValue - parentSlideZone.minValue) * parentSlideZone.size;
				var handles = 'n,s';
				this.pointer = 'n-resize';
				break;
				
			case 'area':
				var w = Math.abs(this.value[0][0] - this.value[0][1]) / (parentSlideZone.maxValue[0] - parentSlideZone.minValue[0]) * parentSlideZone.size[0];
				var h = Math.abs(this.value[1][0] - this.value[1][1]) / (parentSlideZone.maxValue[1] - parentSlideZone.minValue[1]) * parentSlideZone.size[1];
				var handles = 'all';
				this.pointer = 'move';
				break;
		}

		this.resizable = new Ext.Resizable(el, {
			wrap:false,
			pinned:true, 
			width: w,
			height: h,
			minWidth: 20,
			widthIncrement: parentSlideZone.sliderSnap[0],
			heightIncrement: parentSlideZone.sliderSnap[1],
			minHeight: 20,
			dynamic: true,
			handles: handles,
			draggable: true,
			transparent: false,
			constrainTo: parentSlideZone.el,
			leftTravel: null,
			rightTravel: null
		});
		var sliderInstance = this;
		var slideZoneInstance = parentSlideZone;
		
		this.el = this.resizable.el;
		this.el.addClass('x-range-slider-' + this.type);
		this.el.addClass(this.cls);		
		this.ddEl = this.resizable.dd;
		

		this.resizable.on('beforeresize', function() {
			sliderInstance.fireEvent('dragstart', sliderInstance);	
		})
		
		/* Parts of this.resizable.onMouseMove handler taken from:
		 * http://extjs.com/forum/showthread.php?p=23122&highlight=resizable+constrainto#post23122
		 */
		this.resizable.onMouseMove = function( e ) {
				var box = this.constrainTo.getRegion(), tgt = e.getXY();
				//redefine the constraining box if slider crossing resrictions
				if(!parentSlideZone.allowSliderCrossing) {
					if( parentSlideZone.type == 'vertical') {
							box = {left:   box.left,  right:  box.right,
								   top:    this.startBox.y - this.leftTravel[0],
								   bottom: this.startBox.y + this.startBox.height + this.rightTravel[0] }
					}
					if( parentSlideZone.type == 'horizontal') {
							box = {left:   this.startBox.x - this.leftTravel[0],
								   right:  this.startBox.x + this.startBox.width + this.rightTravel[0],
								   top:    box.top, bottom: box.bottom }
					}
				}

				e.xy = [
					tgt[0] - box.left < 0 ? box.left - this.startBox.x + this.startPoint[0] : tgt[0] - box.right > 0 ? box.right - this.startBox.right + this.startPoint[0] : tgt[0],
					tgt[1] - box.top < 0 ? box.top - this.startBox.y + this.startPoint[1] : tgt[1] - box.bottom > 0 ? box.bottom - this.startBox.bottom + this.startPoint[1] : tgt[1]
				];

				Ext.Resizable.prototype.onMouseMove.call(this, e);
				slideZoneInstance.updateValues();
				sliderInstance.fireEvent('drag', sliderInstance);
			};
			
		this.resizable.on('resize', function(width, height) {
			slideZoneInstance.updateConstraints();
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('dragend', sliderInstance);
		})
		
		this.el.on('mouseover', function() {
			sliderInstance.fireEvent('mouseover', sliderInstance);
			sliderInstance.el.setStyle('cursor', sliderInstance.pointer); 
		}); 
		this.el.on('mouseout', function() { 
			sliderInstance.fireEvent('mouseout', sliderInstance);
			sliderInstance.el.setStyle('cursor', 'default'); 
		}); 
		this.ddEl.onMouseDown = function(x, y) { 
			sliderInstance.fireEvent('dragstart', sliderInstance);
		}; 
		this.ddEl.onMouseUp = function(x, y) { 
			slideZoneInstance.updateConstraints();
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('dragend', sliderInstance)
		}; 
		this.ddEl.onDrag = function(e) { 
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('drag', sliderInstance);
		}; 

		Ext.ux.ThumbSlider.superclass.init.call(parentSlideZone);

	}
});

/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }

new function(){
	
	/**
	 * Class for a generic paging Toolbar. Forced loading callbacks to submit
	 * query and avoid caching from store, as used in the analytics project.
	 * 
	 */
	Ext.ux.PagingToolbar = function(config){
		Ext.ux.PagingToolbar.superclass.constructor.call(this, config);	    
	};

	Ext.extend(Ext.ux.PagingToolbar, Ext.PagingToolbar, {
		/**
		 * Retrieves the total number of items from the first result of the store.
		 */
//		initComponent : function(){
//	        // VARs
//			var fn, payloadPages;
//			
//			Ext.ux.PagingToolbar.superclass.initComponent.call(this);
//			
//	        fn = function(record) {
//	        	return record.data.rel == "payloadPages";
//	        };
//	        
//	        this.store.clearFilter(true);
//	        payloadPages = this.store.queryBy(fn);
//	        
//	        if(payloadPages) {
//	        	this.totalItemCount = payloadPages.data.rep.totalNumberValues;
//	        }
//	        
//	        this.store.resetFilter();
//	    },
		
		
		/**
		 * Retrieves the total number of items from the first result of the store.
		 */
		onLoad: function(store, r, o) {
			// VARs
			var fn, payloadPages;
			
//			if(this.totalItemCount) {
				fn = function(record) {
		        	return record.data.rel == "payloadPages";
		        };
		        
		        this.store.clearFilter(true);
		        payloadPages = this.store.queryBy(fn);
		        
		        if(payloadPages && payloadPages.items.length > 0) {
		        	this.totalItemCount = payloadPages.items[0].data.rep.totalNumberValues;
		        }
		        
		        this.store.resetFilter();
//			}
			
//			Ext.ux.PagingToolbar.superclass.onLoad.apply(this, arguments);
			
			if(!this.rendered){
	            this.dsLoaded = [store, r, o];
	            return;
	        }
			this.cursor = o.params ? o.params[this.paramNames.start] : 0;
			var d = this.getPageData(), ap = d.activePage, ps = d.pages;
			
			this.afterTextEl.el.innerHTML = String.format(this.afterPageText, d.pages);
			this.beforeTextEl.el.innerHTML = String.format(this.beforePageText, ap);
			this.first.setDisabled(ap <= 1);
			this.prev.setDisabled(ap <= 1);
			this.next.setDisabled(ap >= ps);
			this.last.setDisabled(ap >= ps);
			this.loading.enable();
			this.updateInfo();
		},
		
		// private
	    updateInfo : function(){
	        if(this.displayEl){
	            var count = this.store.getCount();
	            var msg = count == 0 ?
	                this.emptyMsg :
	                String.format(
	                    this.displayMsg,
	                    this.cursor+1, this.cursor+count, this.totalItemCount||this.store.getTotalCount()
	                );
	            this.displayEl.update(msg);
	        }
	    },
		
	    /**
	     * Calculate paging toolbar metrics.
	     */
		// private
	    getPageData : function(){
	        var total = (this.totalItemCount||this.store.getTotalCount());
	        return {
	            total : total,
	            activePage : Math.ceil((this.cursor+this.pageSize)/this.pageSize),
	            pages :  total < this.pageSize ? 1 : Math.ceil(total/this.pageSize)
	        };
	    },
	    
	    // private
	    /**
	     * Renders the customized paging toolbar.
	     */
	    onRender : function(ct, position){
	        Ext.PagingToolbar.superclass.onRender.call(this, ct, position);
	        this.first = this.addButton({
	            tooltip: this.firstText,
	            iconCls: "x-tbar-page-first",
	            disabled: true,
	            handler: this.onClick.createDelegate(this, ["first"])
	        });
	        this.prev = this.addButton({
	            tooltip: this.prevText,
	            iconCls: "x-tbar-page-prev",
	            disabled: true,
	            handler: this.onClick.createDelegate(this, ["prev"])
	        });
	        this.addSeparator();
	        this.beforeTextEl = this.addText(String.format(this.beforePageText, 1));
	        this.afterTextEl = this.addText(String.format(this.afterPageText, 1));
	        this.addSeparator();
	        this.next = this.addButton({
	            tooltip: this.nextText,
	            iconCls: "x-tbar-page-next",
	            disabled: true,
	            handler: this.onClick.createDelegate(this, ["next"])
	        });
	        this.last = this.addButton({
	            tooltip: this.lastText,
	            iconCls: "x-tbar-page-last",
	            disabled: true,
	            handler: this.onClick.createDelegate(this, ["last"])
	        });
	        this.addSeparator();
	        this.loading = this.addButton({
	            tooltip: this.refreshText,
	            iconCls: "x-tbar-loading",
	            handler: this.onClick.createDelegate(this, ["refresh"])
	        });

	        if(this.displayInfo){
	            this.displayEl = Ext.fly(this.el.dom).createChild({cls:'x-paging-info'});
	        }
	        if(this.dsLoaded){
	            this.onLoad.apply(this, this.dsLoaded);
	        }
	    }
	});
}();/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" === typeof window.Ext){ window.Ext = {}; }
if ("undefined" === typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" === typeof Ext.ux.Toolbar){ Ext.ux.Toolbar = {}; }

new function(){
	
	/**
	 * Class for a generic toggle Button. Provides functionality to prevent the button from being enabled/disabled
	 * 
	 */
	Ext.ux.Toolbar.Button = function(config){
		Ext.ux.Toolbar.Button.superclass.constructor.call(this, config);	    
	};
	
	
	Ext.extend(Ext.ux.Toolbar.Button, Ext.Toolbar.Button, {
		/**
		 * @cfg {Boolean} preventFromDisable
		 * If set to true, the Button can't be disabled.
		 */
		preventFromDisable  : false,
		
		/**
		 * @cfg {Boolean} preventFromEnable
		 * If set to true, the Button can't be enabled.
		 */
		preventFromEnable	: false,
		
		/**
		 * Set true to prevent the button from being disabled
		 * @param {Boolean} prevent
		 */
		setPreventFromDisable : function(prevent) {
			this.preventFromDisable = prevent;
		},
		
		/**
		 * Set true to prevent the button from being enabled
		 * @param {Boolean} prevent
		 */
		setPreventFromEnable : function(prevent) {
			this.preventFromEnable = prevent;
		},
		
		/**
		 * Convenient method to check if the button can be disabled.
		 * @returns {Boolean}
		 */
		getPreventFromDisable : function() {
			return this.preventFromDisable;
		},		
		
		/**
		 * Convenient method to check if the button can be enabled.
		 * @returns {Boolean}
		 */
		getPreventFromEnable : function() {
			return this.preventFromEnable;
		},		
		
		/**
	     * Convenient function for setting disabled/enabled by boolean. If preventFromDisable is true, it is not
	     * possible to disable the button.
	     * @override
	     * @param {Boolean} disabled
	     */
	    setDisabled : function(disabled){
        	this[disabled && !this.preventFromDisable ? "disable" : "enable"]();
	    },
	    
	    /**
	     * Disables the button if it's not forbidden
	     * @returns {Ext.ux.Toolbar.Button} this
	     */
	    disable : function() {
	    	if (!this.preventFromDisable) {
		    	if(this.rendered){
		            this.onDisable();
		        }
		        this.disabled = true;
		        this.fireEvent("disable", this);
	    	} 
	        return this;

	    },
	    
	    /**
	     * Enables the button if it's not forbidden
	     * @returns {Ext.ux.Toolbar.Button} this
	     */
	    enable : function() {
	    	if (!this.preventFromEnable) {
	    		if(this.rendered){
		            this.onEnable();
		        }
		        this.disabled = false;
		        this.fireEvent("enable", this);
	    	}
	    	return this;
	    }
    });
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" === typeof window.Ext){ window.Ext = {}; }
if ("undefined" === typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" === typeof Ext.ux.Toolbar){ Ext.ux.Toolbar = {}; }

new function(){
	
	/**
	 * Class for a generic Button displaying a horizontal Menu on click.
	 * 
	 */
	Ext.ux.Toolbar.HorizontalMenu = function(config){
		Ext.ux.Toolbar.HorizontalMenu.superclass.constructor.call(this, config);	    
	};

	Ext.extend(Ext.ux.Toolbar.HorizontalMenu, Ext.Toolbar, {
		items	: [],
		buttons	: [],
		
		enableButtons: function(elements) {
			// Show the Buttons
			this.buttons.each((function(value){
				if (!value.buttonInstance){ // Check if there is a button
					return;
				}
				
				// Enable the button
				value.buttonInstance.enable();
							
				// If there is less elements than minShapes
				if(value.minShape && value.minShape > elements.length)
					value.buttonInstance.disable();
				// If there is more elements than minShapes
				if(value.maxShape && value.maxShape < elements.length)
					value.buttonInstance.disable();	
				// If the plugin is not enabled	
				if(value.isEnabled && !value.isEnabled(value.buttonInstance))
					value.buttonInstance.disable();
				
			}).bind(this));		
		},
		
		onSelectionChanged: function(event) {
			this.enableButtons(event.elements);
		}
	});
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" === typeof window.Ext){ window.Ext = {}; }
if ("undefined" === typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" === typeof Ext.ux.Toolbar){ Ext.ux.Toolbar = {}; }

new function(){
	
	/**
	 * Class for a generic Button displaying a horizontal Menu on click.
	 * 
	 */
	Ext.ux.Toolbar.HorizontalMenuButton = function(config){
		
		this.menuConfig = {
			menuItems		: config.menuConfig.menuItems || []
		};
		
		this.menuConfig.cls += ' y-horizontal-menu-invisible-render-point ' + this.menuConfig.alignCls;
		Ext.ux.Toolbar.HorizontalMenuButton.superclass.constructor.call(this, config);	    
	};
	
	Ext.extend(Ext.ux.Toolbar.HorizontalMenuButton, Ext.Toolbar.SplitButton, {
		listeners	: {
				click	: function(button, event) {
					button.toggle();
				}.bind(this),
				arrowclick : function(button, event) {
					button.toggle();
				}
		},

		/**
		 * Creates a new Ext.ux.Toolbar.HorizontalMenu and renders it to the position of a given button.
		 * @param {Ext.ux.Toolbar.Button} button
		 * @param {Object} cfg The config object
		 */
		initToolbar : function(button, cfg) {
			// The config for the horizontal menu
			
			// Create the toolbar
			button.toolbar = new Ext.ux.Toolbar.HorizontalMenu(cfg);
			cfg.toolbar = button.toolbar;
			
			// Create the overlay to visually connect the button and the toolbar
			var overlay = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", undefined, ["div", {"class":'y-richtext-toolbar-button-expanded-overlay'+(Ext.isIPad ? 'y-richtext-toolbar-button-expanded-overlay-ipad': '')}]);
            button.overlay = overlay;
            
            var flyOver = Ext.fly(overlay);
            flyOver.setWidth(button.el.getWidth());
            
			// Render the toolbar
			button.toolbar.render(button.el.parent('div.x-panel-body'));
			
			
			this.addMenuButtons(cfg.menuItems);
	    	
			button.toolbar.enableButtons([]);
			
			button.toolbar.el.removeClass('y-horizontal-menu-invisible-render-point');
			
			// Align it to the given button position
			button.toolbar.el.alignTo(button.el, 'bl', (Ext.isIPad ? [0,-4] : [0, 2]), false);
			
			// Add the overlay
			button.toolbar.el.parent().appendChild(overlay);
			flyOver.alignTo(button.el, cfg.alignPosition, [0, (Ext.isIPad ? -3 : -2)], cfg.animate);
		},
		
		/**
		 * Adds an item (Button, ComboBox, etc.) to the given horizontal menu for each given itemConfig 
		 * @param {Array} menuItems Containing configuration for each menu item to add.
		 */
		addMenuButtons : function(menuItems) {
	    	if (!menuItems || menuItems.length === 0) {
	    		return;
	    	}
	    	
	    	this.splitButtons = [];
	    	
	    	menuItems.each(function(value) {
	    		if(!value.name) {
	    			return;
	    		}
	    		
	    		/*
	    		 * If an drop down group icon is provided, a split button should be used.
	    		 */
	            if(value.dropDownGroupIcon) {
	            	var splitButton = this.splitButtons[value.dropDownGroupIcon];
	            	if (!splitButton) {
	            		splitButton = this.createNewSplitButton(value);
	            		this.toolbar.add(splitButton);
	            	}
                    
	                // General config button which will be used either to create a normal button
                    // or a check button (if toggling is enabled)
                    var buttonCfg = {
                        icon		: value.icon,
                        text		: value.name,
                        itemId		: value.id,
                        cls			: "x-"+String(value.group.gsub("\\.", "")).toLowerCase(),
                        handler		: value.toggle ? undefined : value.functionality,
                        checkHandler: value.toggle ? value.functionality : undefined,
                        splitButton	: splitButton,
                        toggleGroup	: value.toggleGroup,
                        listeners	: {
                            render: function(item){
                                // After rendering, a tool tip should be added to component
                                if (value.description) {
                                    new Ext.ToolTip({
                                        target	: item.getEl(),
                                        title	: value.description
                                    });
                                }
                            }
                        }
                    };
                    
                    if ("string" === typeof value.style){
                    	buttonCfg.style = value.style;
                    }
                    
                    // Create buttons depending on toggle
                    if(value.toggle) {
                        var button = new Ext.menu.CheckItem(buttonCfg);
                    } else {
                        var button = new Ext.menu.Item(buttonCfg);
                    }
                    
                    splitButton.menu.add(button);
	            }
	            // If a fill area is desired, add fill
	            else if(value.addFill) {
					this.toolbar.addFill();
				}
					
				// If the item to add to the toolbar is a ComboBox
	            else if (value.comboBox instanceof Function) {
					var combo = value.comboBox();
					this.toolbar.addField(combo);
					
				}
		        // create normal, simple button
	            else {
					var icon = value.icon.split('/').length === 4 ? value.icon.replace('/editor/images/', Ext.IMAGE_URL+'/famfamfam/') : value.icon;
					
					var button = new Ext.ux.Toolbar.Button({
	                    icon:           icon,         // icons can also be specified inline
	                    cls:            'x-btn-icon',       // Class who shows only the icon
	                    itemId:         value.id,
						tooltip:        value.description,  // Set the tooltip
	                    tooltipType:    'title',            // Tooltip will be shown as in the html-title attribute
	                    handler:        value.toggle ? null : value.functionality,  // Handler for mouse click
	                    enableToggle:   value.toggle, // Option for enabling toggling
	                    toggleGroup:	value.toggleGroup,
	                    toggleHandler:  value.toggle ? value.functionality : null // Handler for toggle (Parameters: button, active)
	                }); 
	                
					this.toolbar.add(button);	
					
	                button.getEl().onclick = function() {this.blur();};
	            }
				
	        	value['buttonInstance'] = value.isComboBox ? combo : button;
	        	this.toolbar.buttons.push(value);
	    	}.bind(this));
	    },
	    
	    /**
	     * Creates a new Ext.Toolbar.SplitButton for a given item
	     * @param {Object} item The configuration for the split button
	     */
	    createNewSplitButton : function(item) {
    		var button = new Ext.Toolbar.SplitButton({
                cls			: "x-btn-icon",
                icon		: Ext.isIPad ? item.dropDownGroupIcon.replace('/famfamfam/', '/famfamfam/32x32/') : item.dropDownGroupIcon,
                menu		: new Ext.menu.Menu({
                    			items: [] // items are added later on
                			}),
                listeners	: {
                  click	: function(button, event){
                            // The "normal" button should behave like the arrow button
                            if(!button.menu.isVisible() && !button.ignoreNextClick){
                                button.showMenu();
                            } else {
                                button.hideMenu();
                            }
                  } 
                }
            });
    		
    		this.splitButtons[item.dropDownGroupIcon] = button;
	    }
	});
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *
 *	This code is proprietary software within the 
 * 	company Signavio GmbH.
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.view){ Ext.ux.view = {} }

new function(){
	
	/**
	 * A PDF Export window for exporting views of a selected diargam 
	 * 
	 * @class Ext.ux.view.PdfExportWindow
	 */
	Ext.ux.view.PdfExportWindow = function(views, modelId, data, facade, sel){
		this.sel = sel;
		this.views = views;
		this.modelId = modelId;
		this.data = data;
		this.facade = facade;
		this.signavioBranding = undefined;
		
		Ext.ux.view.PdfExportWindow.superclass.constructor.apply(this, [{}]);
		this.show();
	}

	Ext.extend(Ext.ux.view.PdfExportWindow, Ext.Window, {
		resizable	: false,
		minimizable	: false,
		modal		: true,
		width		: 345,
		title		: Ext.ux.getI18N("views.offerTitle"),
		bodyStyle	: "background-color:white;",
		buttons		: [
						{
				        	text: Ext.ux.getI18N("views.buttonTitle"),
				        	handler: function(){
								this.ownerCt.onSubmit()
								this.ownerCt.close()
							}
				    	},
				    	{
				    		text : Ext.ux.getI18N("views.closeTitle"),
				    		handler : function(){
				    			this.ownerCt.close();
				    		}
				    	}
					  ],
		
		getCurrentViewId: function(modelUrl){
			if (!this.items){return modelUrl;}
			
			var item = this.items.items.find(function(r){
				return r.checked
			});
			
			if (item && item.href){
				return item.href;
			} else {
				return modelUrl;
			}
		},

		onSubmit: function(){
			var model = this.sel[0];
			if (model && this.data.getSelectionCount() == 1) {
				this.body.mask(Ext.ux.getI18N("views.waiting"), "x-waiting-box");
				
				// Page mode
				var params = "?pageMode="+this.data.getSelectedRecords()[0].get("url");
				// Signavio branding
				params += "&showSignavioBranding=" + this.signavioBranding.items.get(0).getValue();
				// Default scale factor
				params += "&scale=1.4"
				var view = this.items.find(function(item){
					return item instanceof Ext.form.Radio && item.checked;
				}) 
				if(view){
					params += "&view=" + view.href;
				} 
				this.showMap(model, params);
			}
		},
		stripName: function(name){
			// Unescape
			name = name.unescapeHTML();
			// Remove all Windows incompatible letters \/:*?"<>| and the #
			name = name.replace(/[\\\/:*?\"<>|#]/g, "");
			// Encode
			name = encodeURI(name);
			name = name.replace(/&/g, "%26");
			return name;
		},
		showMap: function(model, parameter) {
			var url = Signavio.Config.BACKEND_PATH+model.get("href")+"/pdf/"+this.stripName(model.get("rep").name||"")+".pdf";
			url+=parameter;
			window.open(url);
		},	
		
		initComponent: function(){

			var id = Ext.id();
	
			//add radiobox for each view						  
			this.items = [
							new Ext.form.Label({
			     			   	style	: "display:block;padding-bottom:10px;padding-left:7px;padding-right:5px;padding-top:5px;width:320px;",
					    		text	: Ext.ux.getI18N("views.offerTitleDesc")
					    	}),
						
							this.data
					  ];
			
			this.items.push(
				new Ext.form.Label({
					cls			: "y-export-window-description",
					text		: Ext.ux.getI18N("views.windowDescription")
				})
			);
						
			this.items.push(
				new Ext.form.Radio({
					cls		 : "y-export-radio-original",
					name	 : id,
					hideLabel: true,
					boxLabel : "<i>"+Ext.ux.getI18N("views.resetView")+"</i>",
					href	 : this.modelId,
					checked	 : true
				})
			);
			
			this.items = this.items.concat(this.views.map(function(view){
				return new Ext.form.Radio({
					name	 : id,
					cls		 : "y-export-radio",
					hideLabel: true,
					boxLabel : (view.rep.view && view.rep.view.name) || view.rep.name,
					href	 : view.href.replace("/info", "")
				})
			}));
			var licenses = this.facade.getCurrentUser().getRecords("info")[0].get("rep").licenses;
			this.signavioBranding = new Ext.Panel({
					    		layout		: "form",
					    		style 		: "padding-left:7px",
					    		cls			: "x-form-map-export-branding",
					    		border		: false,
					    		items		: [{
												xtype:'checkbox',
												hideLabel : true,
												name: "showSignavioBranding",
												checked: false,
												disabled: !(licenses.member("premium") || licenses.member("corporate")) || this.facade.getConfig().mode === "Academic",
												boxLabel: Ext.ux.getI18N("views.branding") +" "+ ((!(licenses.member("premium") || licenses.member("corporate")))?' <img ext:qtip="' + Ext.ux.getI18N("views.premiumOnly") +'" src="'+Ext.IMAGE_URL+'/famfamfam/information.png"/>':"")
								 			  }]
			});
			this.items.push(this.signavioBranding);	
			
			Ext.ux.view.PdfExportWindow.superclass.initComponent.call(this)
		}
	});

}()
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *
 *	This code is proprietary software within the 
 * 	company Signavio GmbH.
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.view){ Ext.ux.view = {} }

new function(){
	
	/**
	 * The feedback window to contact Signavio
	 * 
	 * @class Ext.ux.view.FeedbackWindow
	 */
	Ext.ux.view.FeedbackWindow = function(mode, url, explorerPath, model, supportMailAddress){
		this.mode = mode;
		this.model = model;
		this.url = url;
		this.explorerPath = explorerPath;
		this.supportMailAddress = supportMailAddress;
		Ext.ux.view.FeedbackWindow.superclass.constructor.apply(this, [{}]);
		this.show();
		this.on("resize", this.updateHeight, this);
		this.updateHeight();
	};

	Ext.extend(Ext.ux.view.FeedbackWindow, Ext.Window, {
		resizable	: true,
		closable	: true,
		minimizable	: false,
		stafeful	: false,
		modal		: true,
		width		: '50%',
		minHeight	: 480,
		minWidth	: 400,
		height		: 480,
		layout		: 'anchor',
		bodyStyle	: "background-color:white;padding:10px;color:black;overflow:visible;",
		buttons		: [
						{
				        	text: Ext.ux.getI18N("views.sendFeedback"),
				        	handler: function(){
								
				        		// Check for user defined subject
								if (!this.ownerCt.items.items[2].items.get(0).getValue()){
									Ext.Msg.alert(Ext.ux.getI18N("views.feedbackMissingHeader"), Ext.ux.getI18N("views.feedbackMissingHeaderMsg"))
										.setIcon(Ext.Msg.INFO).getDialog().syncSize();
									return;
								} else {
									var value = this.ownerCt.items.items[2].items.get(0).getValue();
									if (!value.replace('[Feedback] ','').replace('[Bug Report] ', '').replace('[Feature Request] ', '').trim()) {
										Ext.Msg.alert(Ext.ux.getI18N('views.feedbackMissingHeader'), Ext.ux.getI18N('views.feedbackMissingHeaderMsg'))
											.setIcon(Ext.Msg.INFO).getDialog().syncSize();
										return;
									}
								}
								
								if (!this.ownerCt.items.items[2].items.get(1).getValue()){
									Ext.Msg.alert(Ext.ux.getI18N("views.feedbackMissingBody"), Ext.ux.getI18N("views.feedbackMissingBodyMsg"))
										.setIcon(Ext.Msg.INFO).getDialog().syncSize();
									return;
								} else {
									var value = this.ownerCt.items.items[2].items.get(1).getValue();
									if (value.length < this.ownerCt.items.items[2].items.get(1).minLength){
										Ext.Msg.alert(Ext.ux.getI18N("views.feedbackerrorlengthtitle"), Ext.ux.getI18N("views.feedbackerrorlength"))
										.setIcon(Ext.Msg.INFO).getDialog().syncSize();
									return;
									}
								}
								
								var win = this.ownerCt;
                        		this.ownerCt.items.items[2].form.submit({
		                            waitMsg: Ext.ux.getI18N("views.feedbackSending"), 
		                            success: function(form, action){
		                                Ext.Msg.alert(Ext.ux.getI18N("views.feedbackSuccess"), Ext.ux.getI18N("views.feedbackSuccessMsg"))
											.setIcon(Ext.Msg.INFO).getDialog().syncSize();
		                                win.close();
		                            },
	                            	failure: function(form, action){
	                                	Ext.Msg.alert(Ext.ux.getI18N("views.feedbackFailure"), Ext.ux.getI18N("views.feedbackFailureMsg"))
											.setIcon(Ext.Msg.WARNING).getDialog().syncSize();
	                            	}
                       			});
                    		}
				    	},
				    	{
				    		text : Ext.ux.getI18N("views.feedbackCloseTitle"),
				    		handler : function(){
				    			this.ownerCt.close();
				    		}
				    	}
					  ],
					  
		getEnv: function(){
	        var env = "";
	        
	        env += "Browser: " + navigator.userAgent;
	        
	        env += "\n\nBrowser Plugins: ";
	        if (navigator.plugins) {
	            for (var i = 0; i < navigator.plugins.length; i++) {
	                var plugin = navigator.plugins[i];
	                env += plugin.name + ", ";
	            }
	        }
	        
	        if ((typeof(screen.width) != "undefined") && (screen.width && screen.height)) 
	            env += "\n\nScreen Resolution: " + screen.width + 'x' + screen.height;
	        
	        return env;
	    },
		
	    getHint: function(){
	    	var hint;
	    	if (this.mode === "Enterprise"){
	    		hint = Ext.ux.getI18N("views.feedbackenterprise").replace("[mail]",this.supportMailAddress);
	    	}else{
	    		hint = Ext.ux.getI18N("views.feedbacksignavio").replace("[mail]",this.supportMailAddress);
	    	}	    	
	    	return {
	    		xtype: 'panel',
	    		html: hint,
	    		border: false,
	    		bodyStyle: 'margin-bottom: 11px;font-family: tahoma,arial,helvetica,sans-serif; font-size: 12px; font-size-adjust: none;'+ 
	    			'font-style: normal; font-variant: normal; line-height: normal;'
	    	};
	    },
	    
	    getReceiver: function(){
	    	var hint = Ext.ux.getI18N("views.feedbackreceiver") + ":";
	    	if (this.mode === "Enterprise"){
	    		hint += Ext.ux.getI18N("views.feedbackreceiverenterprise").replace("[mail]",this.supportMailAddress);
	    	}else{
	    		hint += Ext.ux.getI18N("views.feedbackreceiversignavio").replace("[mail]",this.supportMailAddress);
	    	}	 
	    	return {
	    		xtype: 'panel',
	    		html: hint,
	    		border: false,
	    		bodyStyle: 'margin-bottom: 11px;font-family: tahoma,arial,helvetica,sans-serif; font-size: 12px; font-size-adjust: none;'+ 
	    			'font-style: normal; font-variant: normal; line-height: normal;'
	    	};
	    },
	    
		initComponent: function(){
			this.title = this.mode === "Enterprise"?Ext.ux.getI18N("views.feedbackTitleEnterprise"):Ext.ux.getI18N("views.feedbackTitle");
			var hint = this.getHint();
			var receiver = this.getReceiver();
			this.items = [hint,receiver,
				{
					xtype: 'form',
					url: this.url,
					anchor: '100% 93%',
					border: false,
					labelAlign: 'top',
					items: [{
						xtype: 'combo',
						name: 'subject',
						anchor:'100%',
						height:'60px',
						store: new Ext.data.SimpleStore({
							fields: ['title'],
							data: [['[Feedback] '], ['[Bug Report] '], ['[Feature Request] ']]
						}),
						allowBlank: false,
						blankText: Ext.ux.getI18N("views.feedbackEnterSubject"),
						displayField: 'title',
						mode: 'local',
						typeAhead: true,
						triggerAction: 'all',
						fieldLabel: Ext.ux.getI18N("views.feedbackPSubject") + ' *'
					
					}, {
						xtype: 'textarea',
						name: 'description',
						allowBlank: false,
						minLength: 40,
						minLengthText: Ext.ux.getI18N("views.feedbackerrorlength"),
						blankText: Ext.ux.getI18N("views.feedbackEnterDescription"),
						fieldLabel: Ext.ux.getI18N("views.feedbackPMsg") + ' *',
						emptyText: Ext.ux.getI18N("views.feedbackPEmpty"),
						anchor: (Ext.isIPad ? '-8 ' + (this.model ? '-240' : '-209') : '100% ' + (this.model ? '-229' : '-198'))
					},{
						xtype: 'checkbox',
						itemCls : 'x-support-checkbox',
	                    boxLabel: Ext.ux.getI18N("views.feedbackcopy") + ' <img src="'+Ext.IMAGE_URL+'/famfamfam/information.png" ext:qtip="' + Ext.ux.getI18N("views.feedbackcopydesc") + '"/>',
	                    hideLabel: true,
	                    checked: false,
	                    name: 'sendCopy'
					}, {
						xtype: 'hidden',
						itemId: 'hiddenModel',
						name: 'model'
						
					},(this.model?{
	                    xtype: 'checkbox',
						itemCls : 'x-support-checkbox',
	                    boxLabel: Ext.ux.getI18N("views.feedbackpattach") + ' <img src="'+Ext.IMAGE_URL+'/famfamfam/information.png" ext:qtip="' + Ext.ux.getI18N("views.feedbackpattachdesc") + '"/>',
	                    hideLabel: true,
	                    checked: true,
	                    listeners: {
	                        check: function(checkbox, checked){
	                            var hidden = checkbox.ownerCt.find("name", "model")[0];
	                            if (checked) {
	                                hidden.setValue(this.model);
	                            }
	                            else {
	                                hidden.setValue(undefined);
	                            }
	                        }.bind(this)
	                    }
                	}:undefined),{
						xtype: 'textarea',
						itemCls : 'x-support-textarea',
						name: 'environment',
						fieldLabel: Ext.ux.getI18N("views.feedbackPBrowser") + ' <img src="'+Ext.IMAGE_URL+'/famfamfam/information.png" ext:qtip="' + Ext.ux.getI18N("views.feedbackPBrowserDesc") + '"/>',
						anchor: Ext.isIPad ? '-8' : '100%',
						height:'60px',
						value: this.getEnv()
					}].compact()
				}
			];
			Ext.ux.view.FeedbackWindow.superclass.initComponent.call(this)
		},
		
		/**
		 * Set the height of the second panel 
		 * to 100% regarding the height of 
		 * the first panel.
		 * 
		 */
		updateHeight: function(){
			this.items.get(2).setHeight(this.getInnerHeight()-this.items.get(0).el.getHeight()-this.items.get(1).el.getHeight()-20);
			
		}
	});
}()
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *
 *  This code is proprietary software within the 
 *  company Signavio GmbH.
 *  
 */


if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.view){ Ext.ux.view = {}; }

(function(){

    /**
     * A generic wizard providing basic functionality to export single or
     * multiple diagrams in multiple ways.
     * 
     * This class provides an abstraction of a wizard:
     *
     * @param {Object} attributes
     * 
     * @class Ext.ux.view.Wizard
     */
    Ext.ux.view.Wizard = function(attributes) {

        attributes = attributes || {};
        
        // The callback to execute after the wizard
        this.clb = attributes.clb;
        // The name for the button
        this.clbName = attributes.clbName;
        
        // If no buttons are defined or buttons are defined but no button with a cancel text exists, create a cancel button
        if (attributes.closable !== false &&
            (!attributes.buttons || 
            attributes.buttons && !attributes.buttons.find(function(button) {
                return button.text === Ext.MessageBox.buttonText.cancel;
            }))) {
            this.cancel = new Ext.Button({
                text    : Ext.MessageBox.buttonText.cancel,
                handler : function(){
                            // Close the wizard window
                            this.ownerCt.close();       
                            this.ownerCt.destroy();
                }.bind(this),
                template: new Ext.Template("<a href='#' class='x-button-plain'>{0}</a>"), 
                onRender: function(){
                            this.el = Ext.get(this.template.overwrite(this.container.dom, [this.text]));
                            this.el.on("click", function(e,t){
                                this.handler.apply(this, arguments);
                                e.stopEvent(); 
                                return false;
                            }.bind(this));
                }
            }); 
        }
        
        this.lastTab = this.findLastTab(attributes.items);
        
        // The next button
        this.next = new Ext.Button({
                        text    : this.nextLabel,
                        handler : this.nextPage.bind(this)
                    });

        // The previous button
        this.previous = new Ext.Button({
                        text    : this.previousLabel,
                        hidden  : true,
                        handler : this.previousPage.bind(this)
                    });
        
        // Set the next/previous buttons                    
        attributes.buttons = [this.cancel].concat((attributes.buttons||[]), [this.previous, this.next]).compact();
        
        Ext.ux.view.Wizard.superclass.constructor.call(this, attributes);
    };
    
    Ext.extend(Ext.ux.view.Wizard, Ext.TabPanel, {
        /**
         * Initial Configuration
         */
        hideBorders         : true,
        cls                 : 'y-wizard',
        layoutOnTabChange   : true,
        activeTab           : 0,
        nextLabel           : Ext.ux.getI18N("wizard.nextbtnlabel"),
        previousLabel       : Ext.ux.getI18N("wizard.previousbtnlabel"),

        onRender: function(){
            Ext.ux.view.Wizard.superclass.onRender.apply(this, arguments);
            // Hide tabs
            this.header.setStyle("display", "none");
            // Update buttons to display the correct labels
            this.updateButtons();
        },
    
        findLastTab: function(tabs) {
            var last = null;

            tabs.each(function(tab) {
                if(!tab.disabled) {
                    last = tab;

                    return;
                }

                throw $break;
            });

            return last;
        },

        /**
         * Shows previous page
         * @param {Boolean} silent Call it without calling callback
         */
        previousPage: function(silent){
            var tab = (typeof this.activeTab === 'object' ? this.activeTab : this.getItem(this.activeTab)); 
            // If the active tab is the first tab, do nothing
            if (tab === this.items.first()) {
                return;
            } else {
                // Get the previous tab
                var previous = this.getPreviousTab();
                
                // Call method and check if it is ok to go back
                if (silent !== true && (tab.onPrevious && tab.onPrevious(previous) === false)){
                    return;
                }
                
                // Set previous tab
                if (previous) {
                    this.setActiveTab(previous);
                }
                
                this.updateButtons();
            }
        },

        /**
         * Show next page
         * @param {Boolean} silent Call it without calling callback
         */
        nextPage: function(silent){

            var tab = (typeof this.activeTab === 'object' ? this.activeTab : this.getItem(this.activeTab));
            // If the active tab is the last tab and a callback is defined, execute the callback
            // if (tab === this.items.last() && typeof this.clb === 'function') {
            if (tab === this.lastTab && typeof this.clb === 'function') {
                this.clb(this);
                return;
            } else {
                // Get next tab
                var next = this.getNextTab();
                
                // Call method and check if it is ok to move on
                if (silent !== true && (tab.onNext && tab.onNext(next) === false)) {
                    return;
                }

                // Set next tab
                if (next) {
                    this.setActiveTab(next);
                    this.updateButtons();
                }
            }
        },

        /**
         * Updates the next and previous button depending on the active tab
         */
        updateButtons: function(){
            
            var tab = (typeof this.activeTab === 'object' ? this.activeTab : this.getItem(this.activeTab));
            
            // Show/hide previous button
            if (tab === this.items.first() || tab.hideButtons === true ) {
                this.previous.hide();
            } else {
                this.previous.show();
                this.previous.setText((this.getPreviousTab() && this.getPreviousTab().title && ("< " + this.getPreviousTab().title)) || (tab && tab.previousLabel) ||this.previousLabel);
            }
            
            // Show/hide next button
            if (tab === this.lastTab || tab.hideButtons === true) {
                if (this.clb) {
                    this.next.show();
                    this.next.setText(this.clbName || "Funktion rufen");
                } else {
                    this.next.hide();   
                }
            } else {
                this.next.show();
                this.next.setText( (this.getNextTab() && this.getNextTab().title && (this.getNextTab().title + " >")) || (tab && tab.nextLabel) || this.nextLabel);
            }
        },
        
        /**
         * Returns the index of a given page
         * @param {Ext.ux.view.WizardPage} page
         * @returns
         */
        getIndex : function(page) {
            var tabs = this.items;
            return tabs.indexOf(page);
        },
        
        /**
         * Returns the next tab
         * @returns
         */
        getNextTab : function() {
            if (!this.getActiveTab()){
                return this.items.get(Math.min(1, this.items.length-1));
            }
            var next = this.items.get(Math.min(this.items.indexOf(this.getActiveTab())+1, this.items.length-1));
            while (next && next.isNotActive instanceof Function && next.isNotActive()){
                next = this.items.get(Math.max(this.items.indexOf(next)+1, 0));
            }
            return next;
        },
        
        /**
         * Returns the previous tab
         * @returns
         */
        getPreviousTab : function() {
            if (!this.getActiveTab()){
                return this.items.get(0);
            }
            var previous = this.items.get(Math.max(this.items.indexOf(this.getActiveTab())-1, 0));
            while (previous && previous.isNotActive instanceof Function && previous.isNotActive()){
                previous = this.items.get(Math.max(this.items.indexOf(previous)-1, 0));
            }
            return previous;
        },
        
        /**
         * Set the active tab to the given item
         * 
         */
        setTab: function(item){
            this.setActiveTab(item);
            this.updateButtons();
            return item;
        }
    });

    /**
     * This class provides an abstraction for a page within a wizard
     * 
     * @class
     * @param {Object} attributes
     */
    Ext.ux.view.WizardPage = function(attributes){
        attributes = attributes || {};
        Ext.ux.view.WizardPage.superclass.constructor.call(this, attributes);
    };

    Ext.extend(Ext.ux.view.WizardPage, Ext.form.FormPanel, {
        cls     : 'y-wizard-page',
        autoScroll: true,
        defaults: {
            border  : false
        },
        
        /**
         * Adjusts the height of the format selector data view when shown/resized.
         * @param {Ext.ux.view.WizardPage} comp The current wizard page
         * @param {Number} diffHeight Optional value which is subtract to the computed height
         */
        adjustPageContentSize : function(anchor,diffHeight) {
            if(!anchor) {
                return;
            }
            
            var contentHeight = 0;
            var minHeight = 200;
            
            this.items.each(function(item) {
                if(item && item !== anchor) {
                    var el = item.getEl();

                    if(!el || !el.isVisible()) {
                       return;
                    }

                    // var height = el.getHeight();
                   
                    var height = el.getComputedHeight();
                    height += el.getPadding("tb");
                    height += el.getMargins("tb");

                    contentHeight += height;
                }
            });
            
            var computedHeight = Math.max(this.getEl().getHeight() - contentHeight, minHeight);
            
            var addHeight = diffHeight || 0;
            anchor.setHeight(computedHeight-addHeight);
        }
    });
    
    /**
     * This class provides a helper to create a Container for options.
     * 
     * @param {String} title The title for the options container
     * @param @optional {String} desc The description text to display inside the options container
     * @param @optional {String} cls A css class to apply to the options container
     * @param {Object[]} items The items to display inside the options container. 
     */
    Ext.ux.view.OptionsContainer = function(attributes) {
        attributes = attributes || {};
        
        attributes.layout = attributes.layout || "anchor";
        attributes.cls = "y-wizard-options-container " +  (attributes.cls || "");
        
        // If a title is defined, create a new label for it
        var titleLabel = new Ext.form.Label({
            text    : attributes.title || '',
            cls     : 'y-wizard-options-title'
        });
        
        // If a description is defined, create a new label for it
        
        var descLabel = null; 
        if(attributes.desc) {
            descLabel = new Ext.form.Label({
                text  : attributes.desc,
                cls     : 'y-wizard-options-description'
            });
        }
        
        attributes.items = [descLabel].concat(attributes.items || []).compact();
        
        if(attributes.items.length === 0) {
            delete attributes.items;
        }
        
        attributes.titleLabel = titleLabel;
        delete attributes.title;
        
        attributes.listeners = Ext.apply({
            render : function() {
                this.titleLabel.render(this.body.parent().parent());
            }
        }, attributes.listeners || {});
        
        Ext.ux.view.OptionsContainer.superclass.constructor.call(this, attributes);
    };
    
    Ext.extend(Ext.ux.view.OptionsContainer, Ext.Panel);
}());
/**
 * Copyright (c) 2011
 * Sven Wagner-Boysen
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

new function(){
	if(typeof YAHOO == "undefined") {return;}
	/**
	 * Customizes the YAHOO.widget.Slider to select an numeric ranges.
	 * Adds input fields for min and max values.
	 */
	YAHOO.namespace("Signavio");
	
	YAHOO.Signavio.SliderGenerator = function() {
		
	};
	
	YAHOO.lang.augmentObject(YAHOO.Signavio.SliderGenerator, YAHOO.widget.Slider, true);
	
	/**
     * Generates the slider element the registers the callback methods.
     */
	YAHOO.Signavio.SliderGenerator.generateSlider = function(parentElId, tickSize, paramOptions, valuesChangedCB, callbacks, isScrolling) {
    	var slider, range,
    		YElement = YAHOO.util.Element,
    	
        	// slider elements
    		bgElId = YAHOO.util.Dom.generateId(),
    		minThumbId = YAHOO.util.Dom.generateId(),
    		maxThumbId = YAHOO.util.Dom.generateId(),
    		hlElId = YAHOO.util.Dom.generateId(),
    		inStartId = YAHOO.util.Dom.generateId(),
    		inEndId = YAHOO.util.Dom.generateId(),
		
    		// Create elements
    		parentEl = new YElement(YAHOO.util.Dom.get(parentElId));
    	
    	tickSize = 0;
    	
    	/**
    	 * Default Signavio Slider callbacks
    	 */
    	var defaultCallbacks = {
    		// The highlight element
    		_highlight : undefined,
    		
    		/**
    		 * Expects the current selected value ranges and triggers an
    		 * update of the slider and value fields.
    		 * 
    		 */
    		initValues: function(min, max) {
    			if(typeof(min) === "undefined" || typeof(max) === "undefined") {return;}
    			
    			// Setting the element values by exploiting the input
    			// event handler callbacks
    			var options = this._paramOptions,
    			event = function(val) {
    				this.val = val;
    			};
    			
    			event.prototype.element = function() {
    				return {value:this.val};
    			};
    			
    			// avoid slider bubling
    			this.blockUpdate = true;
    			
    			this.inputStartValueChanged(new event(min), options);
    			this.inputEndValueChanged(new event(max), options);
    			
    			this.subscribe('slideEnd',function() {this.blockUpdate = false;}, this, true);
    		},
    		
    		// A method to update the status and update the highlight
    		updateHighlight : function () {
    			var Dom = YAHOO.util.Dom;
    			var delta = this.maxVal - this.minVal;
//    			console.log(this.maxVal);
//    			console.log(this.minVal);
    			//if (this.activeSlider === this.minSlider) {
    				// If the min thumb moved, move the highlight's left edge
    				Dom.setStyle(this._highlight,'left', this.minVal + 'px');
    			//}
    			// Adjust the width of the highlight to match inner boundary
    			Dom.setStyle(this._highlight,'width', Math.max(delta,0) + 'px');
    		},
    		
    		/**
    		 * Returns the pixel position of the left slider thumb corrected by 
    		 * the style sheet offset.
    		 */
    		getMinValNormalized: function() {
    			return this.minVal - 8;
    		},
    		
    		getMaxValNormalized: function() {
    			return this.maxVal - 8;
    		},
     		
    		/**
    		 * Take position of the slider thumbs, transforms them to values
    		 * in parameter value range and displays them.
    		 */
    		updateCaptionValues: function(event, options) {
    			var relPos = function(range, pos) {
    				return pos / range;
    			};
    			
    			var domRange = Math.abs(options._paramOptions.maxVal - options._paramOptions.minVal);
    			var minRelPos = relPos(options._paramOptions.range, this.getMinValNormalized());
    			var maxRelPos = relPos(options._paramOptions.range, this.getMaxValNormalized());
    			var min = options._paramOptions.minVal;
    			var minVal = (min + minRelPos * domRange).toFixed(options._paramOptions.precision);
    			var maxVal = (min + maxRelPos * domRange).toFixed(options._paramOptions.precision);
    			
    			YAHOO.util.Dom.get(options._paramOptions.inStartId).setValue(minVal);
    			YAHOO.util.Dom.get(options._paramOptions.inEndId).setValue(maxVal);
    			
    			options.appendUnitSign(YAHOO.util.Dom.get(options._paramOptions.inStartId), options._paramOptions.unit);
    			options.appendUnitSign(YAHOO.util.Dom.get(options._paramOptions.inEndId), options._paramOptions.unit);
    			
    			options._valuesChangedCB({id:options._paramOptions.id, value: { min:minVal, max:maxVal}, blockUpdate: this.blockUpdate});
    			
//    			// Avoid server update signal during initialisation
//    			this.forceUpdate = true;
    		},
    		
    		inputStartValueChanged: function(event, options) {
    			var val = this._calcSliderValue(options.range, options.minVal, options.maxVal, event.element().value);
    			this.setMinValue(val);
    			this.appendUnitSign(YAHOO.util.Dom.get(options.inStartId), options.unit, true);
    		},
    		
    		inputEndValueChanged: function(event, options) {
    			var val = this._calcSliderValue(options.range, options.minVal, options.maxVal, event.element().value);
    			this.setMaxValue(val);
    			this.appendUnitSign(YAHOO.util.Dom.get(options.inEndId), options.unit, true);
    		},
    		
    		/**
    		 * Calculates the value of the slider thumb from the a user
    		 * defined value of the actual parameter domain.
    		 */
    		_calcSliderValue: function(sliderRange, min, max, value) {
    			// VARs
    			var valNum;
    			
    			if(value) {
    				value = value.replace(/[^0-9.,-]/g, "");
    			}
    			var isNumber = function(n) {
    				  return !isNaN(parseFloat(n)) && isFinite(n);
    			};
    			
    			var decimals = function(x, dec_sep) {
    				var s = '' + x;
    				
    				if(s.indexOf(dec_sep) >= -1) {
    					return s.length - s.indexOf(dec_sep) - 1;
    				} else {
    					return 0;
    				}
    			};
    			
    			if(isNumber(value)) {
    				valNum = parseFloat(value);
    			} else {
    				return;
    			}
    			
    			
    			// Round to same precision for comparision
    			
    			var minD = decimals(min, '.');
    			var maxD = decimals(max, '.');
    			var valueD = decimals(valNum, '.');
    			
    			var d = Math.min(minD, maxD);
    			d = Math.min(d, valueD);
    			
    			min = parseFloat(min.toFixed(d));
    			max = parseFloat(max.toFixed(d));
    			valNum = parseFloat(valNum.toFixed(d));
    			
    			if(!valNum || min > max || min-1 > valNum || max+1 < valNum ) {return;}
    			
    			var domainRange = max - min;
    			// Normalize value and calculate relative position
    			var relPos = (value - min) / domainRange;
    			
    			// Determine the position on the slider
    			return sliderRange * relPos;
    		},
    		
    		/**
    		 * Removes the unit signs from input fields and only shows up the 
    		 * raw value.
    		 */
    		removeUnitSign: function(event, slider) {
				var val = this.getValue();
				this.setValue(val.replace(/[^0-9.,-]/g, ""));
    		},
    		
    		/**
    		 * Appends the unit sign after finished editing.
    		 * 
    		 * @param event
    		 * @param options
    		 */
    		appendUnitSign: function(inputEl, unit, force) {
    			var inStartEl = YAHOO.util.Dom.get(this._paramOptions.inStartId);
    			if(inStartEl.id != document.activeElement.id) {
    				inStartEl.setValue(inStartEl.getValue().replace(/[^0-9.,-]/g, "") + " " + unit);
    			}
    			
    			var inEndEl = YAHOO.util.Dom.get(this._paramOptions.inEndId);
    			if(inEndEl.id != document.activeElement.id) {
    				inEndEl.setValue(inEndEl.getValue().replace(/[^0-9.,-]/g, "") + " " + unit);
    			}
    		},
    		
    		// implements a semaphore to avoid undefined behavior of blur and
    		// focus events
    		_semaphore: {},
    		
    		enter: function(id) {
    			if(!this._semaphore[id]) {
    				this._semaphore[id] = 1;
    				return true;
    			}
    			else {
    				return false;
    			}
    		},
    		
    		exit: function(id) {
    			if(this._semaphore[id]) {
    				this._semaphore[id] = 0;
    				return true;
    			}
    			
    			else {
    				return false;
    			}
    		},
    		
    		/**
    		 * Key event arrow down key
    		 */
    		handleKeyDown: function(event, keyCode, scope) {
    			scope.slider._setNewValueFromKeyEvent(scope, -1);
    		},
    		
    		/**
    		 * Key event arrow up key
    		 */
    		handleKeyUp: function(event, keyCode, scope) {
    			scope.slider._setNewValueFromKeyEvent(scope, 1);
    		},
    		
    		/**
    		 * Set the value of the proper slider thumb and input value field.
    		 * 
    		 * @param scope
    		 * @param upDown
    		 */
    		_setNewValueFromKeyEvent: function(scope, upDown) {
    			var rangeToAdd = scope.slider._getRangePerTick(),
					rangeValueToAdd = scope.slider._getRangeValuePerTick(),
					inputEl = YAHOO.util.Dom.get(scope.elId),
					t = scope.sliderThumb,
					newRangeVal,newVal;
				
				// toCamelCase function
				var cmFn = function(s) {
					return s.charAt(0).toUpperCase() + s.substr(1);
				};
				
				// Calculate new slider thumb value
				rangeToAdd *= upDown;
				rangeValueToAdd *= upDown;
				newRangeVal = scope.slider[t + "Val"] - 8 + rangeToAdd;
				newVal = (parseFloat(inputEl.getValue()) + rangeValueToAdd).toFixed(scope.slider._paramOptions.precision);
				
				if(0 <= newRangeVal && newRangeVal <= scope.slider._paramOptions.range) {
					scope.slider["set" + cmFn(t) + "Value"](newRangeVal);
					inputEl.setValue(newVal);
					scope.slider.appendUnitSign(inputEl, scope.slider._paramOptions.unit);
				}
    		},
    		
    		_getRangePerTick: function() {
    			return this._paramOptions.range / 100;
    		},
    		
    		_getRangeValuePerTick: function() {
    			return Math.abs((this._paramOptions.maxVal - this._paramOptions.minVal)) / 100;
    		}
    	};
		
		// Calculate range
		range = parentEl.get("element").getWidth() - 11 /*(24 + (isScrolling?18:0))*/;
		
		var sliderEl = new YElement(document.createElement("div"));
		sliderEl.addClass("yui-timeframe-slider-container");
		parentEl.appendChild(sliderEl);
		
		// Append the parameter name, if defined
		if(typeof paramOptions.name != "undefined") {
			var labelBox = new YElement(document.createElement("div"));
			labelBox.addClass("yui-timeframe-slider-param-caption-container");
			
			var lineBorderContainerEL = new YElement(document.createElement("span"));
			lineBorderContainerEL.addClass("yui-timeframe-slider-param-caption-border");
			
			var paraEl = new YElement(document.createElement("span"));
			paraEl.addClass("yui-timeframe-slider-param-caption");
			paraEl.get("element").innerHTML = paramOptions.name + "&#09;";
			
			lineBorderContainerEL.appendChild(paraEl);
			labelBox.appendChild(lineBorderContainerEL);
			sliderEl.appendChild(labelBox);
			
			if((typeof paramOptions.min != "undefined") && (typeof paramOptions.max != "undefined")) {
				var mmS = new YElement(document.createElement("span"));
				mmS.get("element").innerHTML = "(" + paramOptions.min.toFixed(paramOptions.precision) + "/" + paramOptions.max.toFixed(paramOptions.precision) + ")";
				paraEl.appendChild(mmS);
			}
		}
		
		var bgEl = new YElement(document.createElement("div"));
		bgEl.addClass("yui-timeframe-slider-bg");
		bgEl.set("id", bgElId);
		
		var hlEl = new YElement(document.createElement("span"));
		hlEl.set("id", hlElId);
		bgEl.appendChild(hlEl);
		
		var sliderTickEl = new YElement(document.createElement("div"));
		sliderTickEl.addClass("yui-timeframe-slider-tick");
		bgEl.appendChild(sliderTickEl);
		
		var rBorderEl = new YElement(document.createElement("div"));
		rBorderEl.addClass("yui-timeframe-slider-border");
		rBorderEl.addClass("yui-timeframe-slider-border-right");
		bgEl.appendChild(rBorderEl);
		
		var lBorderEl = new YElement(document.createElement("div"));
		lBorderEl.addClass("yui-timeframe-slider-border");
		lBorderEl.addClass("yui-timeframe-slider-border-left");
		bgEl.appendChild(lBorderEl);
		
		var minThumbEl = new YElement(document.createElement("div"));
		minThumbEl.addClass("yui-timeframe-slider-thumb");
		minThumbEl.set("id",minThumbId);
		bgEl.appendChild(minThumbEl);
		
		var maxThumbEl = new YElement(document.createElement("div"));
		maxThumbEl.addClass("yui-timeframe-slider-thumb");
		maxThumbEl.set("id",maxThumbId);
		bgEl.appendChild(maxThumbEl);
		
		sliderEl.appendChild(bgEl);
		
		var containerEl = new YElement(document.createElement("div"));
		containerEl.addClass("yui-timeframe-slider-container-values");
		
		var inStartEl = new YElement(document.createElement("input"));
		inStartEl.addClass("yui-timeframe-slider-start-value");
		inStartEl.set("id", inStartId);
		containerEl.appendChild(inStartEl);
		
		var inEndEl = new YElement(document.createElement("input"));
		inEndEl.addClass("yui-timeframe-slider-end-value");
		inEndEl.set("id", inEndId);
		containerEl.appendChild(inEndEl);
		
		sliderEl.appendChild(containerEl);
		
		// generate Slider
		var slider = YAHOO.widget.Slider.getHorizDualSlider(bgElId, minThumbId, maxThumbId, range, tickSize);

		// Apply default callbacks
		YAHOO.lang.augmentObject(slider, defaultCallbacks);
		slider._valuesChangedCB = valuesChangedCB;

		slider._highlight = YAHOO.util.Dom.get(hlElId);
		
		// Attach the highlight method to the slider's change event
        slider.subscribe('change',slider.updateHighlight,slider,true);
        
        
        // Register key events
        var kl = YAHOO.util.KeyListener;
        
        // Key Down code = 40
        var klDown;
        klDown = new kl(inStartId, {keys:40}, {fn: slider.handleKeyDown, scope: {slider: slider, sliderThumb: "min", elId: inStartId}, correctScope: false});
        klDown.enable();
        klDown = new kl(inEndId, {keys:40}, {fn: slider.handleKeyDown, scope: {slider: slider, sliderThumb: "max", elId: inEndId}, correctScope: false});
        klDown.enable();
        
        
        // Key UP code = 38
        var klUp;
        klUp = new kl(inStartId, {keys:38}, {fn: slider.handleKeyUp, scope: {slider: slider, sliderThumb: "min", elId: inStartId}, correctScope: false});
        klUp.enable();
        klUp = new kl(inEndId, {keys:38}, {fn: slider.handleKeyUp, scope: {slider: slider, sliderThumb: "max", elId: inEndId}, correctScope: false});
        klUp.enable();
        
        // Options applied to the event handler
        var options = {
        	range : range,
        	minVal: paramOptions.min,
        	maxVal: paramOptions.max,
        	inStartId : inStartId,
        	inEndId : inEndId,
        	unit : paramOptions.unit,
        	precision: paramOptions.precision,
        	id: paramOptions.id
        };
        
        // Attach the highlight method to the slider's change event
        YAHOO.lang.augmentObject(slider, {_paramOptions:options});
        slider.subscribe('slideEnd',slider.updateCaptionValues, slider, true);
        
        // Register changes in input fields
        YAHOO.util.Event.addListener(inStartId, 'blur', slider.inputStartValueChanged, options, slider);
        YAHOO.util.Event.addListener(inEndId, 'blur', slider.inputEndValueChanged, options, slider);
        
        // Remove unit sign on focus
        YAHOO.util.Event.addListener(inStartId, 'focus', slider.removeUnitSign, slider, false);
        YAHOO.util.Event.addListener(inEndId, 'focus', slider.removeUnitSign, slider, false);
        
        // register user callbacks
        // expected structure: [{event:'...', cb:funcRef},{},...] 
        if(callbacks instanceof Array) {
        	callbacks.each(function(cb) {
        		if(cb.event && cb.cb) {
        			slider.subscribe(cb.event, cb.cb);
        		}
        	});
        }
        
		return slider;
    };
}();