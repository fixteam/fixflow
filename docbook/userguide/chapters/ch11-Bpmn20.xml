<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC '-//OASIS//DTD DocBook XML V5.0//EN'  
               '../dtd/docbook.dtd'> 
               
<chapter xml:id="bpmn_chapter">
  <title>BPMN2.0</title>

  <section xml:id="bpmn.info">
    <title>BPMN简介</title>
    <para><emphasis role="bold">介绍:</emphasis></para>
    <para>
      业务流程建模标记法（BPMN, Business Process Modeling Notation）是对象管理组织（OMG, Object Management Group）维护的关于业务流程建模的行业性标准。
      它创建在与UML的活动图非常相似的流程图法（flowcharting）基础上，为“业务流程图”（BPD, Business Process Diagram）中的特定业务流程提供一套图形化标记法。
    </para>
    <para> <emphasis role="bold">目标:</emphasis></para>
    <para>
     BPMN的目标是，通过提供一套既符合业务人员直观又能表现复杂流程语义的标记法，同时为技术人员和业务人员从事业务流程管理提供支持。
      BPMN的首要目的是提供全体业务相关者易于理解的标准标记法。业务相关者包括创造与梳理流程的业务分析师、负责实施流程的技术开发者、以及管理和监督流程的经理人。BPMN旨在充当公共语言，跨越业务流程设计和实施之间常见的鸿沟。
      当前有多种竞争的业务流程建模语言标准供建模过程和工具选用。广泛采用BPMN将有助于统一基本的业务流程概念的表达（例如：公共或私有的流程、编排），就像一些高级的业务概念一样（例如：例外处理、事务补偿）。
    </para>
    <para> <emphasis role="bold">BPMN2.0元素图</emphasis></para>
    <para>
      <link xlink:href="../../images/BPMN2_0_Poster_EN.png">查看完整图片</link>
      <mediaobject ><imageobject>
        <imagedata align="center" contentwidth="900"  fileref="images/BPMN2_0_Poster_EN.png"/>
      </imageobject></mediaobject>
    </para>

    <para> <emphasis role="bold">我们使用BPMN元素进行建模，BPMN的元素分为五个类别</emphasis></para>
    <para>
      <mediaobject ><imageobject>
        <imagedata align="center" contentwidth="800"   fileref="images/bpmn.info.1.png"/>
      </imageobject></mediaobject>
    </para>
    <para>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">流对象(Flow Objects)</emphasis>: 流对象是定义业务流程的主要图形元素。它进一步细分为三个类别,分别是事件(Events)、活动(Activities)和网关(Gateways)。
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">数据(Data)</emphasis>: 它分为四个类别:数据对象（Data Object)、数据输入(Data Inputs)、数据输出(Data Outputs)和数据存储(Data Stores)。
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">连接对象(Connection Ojbects)</emphasis>: 用来把各个流对象或流对象与其他信息连接起来,它分为四种类别:顺序流(Sequence Flows)、消息流(Message Flows)、关联(Associations)和数据关联(Data Associations)。
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">泳道(Swimlanes)</emphasis>: 用来区分不同部门或者不同参与者的功能和职责,Swimlanes包含两种类别：池(Pool)和道（Lane)。
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">人工交付物(Artifacts)</emphasis>: 它用以给流程附加一些额外的信息,它分为两种类别：组(Group)和附注（Text Annotation)。
          </para>
        </listitem>
      </itemizedlist>    
    </para>
    <para>
      <emphasis role="bold">BPMN元素的三个层次</emphasis>
    </para>
    <para>
      根据流程引擎的实现顺序我们将BPMN元素分为了三个层次，分别是基本元素、核心元素和高级元素，通过基本元素的学习，我们能够开始进行简单的建模；通过核心元素的学习，能够满足我们平常大部分的建模需求；通过学习高级元素，我们能够看到BPMN所能处理的复杂情况。 
    </para>
    
    <para>
      <emphasis role="bold">基本元素:</emphasis>
      <mediaobject ><imageobject>
        <imagedata contentwidth="800" align="center" fileref="images/bpmn.info.2.png"/>
      </imageobject></mediaobject>
    </para>
    <para>
      <emphasis role="bold">核心元素:</emphasis>
      <mediaobject ><imageobject>
        <imagedata contentwidth="800" align="center" fileref="images/bpmn.info.3.png"/>
      </imageobject></mediaobject>
    </para>
    <para>
      <emphasis role="bold">高级元素:</emphasis>
      <mediaobject ><imageobject>
        <imagedata contentwidth="800" align="center" fileref="images/bpmn.info.4.png"/>
      </imageobject></mediaobject>
    </para>
  </section>
 
  <section xml:id="bpmn.extensions">
    <title>扩展元素</title>
    <para>
      bpmn2.0标准是一个各个厂商公认的业务建模标准,最终用户可以不受到来自供应商的绑定,遵循这个标准的厂商之间的产品可以平滑的过度。
      然而,bpmn2.0标准的的一个缺点就是,它始终是许多不同的公司之间的讨论和妥协的结果,对于一名开发人员来说BPMN 2.0 XML标准的定义,
      有时感觉它的结构或做事方式有点太麻烦了,并且很多工作流产品必须的流转配置信息,在标准里边没有很好的定义出来,所以,我们在bpmn2.0的基础之上遵循官方对bpmn2.0的扩展原则,
      对标准做了一些自己的扩展,FixFlow引擎的扩展都以"fixflow:"开头。
    </para>
    <para>
      BPMN标准是个开放的标准,它为每个元素都提供了扩展的方式,extensionElements可以包含在任务BPMN官方的元素里。
      <programlisting language="xml"><![CDATA[
      <bpmn2:extensionElements>
        <fixflow:taskSubject>
          <fixflow:expression xsi:type="fixflow:Expression" >"编号为: "+${编号}+" 的测试流程任务主题"</fixflow:expression>
        </fixflow:taskSubject>
      </bpmn2:extensionElements>
      ]]></programlisting>
    </para>
    <para>开发者也可以给我们反馈对扩展的意见<link xlink:href="https://github.com/fixteam/fixflow/issues">GtiHub issues</link>,或提出自定义扩展的新思路。谁知道,有一天,你的想法可能会出现在FixFlow引擎中哦。</para>
  </section>
  
  <section xml:id="bpmn.definitions">
    <title>Definitions</title>
    <para>
      bpmn2.0标准的文件根节点是definitions元素。在这个元素下，可以定义多个流程定义(Process)（虽然我们建议在每个文件中只定义一个流程，因为这样在部署流程的时候，简化了维护）。一个空的流程定义看起来像下面列出来的一样。
      
    </para>
    <para>
      <emphasis >注意:</emphasis>当definitions中含有多个process的时候为交互式流程图(Collaborations)。在一个Process的流程中,Pool就相当于Process。
    </para>
    <para>
      <emphasis role="bold">XML定义</emphasis>:
      <programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<bpmn2:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" 
  xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" 
  xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" 
  xmlns:di="http://www.omg.org/spec/DD/20100524/DI" 
  xmlns:fixflow="http://www.founderfix.com/fixflow" 
  id="Definitions_1" 
  targetNamespace="http://www.founderfix.com">
    <bpmn2:process id="process_demotest" fixflow:verification="true" fixflow:dbid="" name="测试流程">
     ........
    </bpmn2:process>
</bpmn2:definitions>]]></programlisting>
    </para>
  </section>

  
  <section xml:id="bpmn.process">
    <title>Process</title>
    <para>在FixFlow引擎中,一个流程定义实际指的就是一个Process元素,FixFlow现在并不支持多Process的交互式流程图,设计完流程定义之后需要发布到数据库中才能供引擎使用,FixFlow支持多流程版本功能,新启动的流程自动走新的版本,老的流程继续跑在老的版本上,相互不会产生影响。</para>
    <para>
      <emphasis role="bold">XML定义</emphasis>:      
      <programlisting language="xml"><![CDATA[<bpmn2:process id="process_demotest" 
  fixflow:verification="true" 
  fixflow:dbid="process_demotest:1:73189bfc-59cf-4ecf-b425-051cff44de3a" 
  name="测试流程" fixflow:category="测试分类" >
    ........
</bpmn2:process>]]></programlisting>
    </para>
    
    
    <itemizedlist>
      
      <listitem>
    <para>
      <emphasis role="bold">流程编号(id)</emphasis>:也叫流程Key 用来标识一个流程,但是一个流程里会有多个版本,所以通过Key找流程,不能定位到唯一的一个。 
    </para>
        </listitem>
        <listitem>
    <para>
      <emphasis role="bold">流程唯一编号(dbid)</emphasis>:流程唯一编号,由流程Key、版本号、GIUD组合而成的唯一编号。   
    </para>
        </listitem>
          <listitem>
    <para>
      <emphasis role="bold">流程名称(name)</emphasis>:流程的名称。
    </para>
          </listitem>
            <listitem>
    <para>
      <emphasis role="bold">是否验证发布(verification)</emphasis>:设计器在发布的时候是否强制验证流程。
    </para>
            </listitem>
              <listitem>
    <para>
      <emphasis role="bold">分类(category)</emphasis>:用于流程定义的归类。
    </para>
              </listitem>
      </itemizedlist>
        
    <para>
      <emphasis role="bold">Java代码</emphasis>:  
      <programlisting language="java"><![CDATA[
//查询所有流程定义
List<ProcessDefinitionBehavior> processDefinitions=modelService.createProcessDefinitionQuery().list();

//获取其中的一个流程定义
ProcessDefinitionBehavior processDefinition=processDefinitions.get(0);

//流程唯一编号
processDefinition.getProcessDefinitionId();

//流程编号
processDefinition.getProcessDefinitionKey();

//流程名称
processDefinition.getName();

//版本号
processDefinition.getVersion();

//流程分类
processDefinition.getCategory();

//流程定义里的所有元素
processDefinition.getFlowElements();]]></programlisting>
     
      
    </para>
    
    <para>
      
      <emphasis role="bold">设计器配置</emphasis>:
      <mediaobject ><imageobject>
        <imagedata contentwidth="800"  align="center" fileref="images/bpmn.process.1.png"/>
      </imageobject></mediaobject>
      
      
    </para>
    
    <para xml:id="bpmn.process.subject">
      <emphasis role="bold">流程任务主题</emphasis>:
    </para>
    <para>
      流程任务主题是用来标识一个流程实例的说明,不同于人工任务(UserTask)的任务主题,流程的任务主题是用来显示在流程实例上的实例主题,一般情况下我们在流程中只需要设置这个流程任务
      主题就可以了,一但设置了流程任务主题,流程中的所有人工任务(UserTask)的任务主题在没有配置的情况下就会默认从这里取。
    </para>
    <para>
      <emphasis role="bold">XML描述</emphasis>:
      <programlisting language="xml"><![CDATA[
<bpmn2:process id="process_demotest" 
fixflow:verification="true" 
fixflow:dbid="process_demotest:1:e9701a99-3814-48d4-b7f5-a64144c439a1" 
fixflow:category="测试分类" 
name="测试流程">
  <bpmn2:extensionElements>
    <fixflow:taskSubject>
        <fixflow:expression xsi:type="fixflow:Expression" >"编号为: "+${编号}+" 的测试流程任务主题"</fixflow:expression>
    </fixflow:taskSubject>
  </bpmn2:extensionElements>
</bpmn2:process>]]></programlisting>
      
    </para>
    <para>
      可以看到上面的 fixflow:taskSubject 是一个扩展元素,它存放在 bpmn2:extensionElements 中,这个元素是扩展元素的根元素,更多请查看 <link linkend="bpmn.extensions">扩展元素</link>。
    </para>
    <para>
      <emphasis role="bold">Java代码</emphasis>:
      <programlisting language="java"><![CDATA[//查询所有流程实例
List<ProcessInstance> processInstances=runtimeService.createProcessInstanceQuery().list();

//取第一个流程实例
ProcessInstance processInstance=processInstances.get(0);

//获取流程实例主题
processInstance.getSubject();]]></programlisting>
    </para>
    
    
    <para xml:id="bpmn.process.defaultForm">
      <emphasis role="bold">默认表单</emphasis>:
    </para>
    <para>
      默认表单是用来查看流程实例的浏览表单,FixFlow引擎的一条流程记录会有一个流程实例和多个任务组成,当UserTask的操作表单没有配置的时候,会
      自动去流程实例默认表单去寻找。当我们想查看一个流程实例的数据的时候一般都是以这个默认表单打开。
    </para>
    <para>
      <emphasis role="bold">XML描述</emphasis>:
      <programlisting language="xml"><![CDATA[
<bpmn2:process id="process_demotest" 
fixflow:verification="true" 
fixflow:dbid="process_demotest:1:e9701a99-3814-48d4-b7f5-a64144c439a1" 
fixflow:category="测试分类" 
name="测试流程">
  <bpmn2:extensionElements>
    <fixflow:formUri>
        <fixflow:expression xsi:type="fixflow:Expression" >"view.html"</fixflow:expression>
    </fixflow:formUri>
  </bpmn2:extensionElements>
</bpmn2:process>]]></programlisting>
      
    </para>
    <para>
      <emphasis role="bold">Java代码</emphasis>:
      <programlisting language="java"><![CDATA[//查询所有流程实例
List<ProcessInstance> processInstances=runtimeService.createProcessInstanceQuery().list();

//取第一个流程实例
ProcessInstance processInstance=processInstances.get(0);

//获取默认表单
processInstance.getProcessDefinition().getDefaultFormUri();]]></programlisting>
    </para>
   
   
    <itemizedlist>

  <listitem>
   <para>
     <emphasis role="bold">发布定时任务</emphasis>:       发布流程定义的时候同时发布定时启动任务。参见<link linkend="bpmn.event.TimerStartEvent">时间开始事件</link>
   </para>
  </listitem>
      <listitem>
    <para>
      <emphasis role="bold">发布校验</emphasis>:在流程定义发布的时候检查一些常用配置,不正确的话将禁止发布,如果去掉的话,流程将不验证发布正确性。
    </para>
      </listitem>
        <listitem>
    <para>
      <emphasis role="bold">验证</emphasis>:触发一次验证,检查流程定义正确性。
    </para>
        </listitem>
          <listitem>
    <para>
      <emphasis role="bold">发布</emphasis>:发布一个新的流程定义。
    </para>
          </listitem>
            <listitem>
    <para>
      <emphasis role="bold">更新</emphasis>:将当前设计区的流程定义更新到数据库一个选定的版本上。
    </para>
            </listitem>
              <listitem>
    <para>
      <emphasis role="bold">删除</emphasis>:删除数据库中一个流程定义版本。
    </para>
              </listitem>
                <listitem>
    <para>
      <emphasis role="bold">获取</emphasis>:将数据库中选中的一个版本覆盖掉当前工作区的流程版本。
    </para>
                </listitem>
                  <listitem>
    <para>
      <emphasis role="bold">下载定义</emphasis>:将选中的流程定义打包下载到本地。
    </para>
                  </listitem>
      </itemizedlist>
        
    <para>
      <emphasis role="bold">其他内容请参见相应章节</emphasis>:
    </para>
    <para>
      
      <link linkend="bpmn.ExtensionElements.dataVariable">数据变量</link>
      <link linkend="bpmn.ExtensionElements.connector">连接器</link>
      <link linkend="bpmn.ExtensionElements.connector">国际化</link>
    </para>
  </section>
  
  <section xml:id="bpmn.event">
    <title>Events</title>
    <para>
      事件是在流程过程中发生的事情。事件总是以一个圆圈图形出现。在BPMN 2.0中，存在两个主要的事件类别：捕捉(Catching)或抛出(Throwing)事件。
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">捕捉(Catching)</emphasis>:  执行过程中的事件到达时，它会等待一个触发发生。是指由不同的触发器内的图标或XML中的类型声明。捕获事件在视觉上区别于图标不填（即它是白色的）由内投掷事件。
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">抛出(Throwing)</emphasis>:  执行过程中的事件到达时，触发器被触发。是指由不同的触发器内的图标或XML中的类型声明。投掷项目在视觉上区别从一个醒目的事件内的图标，用黑色填充。
          </para>
        </listitem>
      </itemizedlist>
      对一个事件来说，通常会有产生该事件的原因（起因）和该事件所产生的影响（结果），例如一个消息的到来触发了一个事件并导致流程的启动，这个开始事件的起因是消息，它被称为消息开始事件，流程在结束时发送了一个消息，这个结束事件的结果是发送了消息，它被称为消息结束事件。我们使用不同的标识来区分事件的不同起因和结果。我们也使用事件不同的起因和结果来分类事件，完整的事件类型如下图所示：
      空开始事件没有指定事件的起因，它只是产生Token，触发流程的执行；空结束事件没有指定事件的结果，它消费掉Token，结束流程的执行。
    </para>
    <para><emphasis role="bold">Fixflow事件支持: </emphasis></para>
    <para> 在BPMN2.0官方定义的这些事件中Fixflow引擎现在支持：开始事件和结束事件和捕获事件。在后续的小节中我们会讨论到,其他的事件我们也将逐渐有计划的支持,开发计划请参见未来功能章节。<link linkend="future.info">未来的功能</link> </para>
    <para>
      <emphasis role="bold">BPMN2.0事件元素图:</emphasis>
      <mediaobject ><imageobject>
        <imagedata contentwidth="800" align="center" fileref="images/BPMN2_0_Poster_EN_EVENT.png"/>
      </imageobject></mediaobject>
    </para>
    
    <section xml:id="bpmn.event.EventDefinitions">
      <title>Event Definitions</title>
      <para>
        事件定义定义了一个事件的内容。没有事件定义，事件之间没有任何区别。例如：开始事件没有事件定义就没有指明究竟是什么启动过程。
        如果我们添加一个事件定义在开始事件里（计时器事件定义）那么我们就可以叫这个开始事件为(定时开始事件)。 
      </para>
    </section>
    
    <section xml:id="bpmn.event.TimerEventDefinitions">
      <title>Timer Event Definitions</title>
      <para>
        
      </para>
    </section>
    
    <section xml:id="bpmn.event.StartEvents">
      <title>Start Events</title>
      <para>
        启动事件表示一个流程的开始。启动事件可以通过事件定义来确定如何启动流程(如通过一个消息启动、定时启动)。开始事件属于捕获型事件(Catching):一直在等待某个请求发生。
      </para>

    </section>
    
    <section xml:id="bpmn.event.NoneStartEvent">
      <title>None Start Event</title>
      <section xml:id="bpmn.event.NoneStartEvent.Description">
        
        <title>描述</title>
        
        <para>
          一个空的启动事件(None StartEvent),表示流程的启动是人工启动的,需要通过调用FixFlow引擎RunTimeService中的启动方法将流程发起。
        </para>
        <para>
          
          <programlisting language="java">
<![CDATA[//创建一个启动命令
StartProcessInstanceCommand startProcessInstanceCommand = new StartProcessInstanceCommand();
//设置需要启动的流程的KEY
startProcessInstanceCommand.setProcessDefinitionKey("Process_StartProcessInstanceTest");
//设置业务关联键
startProcessInstanceCommand.setBusinessKey("bk_StartProcessInstanceTest");
//设置流程的启动人
startProcessInstanceCommand.setStartAuthor("1200119390");
//启动流程，返回流程实例
ProcessInstance processInstance = runtimeService.noneStartProcessInstance(startProcessInstanceCommand);]]></programlisting>
        </para>
        <para>
          <emphasis>注意: </emphasis> 私有子流程(subprocess) 总是有一个空启动事件(None StartEvent).
        </para>
        
      </section>
      
      <section xml:id="bpmn.event.NoneStartEvent.GraphicalNotation">
        
        <title>图形符号</title>
        <para> 
          一个空启动事件是图形为一个圆,细边框空心圆圈的图标(即没有触发类型)。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.event.NoneStartEvent.1.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
      
      <section xml:id="bpmn.event.NoneStartEvent.xml">
        <title>XML描述</title>
      <para>
        这是一个空启动事件的XML表示,没有任何子元素(其他开始事件类型都有一个元素声明的类型)。
        <programlisting language="xml">
<![CDATA[<bpmn2:startEvent id="StartEvent_1" name="启动">]]></programlisting>
      </para>
      </section>
      
      <section xml:id="bpmn.event.NoneStartEvent.designer">
        
        <title>设计器配置</title>
        <para> 
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.event.NoneStartEvent.CustomExtensions.1.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>

      <section xml:id="bpmn.event.NoneStartEvent.CustomExtensions">
        <title>空启动事件的扩展</title>
        <para>
          <emphasis>isPersistence: </emphasis>
          是否持久化,默认为true,当设置为false的时候,流程启动之后将不进行实例数据保存,但是在流程里边进行的其他数据数据操作可以正常使用,
          这个功能一般作用在频繁触发的定时启动任务以及不需要人工参与的自动化任务上,而且不需要记录实例数据的流程。
          <programlisting language="xml">
<![CDATA[<bpmn2:startEvent id="StartEvent_1" fixflow:isPersistence="false" name="启动">]]></programlisting>
          <emphasis>例如: </emphasis>一个频繁触发的定时启动流程。 参见:<link linkend="bpmn.event.TimerStartEvent">定时启动</link>
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.event.NoneStartEvent.CustomExtensions.2.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
    </section>
    
    <section xml:id="bpmn.event.TimerStartEvent">
      <title>Timer Start Event</title>
      <para>
        
      </para>
    </section>
    
    <section xml:id="bpmn.event.EndEvents">
      <title>End Events</title>
      <para>
        结束事件标志着一个流程或者子流程的结束。结束事件属于抛出(Throwing)型事件，这意味着当流程执行到结束事件时结果将被抛出。结果类型的由事件内的事件定义决定。
      </para>
    </section>
    
    <section xml:id="bpmn.event.NoneEndEvent">
      <title>None End Event</title>
      <section xml:id="bpmn.event.NoneEndEvent.Description">
        
        <title>描述</title>
        
        <para>
          一个空结束事件(NoneEndEvent)表示抛出的结果是不确定的。因此，流程引擎将只会结束当前执行路径(Token)。 
          在FixFlow引擎中,流程执行到空结束事件(NoneEndEvent)的时候,当前<link linkend="bpmn.FixFlow.ProcessEngine"><emphasis>令牌(Token)</emphasis></link>会被结束,如果当前令牌(Token)是根令牌(RootToken)
          ,则整个流程实例将会被结束,否则只会结束这个分支令牌(ChildToken),流程实例结束的时候会触发 <link linkend="bpmn.FixFlow.ProcessEngine.Event"><emphasis>实例结束事件(process-end)</emphasis></link>。
        </para>
      
      </section>
      <section xml:id="bpmn.event.NoneEndEvent.GraphicalNotation">
        
        <title>图形符号</title>
        <para> 
          一个空结束事件(NoneEndEvent)是粗的空心的圆圈都成的的图标(没有事件定义)。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.event.NoneEndEvent.1.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
      
      <section xml:id="bpmn.event.NoneEndEvent.xml">
        <title>XML描述</title>
        <para>
          这是一个空结束事件(NoneEndEvent)的XML表示,没有任何子元素(其他开始事件类型都有一个元素声明的类型)。
          <programlisting language="xml"><![CDATA[<bpmn2:endEvent id="EndEvent_1" name="结束">]]></programlisting>
        </para>
      </section>
      
      <section xml:id="bpmn.event.NoneEndEvent.designer">
        
        <title>设计器配置</title>
        <para> 
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.event.NoneEndEvent.designer.1.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
    </section>
    
    <section xml:id="bpmn.event.TerminateEndEvent">
      <title>Terminate End Event</title>
      <section xml:id="bpmn.event.TerminateEndEvent.Description">
        
        <title>描述</title>
        
        <para>
          终止结束事件(Terminate End Event)表示流程走到这里的时候,不仅仅会结束当前的分支,而且还会直接结束整个流程实例,
          不管当前走到结束的是 分支令牌(ChildToken) 还是 根令牌(RootToken) 都会直接结束整个流程实例,并触发流程
          <link linkend="bpmn.FixFlow.ProcessEngine.Event"><emphasis>实例结束事件(process-end)</emphasis></link>。 
        </para>
        <para>
          关于分支令牌(ChildToken)、根令牌(RootToken)、并发、合并、分支 请参见 <link linkend="bpmn.FixFlow.ProcessEngine"><emphasis>流程内核原理</emphasis></link>
        </para>
        
      </section>
      <section xml:id="bpmn.event.TerminateEndEvent.GraphicalNotation">
        
        <title>图形符号</title>
        <para> 
          一个空结束事件(NoneEndEvent)是粗的空心的圆圈都成的的图标(没有事件定义)。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.event.TerminateEndEvent.1.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
      
      <section xml:id="bpmn.event.TerminateEndEvent.xml">
        <title>XML描述</title>
        <para>
          这是一个空结束事件(NoneEndEvent)的XML表示,没有任何子元素(其他开始事件类型都有一个元素声明的类型)。
          <programlisting language="xml"><![CDATA[<bpmn2:endEvent id="EndEvent_1" name="结束">
  <bpmn2:terminateEventDefinition id="TerminateEventDefinition_1"/>
</bpmn2:endEvent>]]></programlisting>
        </para>
      </section>
      
      <section xml:id="bpmn.event.TerminateEndEvent.designer">
        
        <title>设计器配置</title>
        <para> 
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.event.NoneEndEvent.designer.1.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
    </section>
    
    <section xml:id="bpmn.event.BoundaryEvents">
      <title>Boundary Events</title>
      <para>
        
      </para>
    </section>
    
    <section xml:id="bpmn.event.TimerBoundaryEvent">
      <title>Timer Boundary Event</title>
      <para>
        
      </para>
    </section>
    
    <section xml:id="bpmn.event.IntermediateCatchingEventst">
      <title>Intermediate Catching Eventst</title>
      <para>
        
      </para>
    </section>
    
    <section xml:id="bpmn.event.TimerIntermediateCatchingEvent">
      <title>Timer Intermediate Catching Event</title>
      <para>
        
      </para>
    </section>




  </section>
  
  <section xml:id="bpmn.SequenceFlow">
    <title>Sequence Flow</title>
    
    <section xml:id="bpmn.Description">
      <title>描述</title>
      <para>
        顺序流是流程中两个元素之间的连接。令牌通过顺序流流转到下面的节点上。一个节点后面可以有多个顺序流,当条件都满足的时候会产生并行的执行。 
      </para>
    </section>

    <section xml:id="bpmn.SequenceFlow.GraphicalNotation">
      <title>图形符号</title>
      <para> 
        一个顺序流可视化作为一个从源元素对目标元素的箭头。箭头始终指向朝着既定目标。 
        <mediaobject ><imageobject>
          <imagedata align="center"  fileref="images/bpmn.SequenceFlow.1.png"/>
        </imageobject></mediaobject>
      </para>
    </section>
    
    <section xml:id="bpmn.SequenceFlow.XMLRepresentation">
      <title>XML描述</title>
      <para>
          这是一个空结束事件(NoneEndEvent)的XML表示,没有任何子元素(其他开始事件类型都有一个元素声明的类型)。
          <programlisting language="xml"><![CDATA[<bpmn2:sequenceFlow id="SequenceFlow_3" name="" sourceRef="UserTask_1" targetRef="UserTask_2"/>]]></programlisting>
      </para>
    </section>
    
    <section xml:id="bpmn.SequenceFlow.designer">
      
      <title>设计器配置</title>
      <para> 
        <mediaobject ><imageobject>
          <imagedata align="center"  fileref="images/bpmn.SequenceFlow.2.png"/>
        </imageobject></mediaobject>
      </para>
      
    </section>

    
    
    <section xml:id="bpmn.SequenceFlow.ConditionalSequenceFlow">
      <title>条件序列流</title>
      <section xml:id="bpmn.SequenceFlow.ConditionalSequenceFlow.Description">
        <title>描述</title>
        <para>
          一个顺序流(SequenceFlow)上可以定义条件,当条件返回为true则允许通过,返回false则不允许通过。
          当节点后面多条线都满足条件将产生一个并发(有几条线满足则产生几个并发)。
        </para>
        <para>注:以上适用于非网关节点的连接,网关会根据类型对线条的判断产生影响。</para>
      </section>


      
      <section xml:id="bpmn.SequenceFlow.ConditionalSequenceFlow.SequenceFlow.GraphicalNotation">
        <title>图形符号</title>
        <para> 
          一个有条件的序列流图形为一个常规序列流左边加上一个小钻石开始。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.SequenceFlow.ConditionalSequenceFlow.1.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      
      <section xml:id="bpmn.SequenceFlow.ConditionalSequenceFlow.SequenceFlow.XMLRepresentation">
        <title>XML描述</title>
        <para>
          这是一个空结束事件(NoneEndEvent)的XML表示,没有任何子元素(其他开始事件类型都有一个元素声明的类型)。
          <programlisting language="xml"><![CDATA[<bpmn2:sequenceFlow id="SequenceFlow_5" name="" sourceRef="StartEvent_2" targetRef="UserTask_1">
  <bpmn2:conditionExpression xsi:type="bpmn2:tFormalExpression">1==1</bpmn2:conditionExpression>
</bpmn2:sequenceFlow>]]></programlisting>
        </para>
      </section>
      
      <section xml:id="bpmn.SequenceFlow.ConditionalSequenceFlow.SequenceFlow.designer">
        
        <title>设计器配置</title>
        <para> 
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.SequenceFlow.ConditionalSequenceFlow.2.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
    </section>
    
    <section>
      <title>序列流的扩展</title>
      <para>
        <emphasis>orderId:</emphasis>顺序流的排序号,当一个节点后面有多个顺序流的时候,会按照顺序流的排序号进行验证,越小的越先参与计算。网关有自己的计算逻辑,请参见 <link linkend="bpmn.Gateways">网关章节</link>。
        <programlisting language="xml"><![CDATA[<bpmn2:sequenceFlow id="SequenceFlow_3" name="" fixflow:orderId="1" sourceRef="UserTask_1" targetRef="UserTask_2"/>]]></programlisting>
      </para>
    </section>
    
  </section>
  
  <section xml:id="bpmn.Gateways">
    <title>Gateways</title>
    <para>
      　　网关是用来控制流程分支执行的(令牌的分支执行)。网关能够合并或分散令牌。网关是图形为一个菱形,内部为一个图标。这个图标显示了网关的类型。
    </para>
    <para>
    <mediaobject ><imageobject>
      <imagedata align="center"  fileref="images/bpmn.Gateways.1.png"/>
    </imageobject></mediaobject>
    </para>
    <section xml:id="bpmn.ExclusiveGateway">
      <title>Exclusive Gateway</title>
      
      
      
      <section xml:id="bpmn.ExclusiveGateway.Description">
        <title>描述</title>
        <para>
          排他网关(ExclusiveGateway)在分裂时，只会选择一个输出顺序流传递Token,会按照后面线条的排序号优先计算,第一个满足条件的会将Token传递过去,排他网关在聚合时，任何一个输入顺序流传入Token，网关都会向后传递，不会对Token进行同步。我们使用"x"在网关内部标示出这是一个排他网关，默认情况下，我们也可以忽略标示。
        </para>
        <para>
          一般情况下,值只允许后面有一条线通过或者说是只允许有一个条件满足的时候使用排他网关。
        </para>
        <para>
          <emphasis>注意: </emphasis> 当排他网关(ExclusiveGateway)后面的线条都不满足的时候会抛出异常.
        </para>
      </section>
      
      <section xml:id="bpmn.ExclusiveGateway.GraphicalNotation">
        <title>图形符号</title>
        <para> 
          排他网关(ExclusiveGateway)图形为一个菱形里边有一个X。注意,一个网关如果内部是空的则默认为排他网关。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ExclusiveGateway.GraphicalNotation.1.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      
      <section xml:id="bpmn.ExclusiveGateway.XMLRepresentation">
        <title>XML描述</title>
        <para>下面描述的是一个排他网关,后面通过带条件的顺序流<link linkend="bpmn.SequenceFlow.ConditionalSequenceFlow">(Conditional SequenceFlow)</link>连接了三个Task。</para>
        <mediaobject ><imageobject>
          <imagedata align="center"  fileref="images/bpmn.ExclusiveGateway.XMLRepresentation.1.png"/>
        </imageobject></mediaobject>
       
        <para>
          XML元素表示如下:
          <programlisting language="xml"><![CDATA[<bpmn2:exclusiveGateway id="ExclusiveGateway_1" name="">
  <bpmn2:incoming>SequenceFlow_6</bpmn2:incoming>
  <bpmn2:outgoing>SequenceFlow_3</bpmn2:outgoing>
  <bpmn2:outgoing>SequenceFlow_4</bpmn2:outgoing>
  <bpmn2:outgoing>SequenceFlow_5</bpmn2:outgoing>
</bpmn2:exclusiveGateway>
<bpmn2:sequenceFlow id="SequenceFlow_3" name="${金额}==300" sourceRef="ExclusiveGateway_1" targetRef="Task_1">
  <bpmn2:conditionExpression xsi:type="bpmn2:tFormalExpression">${金额}==300</bpmn2:conditionExpression>
</bpmn2:sequenceFlow>
<bpmn2:sequenceFlow id="SequenceFlow_4" name="${金额}==200" sourceRef="ExclusiveGateway_1" targetRef="Task_2">
  <bpmn2:conditionExpression xsi:type="bpmn2:tFormalExpression">${金额}==200</bpmn2:conditionExpression>
</bpmn2:sequenceFlow>
<bpmn2:sequenceFlow id="SequenceFlow_5" name="${金额}==100" sourceRef="ExclusiveGateway_1" targetRef="Task_3">
  <bpmn2:conditionExpression xsi:type="bpmn2:tFormalExpression">${金额}==100</bpmn2:conditionExpression>
</bpmn2:sequenceFlow>]]></programlisting>
        </para>
      </section>
      
      <section xml:id="bpmn.ExclusiveGateway.designer">
        
        <title>设计器配置</title>
        <para> 
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ExclusiveGateway.designer.1.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
      
    </section>
    
    <section xml:id="bpmn.ParallelGateway">
      <title>Parallel Gateway</title>
      <section xml:id="bpmn.ParallelGateway.Description">
        <title>描述</title>
        <para>
          并行网关(ParallelGateway)用于将流程产生多个并行的分支,也可以将多个并行的分支合并回一个主线。

          <itemizedlist>
            <listitem>
              <para>
                <emphasis role="bold">分散</emphasis>(Diverging):  
                当并行网关处于分散(Diverging)状态的时候,流程令牌(token)经过的时候,会被分散出和网关输出顺序流相同数据量的分支,并每个分支沿着对应的顺序流向下执行。
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="bold">合并</emphasis>(Converging): 
                当并行网关处于合并(Converging)状态的时候,当分支令牌经过的时候,分支令牌会停留在网关上,等待其他的分支一起走到该网关,然后合并为一个继续向下。
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          分散、合并原理解释: 令牌 token1 走到 ParallelGateway1(Diverging) 的时候,token1会生成两个子令牌 token1.1 和 token1.2,两个子令牌沿着顺序流向下面的节点运行,token1父令牌
          停留在ParallelGateway1上面,当token1.1到达 ParallelGateway2(Converging) 的时候,会停在上面等待 它的"兄弟" token1.2,当token1.2到达ParallelGateway2(Converging)的时候,
          两个子令牌都被结束,同时激活父令牌token1,将token1拉到ParallelGateway2,沿着后面的线条向下运行。
        </para>
        <para>
          <emphasis>注意: </emphasis> 并行网关处于分散的时候,会忽略掉后面顺序流的条件,直接向下执行,这是并行网关和包容网关最大的区别。
        </para>
      </section>
      
      <section xml:id="bpmn.ParallelGateway.GraphicalNotation">
        <title>图形符号</title>
        <para> 
          并行网关(ParallelGateway)图形为一个菱形里边有一个"+"。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ParallelGateway.GraphicalNotation.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      
      <section xml:id="bpmn.ParallelGateway.XMLRepresentation">
        <title>XML描述</title>
        <para>
          XML元素表示如下:
          <programlisting language="xml"><![CDATA[ <bpmn2:parallelGateway id="ParallelGateway_1" name=""></bpmn2:parallelGateway>]]></programlisting>
        </para>
        <para>
          下面是一个合并、分散例子的XML表示:
          <programlisting language="xml"><![CDATA[<bpmn2:userTask id="UserTask_7" name="提交">
  <bpmn2:outgoing>SequenceFlow_12</bpmn2:outgoing>
</bpmn2:userTask>

<bpmn2:sequenceFlow id="SequenceFlow_12" name="" sourceRef="UserTask_7" targetRef="ParallelGateway_1"/>

<bpmn2:parallelGateway id="ParallelGateway_1" name="" gatewayDirection="Diverging">
  <bpmn2:incoming>SequenceFlow_12</bpmn2:incoming>
  <bpmn2:outgoing>SequenceFlow_1</bpmn2:outgoing>
  <bpmn2:outgoing>SequenceFlow_2</bpmn2:outgoing>
</bpmn2:parallelGateway>

<bpmn2:sequenceFlow id="SequenceFlow_1" name="" sourceRef="ParallelGateway_1" targetRef="UserTask_2"/>
<bpmn2:sequenceFlow id="SequenceFlow_2" name="" sourceRef="ParallelGateway_1" targetRef="UserTask_4"/>

<bpmn2:userTask id="UserTask_2" name="并行审批1">
  <bpmn2:incoming>SequenceFlow_1</bpmn2:incoming>
  <bpmn2:outgoing>SequenceFlow_7</bpmn2:outgoing>
</bpmn2:userTask>

<bpmn2:userTask id="UserTask_4" name="并行审批2">
  <bpmn2:incoming>SequenceFlow_2</bpmn2:incoming>
  <bpmn2:outgoing>SequenceFlow_8</bpmn2:outgoing>
</bpmn2:userTask>
    
<bpmn2:parallelGateway id="ParallelGateway_2" name="" gatewayDirection="Converging">
  <bpmn2:incoming>SequenceFlow_7</bpmn2:incoming>
  <bpmn2:incoming>SequenceFlow_8</bpmn2:incoming>
  <bpmn2:outgoing>SequenceFlow_13</bpmn2:outgoing>
</bpmn2:parallelGateway>
   
<bpmn2:sequenceFlow id="SequenceFlow_7" name="" sourceRef="UserTask_2" targetRef="ParallelGateway_2"/>
<bpmn2:sequenceFlow id="SequenceFlow_8" name="" sourceRef="UserTask_4" targetRef="ParallelGateway_2"/>

<bpmn2:sequenceFlow id="SequenceFlow_13" name="" sourceRef="ParallelGateway_2" targetRef="UserTask_8"/>

<bpmn2:userTask id="UserTask_8" name="最终审批">   
  <bpmn2:incoming>SequenceFlow_13</bpmn2:incoming>
</bpmn2:userTask>]]>
          </programlisting>
        </para>
        
        <para>
          FixFlow的分支和合并要遵循同时分散,同时收回的原则,一次分散出来的子令牌必须在一个合并网关上合并。例如下面的例子：
        </para>
        
        <para>
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ParallelGateway.GraphicalNotation.1.png"/>
          </imageobject></mediaobject>
        </para>
        
        <para>
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ParallelGateway.GraphicalNotation.2.png"/>
          </imageobject></mediaobject>
        </para>
        
        
      </section>
      
      <section xml:id="bpmn.ParallelGateway.designer">
        
        <title>设计器配置</title>
        <para> 
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ParallelGateway.GraphicalNotation.3.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
    </section>
    
    <section xml:id="bpmn.InclusiveGateway">
      <title>InclusiveGateway</title>
      <section xml:id="bpmn.InclusiveGateway.Description">
        <title>描述</title>
        <para>
          包容网关(InclusiveGateway)更像是排他网关和并行网关的结合,它会验证后面的每条顺序流,如果后面有多条顺序流条件都满足则产生并发,如只有一个
          满足,则令牌正常往下流转不产生分支,如没有一条顺序流满足则抛出异常。
        </para>
      </section>
      
      <section xml:id="bpmn.InclusiveGateway.GraphicalNotation">
        <title>图形符号</title>
        <para> 
          包容网关(ExclusiveGateway)图形为一个菱形里边有一个"o"圆圈。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.InclusiveGateway.GraphicalNotation.1.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      
      <section xml:id="bpmn.InclusiveGateway.XMLRepresentation">
        <title>XML描述</title>
     
        <para>
          XML元素表示如下:
          <programlisting language="xml"><![CDATA[<bpmn2:inclusiveGateway id="InclusiveGateway_1"></bpmn2:inclusiveGateway>]]></programlisting>
        </para>
        
        <para>
          下面是一个使用包容网关和平行网关例子的XML表示:
          <programlisting language="xml"><![CDATA[
<bpmn2:inclusiveGateway id="InclusiveGateway_1" name="">
  <bpmn2:incoming>SequenceFlow_32</bpmn2:incoming>
  <bpmn2:outgoing>SequenceFlow_26</bpmn2:outgoing>
  <bpmn2:outgoing>SequenceFlow_27</bpmn2:outgoing>
</bpmn2:inclusiveGateway>

<bpmn2:userTask id="UserTask_16" name="UserTask_2">
  <bpmn2:incoming>SequenceFlow_26</bpmn2:incoming>
  <bpmn2:outgoing>SequenceFlow_28</bpmn2:outgoing>
</bpmn2:userTask>

<bpmn2:userTask id="UserTask_17" name="UserTask_3">
  <bpmn2:incoming>SequenceFlow_27</bpmn2:incoming>
  <bpmn2:outgoing>SequenceFlow_29</bpmn2:outgoing>
</bpmn2:userTask>

<bpmn2:parallelGateway id="ParallelGateway_5" name="" gatewayDirection="Converging">
  <bpmn2:incoming>SequenceFlow_28</bpmn2:incoming>
  <bpmn2:incoming>SequenceFlow_29</bpmn2:incoming>
  <bpmn2:outgoing>SequenceFlow_31</bpmn2:outgoing>
</bpmn2:parallelGateway>

<bpmn2:sequenceFlow id="SequenceFlow_26" name="${金额>300}" sourceRef="InclusiveGateway_1" targetRef="UserTask_16">
  <bpmn2:conditionExpression xsi:type="bpmn2:tFormalExpression" id="${金额>300}">${金额>300}</bpmn2:conditionExpression>
</bpmn2:sequenceFlow>

<bpmn2:sequenceFlow id="SequenceFlow_27" name="${金额>400}" sourceRef="InclusiveGateway_1" targetRef="UserTask_17">
  <bpmn2:conditionExpression xsi:type="bpmn2:tFormalExpression" id="${金额>400}">${金额>400}</bpmn2:conditionExpression>
</bpmn2:sequenceFlow>
    
<bpmn2:sequenceFlow id="SequenceFlow_28" name="" sourceRef="UserTask_16" targetRef="ParallelGateway_5"/>

<bpmn2:sequenceFlow id="SequenceFlow_29" name="" sourceRef="UserTask_17" targetRef="ParallelGateway_5"/>

<bpmn2:userTask id="UserTask_19" name="UserTask_1">
  <bpmn2:outgoing>SequenceFlow_32</bpmn2:outgoing>
</bpmn2:userTask>

<bpmn2:userTask id="UserTask_20" name="UserTask_4">
  <bpmn2:incoming>SequenceFlow_31</bpmn2:incoming>
</bpmn2:userTask>

<bpmn2:sequenceFlow id="SequenceFlow_31" name="" sourceRef="ParallelGateway_5" targetRef="UserTask_20"/>

<bpmn2:sequenceFlow id="SequenceFlow_32" name="" sourceRef="UserTask_19" targetRef="InclusiveGateway_1"/>]]></programlisting>
        </para>
        <para>
          上面的例子使用包容网关和并行网关来完成操作,当包容网关后面有多个分支的时候,并行网关负责合并,如果包容网关后面没有产生并发的话,那么并行网关将忽略不记。
        </para>
        
        <para>
          <emphasis>注意: </emphasis> 所有非网关的FlowNode节点,后面都默认实现了包容网关的功能,FixFlow允许开发人员不使用网关来控制顺序流走向,但这样做是不推荐的,除非万不得已。
        </para>
        <para>
          下面这样做法FixFLow引擎是支持的,但是不推荐这么用。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.InclusiveGateway.GraphicalNotation.2.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
      
      <section xml:id="bpmn.InclusiveGateway.designer">
        
        <title>设计器配置</title>
        <para> 
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.InclusiveGateway.designer.png"/>
          </imageobject></mediaobject>
        </para>
        
      </section>
    </section>
    

  </section>
  
  
  <section xml:id="bpmn.Tasks">
    <title>Tasks</title>
    <para>任务是一个流程里面最基本的活动，一个任务在使用的过程中不能再被拆分到更细的水平去执行。一般情况下，任务是被最终用户或应用程序执行的。</para>
    <para>
      
      <emphasis role="bold">BPMN2.0 Task类型元素图:</emphasis>
      <mediaobject ><imageobject>
        <imagedata  align="center" fileref="images/bpmn.Tasks.1.png"/>
      </imageobject></mediaobject>
    </para>
    
    <section xml:id="bpmn.UserTask">
      <title>User Task</title>
      
      <section xml:id="bpmn.UserTask.Description">
        <title>描述</title>
        <para>
          人工任务(UserTask)是用于模拟人工工作的，通常是需要被人来操作完成的。当执行到一个人工任务时，这个任务列表中的用户或者组都会被分配到此任务。 
        </para>
      </section>
      <section xml:id="bpmn.UserTask.GraphicalNotation">
        <title>图形符号</title>
        <para> 
          一个人工任务是图形为一个圆角矩形,有一个小的用户图标在左上角。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.UserTask.GraphicalNotation.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      
      
      <section xml:id="bpmn.UserTask.XMLRepresentation">
        <title>XML描述</title>
        
        <para>
          XML元素表示如下:
          <programlisting language="xml"><![CDATA[<bpmn2:userTask id="UserTask_1" name="人工任务"/>]]></programlisting>
        </para>
       
      </section>
      
      
      <section xml:id="bpmn.UserTask.assignment">
        <title>任务分配</title>
        
        <para>
          人工任务需要指派给一个用户或者是一个组(部门、角色),任务类型也被分为两大种:独占、共享，
          独占的任务直接指派给一个用户,共享的任务可以指定给多个用户、部门、角色等,共享任务默认需要先领取才能处理。
        </para>
        
        <para>
          BPMN2.0 标准中定义的UserTask节点的功能过于简单,没有办法描述复杂人工任务,所以FixFlow引擎对UserTask节点做了很多的扩展。
        </para>
        
        <para>
          下面这段XML表示,UserTask_1这个人工节点的任务处理者为"所有人",任务的分配策略为共享方式。
          <programlisting language="xml"><![CDATA[<bpmn2:userTask id="UserTask_1" name="User Task 1">
  <bpmn2:extensionElements>
    <fixflow:assignPolicyType id="potentialOwner"/>
  </bpmn2:extensionElements>
  <bpmn2:potentialOwner id="PotentialOwner_1" fixflow:resourceType="user" fixflow:includeExclusion="INCLUDE" fixflow:isContainsSub="false" name="所有人">
    <bpmn2:resourceAssignmentExpression id="ResourceAssignmentExpression_1">
      <bpmn2:formalExpression id="所有人">"quot;fixflow_allusers"</bpmn2:formalExpression>
    </bpmn2:resourceAssignmentExpression>
  </bpmn2:potentialOwner>
</bpmn2:userTask>]]></programlisting>
        </para>
        
        <para> 
          对应的设计器图形表示:
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.UserTask.assignment.1.png"/>
          </imageobject></mediaobject>
        </para>
        
        <para>
          分配策略(assignPolicyType):
        </para>
        <para>
          分配策略用来决定任务将以什么形式被分配或是怎么分配,而完成人选择,则决定了任务将分配给谁。
          FixFlow自带了一些分配策略,开发人员还可以自己扩展出自己的分配策略,分配策略的XML配置在FixFlowConfig.xml中,详见 <link linkend="config.assignPolicyConfig">分配策略</link>
          <programlisting language="xml"><![CDATA[
<assignPolicy id="potentialOwner" name="共享   (默认策略)" 
  classImpl="com.founder.fix.fixflow.expand.assignment.PotentialOwnerAssignmentImpl" 
  remarks="系统默认策略,需要接收任务才能处理,不能删除。"/>
<assignPolicy id="humanPerformer" name="独占   (默认策略)" 
  classImpl="com.founder.fix.fixflow.expand.assignment.HumanPerformerAssignmentImpl" 
  remarks="系统默认策略,只能分配给一个处理者,不能删除。"/>
<assignPolicy id="potentialOwner_One" name="共享   (当只有一人时采用独占策略)" 
  classImpl="com.founder.fix.fixflow.expand.assignment.PotentialOwnerOneAssignmentImpl" 
  remarks="当任务的处理者只有一个人的时候自动使用独占策略,多人的时候使用共享策略。"/>]]></programlisting>
          
        </para>
        
        <para>
          任务处理者:
        </para>
        <para>
          <emphasis role="bold">resourceType</emphasis>:分配资源的类型(用户、部门、角色 或者任意的组) 。
        </para>
        <para>
          <emphasis role="bold">includeExclusion</emphasis>:是包含这个资源还是排除它。 注意:这个功能存在一个已知bug,不推荐使用。
        </para>
        <para>
          <emphasis role="bold">isContainsSub</emphasis>:是否包含子集,在有上下级关系的组里才会起作用。
        </para>
        <para>
          <emphasis role="bold">resourceAssignmentExpression-formalExpression</emphasis>:人员或者组信息的表达式,
          可以是"人员编号"、也可以 return "人员编号"、或者 "人员1,人员2,人员3"、或者是个 List(String) 、也可以直接在这里调用java代码返回人员信息。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.UserTask.assignment.2.png"/>
          </imageobject></mediaobject>
        </para>
        <para>
          例如:
        </para>
        <para>
          <programlisting language="java"><![CDATA["admin"]]></programlisting>
          <programlisting language="java"><![CDATA[return "admin";]]></programlisting>
          <programlisting language="java"><![CDATA["admin,kenshin,char"]]></programlisting>
          可以调用任意的java代码,只要保证返回值的格式正确性,流程引擎就能接收。注意：对于java代码请注意导入import。
          <programlisting language="java"><![CDATA[import com.founder.fix.fixflow.core.impl.Context;
import com.founder.fix.fixflow.core.impl.identity.GroupTo;

groupTos=Context.getProcessEngineConfiguration().getUserDefinition().getUserInGroups("用户编号");
for (GroupTo groupTo : groupTos) {
	//默认取出用户的第一个所在部门
	if(groupTo.getGroupType().equals("org")){
		return processInfo.findUserDeptAndRole(groupTo.getGroupId(),"角色编号");;
	}
}
return null;]]></programlisting>
          
        </para>
      
      </section>
      
      
      <section xml:id="bpmn.UserTask.commonConfig">
        <title>常规配置</title>
        <para>
          <emphasis role="bold">编号(id)</emphasis>:
          一个bpmn文件中的任意一个元素都拥有不同的编号,通过这个编号可以定位到唯一的一个节点。
        </para>
        <para>
          <emphasis role="bold">名称(name)</emphasis>:
          用来在节点上显示的名称。
        </para>
        <para>
          <emphasis role="bold">操作表单(formUri)</emphasis>:
          用来进行任务处理的表单地址,可以从数据变量中的表单变量中选择,也可以返回一段字符串地址"add.html"。
        </para>
        <para>
          <emphasis role="bold">浏览表单(formUriView)</emphasis>:
          用来在查看已经处理完毕的任务的表单。
        </para>
        <para>
          <emphasis role="bold">优先级(taskPriority)</emphasis>:
          用来标识任务的紧急程度,接收的是int类型。
        </para>
        <para>  
          <emphasis role="bold">XML定义</emphasis>:
          <programlisting language="xml"><![CDATA[<bpmn2:userTask id="UserTask_1" fixflow:taskType="FIXFLOWTASK" name="人工任务">
  <bpmn2:extensionElements>
    <fixflow:formUri>
      <fixflow:expression xsi:type="fixflow:Expression" >"add.html"</fixflow:expression>
    </fixflow:formUri>
    <fixflow:formUriView>
      <fixflow:expression xsi:type="fixflow:Expression" >"view.html"</fixflow:expression>
    </fixflow:formUriView>
    <fixflow:taskPriority>
      <fixflow:expression xsi:type="fixflow:Expression" >50</fixflow:expression>
    </fixflow:taskPriority>
  </bpmn2:extensionElements>
</bpmn2:userTask>]]></programlisting>
          
        </para>
        
        <para>  
          <emphasis role="bold">Java代码</emphasis>:有了表单地址和BizKey我们就可以打开相应的表单。
          <programlisting language="java"><![CDATA[//创建任务查询
TaskQuery taskQuery = taskService.createTaskQuery();
//查询用户的任务,取第一个任务。
TaskInstance taskInstance=taskQuery.taskAssignee("").list().get(0);
//任务编号
taskInstance.getId();
//任务标题
taskInstance.getDescription();
//操作表单
taskInstance.getFormUri();
//浏览表单
taskInstance.getFormUriView();
//任务所在节点编号
taskInstance.getNodeId();
//任务所在节点名称
taskInstance.getNodeName();
//流程业务关联值
taskInstance.getBizKey();
//优先级
taskInstance.getPriority();]]></programlisting>
          
        </para>
      </section>
      <section xml:id="bpmn.UserTask.taskInfo">
        <title>任务信息</title>
        
       
        <para> <emphasis role="bold">动态主题</emphasis>:</para>
        <para>用来显示在代办任务上任务的显示主题,如果这里不填写的话,将自动从流程实例主题获取。<link linkend="bpmn.process.subject">流程任务主题</link></para>
        <para> <emphasis role="bold">任务类型</emphasis>:</para>
        <para>用来区别不同的任务分类,例如,通知任务、提醒任务等等,任务类型默认提供3种,FIXFLOWTASK 是默认的任务类型,其他两种用户可以自由选择。通过任务类型的区分之后,就
        可以在任务查询的时候通过指定的类型来分类任务。</para>
        <para> <emphasis>注意</emphasis>: 任务类型现在只有写死的三种,在以后的版本中我们会对这里做出扩展能让开发人员自定义任务类型。</para>
        <para> <emphasis role="bold">预计执行时间</emphasis>:</para>
        <para>设置任务的预计执行时间,只用来显示用并不用做超时处理,超时处理请参见<link linkend="bpmn.ExtensionElements.connector">连接器</link>章节</para>
        <para>
          <emphasis role="bold">XML描述</emphasis>:
          <programlisting language="xml"><![CDATA[<bpmn2:userTask id="UserTask_1" fixflow:taskType="FIXFLOWTASK" name="人工任务">
  <bpmn2:extensionElements>
    <fixflow:taskSubject>
      <fixflow:expression xsi:type="fixflow:Expression">"任务主题"</fixflow:expression>
    </fixflow:taskSubject>
  </bpmn2:extensionElements>
</bpmn2:userTask>]]></programlisting>
        </para>
        <para>
          <emphasis role="bold">设计器界面</emphasis>:
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.UserTask.taskInfo.1.png"/>
          </imageobject></mediaobject>
        </para>
        <para>
          <emphasis role="bold">Java代码</emphasis>:
          <programlisting language="java"><![CDATA[//获取任务查询对象
TaskQuery taskQuery=taskService.createTaskQuery();

//设置查询的任务类型(默认任务),可以设置多个之间是or的关系。
taskQuery.addTaskType(TaskInstanceType.FIXFLOWTASK);

//通知型任务
taskQuery.addTaskType(TaskInstanceType.FIXNOTICETASK);

//提醒任务
taskQuery.addTaskType(TaskInstanceType.FIXREMIND);

//查询出一个任务
TaskInstance taskInstance=taskQuery.singleResult();

//获取任务主题
taskInstance.getDescription();

//获取任务类型
taskInstance.getTaskInstanceType();

//获取任务的预计执行时间(毫秒)
taskInstance.getExpectedExecutionTime();
]]></programlisting>
        </para>
        
        
      </section>
      <section xml:id="bpmn.UserTask.advancedProperties">
        <title>高级属性</title>
        <para>高级属性中的多实例,是用来完成一个for循环的动作,出发多次不同参数的执行,并将结果收集起来。BPMN官方对多实例是使用Multi-instance元素,来实现的,
          关于多实例的使用请参见<link linkend="bpmn.foreach">Multi-instance (for each)</link>章节。
        </para>
        <para><emphasis>注意</emphasis>: 用于人工任务(UserTask)来说,多实例一般就是用来完成并行会签功能,也可以作用在子流程等其他节点上起到不同的效果。</para>
        <para><emphasis>注意</emphasis>: 串行的多实例,在这个版本的FixFlow中并没有实现,我们将会在今后的版本中引入这个功能。</para>
      </section>
      
    </section>
    
   
    <section xml:id="bpmn.ScriptTask">
      <title>Script Task</title>
      <section xml:id="bpmn.ScriptTask.Description">
        <title>描述</title>
        <para>
          脚本任务(ScriptTask)是一个自动的活动。当一个流程执行到脚本任务的时候相应的脚本被会被执行。 
        </para>
      </section>
      <section xml:id="bpmn.ScriptTask.GraphicalNotation">
        <title>图形符号</title>
        <para> 
          脚本任务是图形为一个圆角矩形,有一个小的脚本图标在左上角。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ScriptTask.GraphicalNotation.1.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      
      
      <section xml:id="bpmn.ScriptTask.XMLRepresentation">
        <title>XML描述</title>
        
        <para>
          XML元素表示如下:
          <programlisting language="xml"><![CDATA[<bpmn2:scriptTask id="ScriptTask_1" name="ScriptTask" scriptFormat="Groovy">
  <bpmn2:script>System.out.print("测试脚本");</bpmn2:script>
</bpmn2:scriptTask>]]></programlisting>
        </para>
        <para>
          FixFlow自带两种脚本语言,Groovy、BeanShell开发人员也可以扩展自己的脚本语言,这里我们推荐使用Groovy做为默认的脚本引擎,关于Groovy请查看<link xlink:href="http://groovy.codehaus.org">Groovy官网</link>
        </para>
        <para>
          关于扩展脚本语言请参见<link linkend="config.scriptConfig">脚本语言配置</link>
        </para>
        
      </section>
      
      <section xml:id="bpmn.ScriptTask.script">
        <title>脚本使用技巧</title>
        
        <para>
          如果在表达式中使用数据变量:
          <programlisting language="xml"><![CDATA[        
def title= "单据号为: "+${单据编号}+" 的报销单请审批!";
            ]]></programlisting>
        </para>
        <para>
          关于脚本语言更多使用介绍请参见<link linkend="bpmn.FixFlow.ProcessEngine.Script">脚本语言</link>
        </para>
      </section>
      
    </section>
    
    
    <section xml:id="bpmn.ServiceTask">
      <title>Service Task</title>
      <section xml:id="bpmn.ServiceTask.Description">
        <title>描述</title>
        <para>
          BPMN官方定义,服务任务(ServiceTask)专门被用来调用服务用的,FixFlow将这里指的服务解释为连接器,服务任务
          可以通过连接器完成调用功能。 
        </para>
      </section>
      <section xml:id="bpmn.ServiceTask.GraphicalNotation">
        <title>图形符号</title>
        <para> 
          服务任务是图形为一个圆角矩形,有一个小的齿轮图标在左上角。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ServiceTask.GraphicalNotation.1.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      
      
      <section xml:id="bpmn.ServiceTask.XMLRepresentation">
        <title>XML描述</title>
        
        <para>
          XML元素表示如下:
          <programlisting language="xml"><![CDATA[<bpmn2:serviceTask id="ServiceTask_1" name="ServiceTask"/>]]></programlisting>
        </para>
      </section>
    </section>
    
    <section xml:id="bpmn.BusinessRuleTask">
      <title>Business Rule Task</title>
      <section xml:id="bpmn.BusinessRuleTask.Description">
        <title>描述</title>
        <para>
          业务规则任务(BusinessRuleTask)用来执行一段业务规则脚本,这个节点FixFlow引擎是采用连接器的方式去执行的。
        </para>
      </section>
      <section xml:id="bpmn.BusinessRuleTask.GraphicalNotation">
        <title>图形符号</title>
        <para> 
          服务任务是图形为一个圆角矩形,有一个小的表格图标在左上角。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.BusinessRuleTask.GraphicalNotation.1.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      
      
      <section xml:id="bpmn.BusinessRuleTask.XMLRepresentation">
        <title>XML描述</title>
        
        <para>
          XML元素表示如下:
          <programlisting language="xml"><![CDATA[<bpmn2:businessRuleTask id="BusinessRuleTask_1" name="BusinessRuleTask"/>]]></programlisting>
        </para>
      </section>
    </section>
    
    <section xml:id="bpmn.SendTask">
      <title>Send Task</title>
      <section xml:id="bpmn.SendTask.Description">
        <title>描述</title>
        <para>
          发送任务(SendTask)用来发送邮件、短信、通知等等消息,FixFlow使用连接器来完成这个节点的功能。
          发送任务中一般使用发送邮件的连接器。
        </para>
      </section>
      <section xml:id="bpmn.SendTask.GraphicalNotation">
        <title>图形符号</title>
        <para> 
          发送任务是图形为一个圆角矩形,有一个小的邮件图标在左上角。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.SendTask.GraphicalNotation.1.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      
      
      <section xml:id="bpmn.SendTask.XMLRepresentation">
        <title>XML描述</title>
        
        <para>
          XML元素表示如下:
          <programlisting language="xml"><![CDATA[<bpmn2:sendTask id="SendTask_1" name="SendTask"/>]]></programlisting>
        </para>
      </section>
    </section>
    
    <section xml:id="bpmn.ReceiveTask">
      <title>Receive Task</title>
      <para>
        
      </para>
    </section>
    
    <section xml:id="bpmn.ManualTask">
      <title>Manual Task</title>
      <para>
        
      </para>
    </section>
    
    <section xml:id="bpmn.foreach">
      <title>Multi-instance (for each)</title>
      <para>
        
      </para>
    </section>
    
    
    
  </section>
  
  <section xml:id="bpmn.Sub-ProcessesAndCallActivities">
    <title>Sub-Processes and Call Activities</title>
    <para>
      
    </para>
    
    <section xml:id="bpmn.Sub-Process">
      <title>Sub-Process</title>
      <para>
        
      </para>
    </section>
    
    <section xml:id="bpmn.CallActivity">
      <title>Call activity (subprocess)</title>
      <para>
        
      </para>
    </section>
    
    
  </section>

  <section xml:id="bpmn.Lane">
    <title>Lane</title>
    <para>
      
    </para>
  
  </section>
  
  <section xml:id="bpmn.Data">
    <title>Data</title>
    <para>
      
    </para>
    
  </section>
  
  
  <section xml:id="bpmn.Artifacts">
    <title>Artifacts</title>
    <para>
      
    </para>
    
  </section>
  
  
  
  <section xml:id="bpmn.ExtensionElements">
    <title>扩展元素</title>
    <para>
      
    </para>
    <section xml:id="bpmn.ExtensionElements.connector">
      <title>连接器</title>
      <para>
        连接器的使用主要在于封装一些在流程中常用操作，用可视化界面代替原有静态方法，并提供在流程各种事件中扩展。本例以发送短信为例子介绍连接器的使用。
      </para>
      <para>按照项目经验，这部分工作会分为“封装”连接器和“调用”连接器。</para>
      <section xml:id="bpmn.ExtensionElements.connector.create">
        <title>创建连接器</title>
        <orderedlist>
          <listitem>
            <para>打开设计器，点击流程设置->创建连接器</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.create.1.png"/>
            </imageobject></mediaobject>
          </listitem>
          <listitem>
            <para>填写连接器ID，名称，描述等信息，分类可选择新建或者原有分类。</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.create.2.png"/>
            </imageobject></mediaobject>
          </listitem>
          <listitem>
            <para>发送短信需要配置收件人号码和信息内容，所以创建一个页面，填写页面ID，标题，描述等，并创建两个参数：收件人号码和信息内容。</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.create.3.png"/>
            </imageobject></mediaobject>
          </listitem>
          <listitem>
            <para>配置输出参数，这里可以将发送短信之后的结果返回给FixFlow在流程中使用,当然，实际使用中我们可能会返回更复杂的数据结构，如List、Map等，如：</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.create.6.png"/>
            </imageobject></mediaobject>
          </listitem>
          <listitem>
            <para>点击确定->完成，连接器创建成功，下面需要写发送短信的业务逻辑，设计器已经为我们创建好了相关的java类和xml配置文件（flow-expand\src\com\founder\fix\fixflow\expand\connector\TestSendMessage包下）。</para>
          </listitem>
          <listitem>
            <para>实现发送短信的具体逻辑</para>
            <para>查看生成的java代码，其中receiveId和messageInfo是我们刚才创建的变量ID，execute方法是最终执行的方法，这里的业务逻辑可能要调用第三方的短信猫接口，需要自己去补充。
              我们这里仅仅做简单的输出，表明我们拿到了相关的参数，可以进行复杂的业务计算等：</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.create.5.png"/>
            </imageobject></mediaobject>
          </listitem>
          <listitem>
            <para>到这里我们的“封装”的工具就完成了。</para>
          </listitem>
        </orderedlist>
        <para>连接器定义的源文件介绍：</para>
        <para>FixFlow的连接器定义文件在fixflow-expand\src\com\founder\fix\fixflow\expand\connector包下，其中FixConnectorMenu.xml是连接器的总览文件
          一个包代表一个连接器的定义，其中包括**.java和FixConnector.xml两个文件。
        </para>
        <para>FixConnectorMenu.xml中一个连接的定义如下：</para>
        <programlisting>&lt;node id="64159507-476c-483c-ad29-9918465afbab" name="TestFixFlow">
    &lt;menuConnector id="TestSendMessage" name="发送短信" note="发送短信连接器"/>
 &lt;/node></programlisting>
        <itemizedlist>
          <listitem><para>node：表示一个连接器分类</para></listitem>
          <listitem>
            <para>id：表示分类的唯一编号，自动生成的</para>
          </listitem>
          <listitem>
            <para>name：分类的名称</para>
          </listitem>
          <listitem>
            <para>ico：分类在设计器中的图标</para>
          </listitem>
          <listitem>
            <para>menuConnector：连接器的定义</para>
            <itemizedlist>
              <listitem><para>id：连接器的唯一编号，自己定义，并且相同目录下必须有这个同名包，包下有同名的java文件。</para></listitem>
              <listitem><para>name：连接器的名称。</para></listitem>
              <listitem><para>note：连接器的说明。</para></listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
        <para>同名包下的FixConnector.xml文件的定义如下：</para>
        <programlisting>
&lt;connector:Connector xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:connector="http://www.founderfix.com/connector" connectorId="TestSendMessage" className="TestSendMessage" packageName="com.founder.fix.fixflow.expand.connector.TestSendMessage" connectorName="发送短信" connectorNote="发送短信连接器" category="TestFixFlow">
  &lt;outputs>
    &lt;outputParameter id="result" name="发送是否成功" dataType="java.lang.String"/>
  &lt;/outputs>
  &lt;Pages>
    &lt;page pageId="messageConfig" pageTitle="信息配置" pageNote="信息配置">
      &lt;inputParameter id="receiveId" name="收件人号码" dataType="java.lang.String" controlType="text"/>
      &lt;inputParameter id="messageInfo" name="短信内容" dataType="java.lang.String" controlType="text"/>
    &lt;/page>
  &lt;/Pages>
&lt;/connector:Connector>      
        </programlisting>
        <para>主要属性说明</para>
        <itemizedlist>
          <listitem>
            <para>connector：连接器的声明，类名，包名等信息</para>
          </listitem>
          <listitem>
            <para>outputs：输出参数</para>
          </listitem>
          <listitem>
            <para>Pages：页面数，流程中使用此连接器时需要配置几个界面。<itemizedlist>
              <listitem>
                <para>page：页面定义</para>
              </listitem>
              <listitem>
                <para>inputParameter：页面上的输入参数，与Java文件中的一一对应。</para>
              </listitem>
            </itemizedlist></para>
          </listitem>
        </itemizedlist>
        <para>对应的java文件代码如下：</para>
        <programlisting language="java">
package com.founder.fix.fixflow.expand.connector.TestSendMessage;


import com.founder.fix.fixflow.core.runtime.ExecutionContext;
import com.founder.fix.fixflow.core.action.ConnectorHandler;

public class TestSendMessage implements ConnectorHandler {

	private java.lang.String receiveId;

	private java.lang.String messageInfo;

	public void execute(ExecutionContext executionContext) throws Exception {
		System.out.println("收件人号码为："+receiveId);
		System.out.println("短信内容为："+messageInfo);
	}

	public void  setReceiveId(java.lang.String receiveId){
		this.receiveId = receiveId;
	}

	public void  setMessageInfo(java.lang.String messageInfo){
		this.messageInfo = messageInfo;
	}

	public java.lang.String  getResult(){
		return "true" ;
	}

}          
        </programlisting>
        <para>主要代码说明</para>
        <itemizedlist>
          <listitem>
            <para>receiveId：和messageInfo一样，是连接器定义XML文件中定义的输入参数，并且要有setReceiveId()方法</para>
          </listitem>
          <listitem>
            <para>getResult()：定义文件中有出参result，所以此处会有getResult()方法，返回给流程使用</para>
          </listitem>
          <listitem>
            <para>execute()：具体逻辑的实现方法。</para>
          </listitem>
        </itemizedlist>
        <para><emphasis>注意：</emphasis>get方法和set方法是由FixFlow流程引擎调用，用户只需要实现execute()中的相关逻辑即可。</para>
      </section>
      <section xml:id="bpmn.ExtensionElements.connector.use">
        <title>使用连接器</title>
        <para>连接器作用在不同的地方有不同的触发事件，作用在流程上时有启动触发，终止触发，结束触发；作用在节点上时有进入时触发，分配任务时触发，离开时触发。</para>
        <orderedlist>
          <listitem> 
            <para>打开设计器，打开一个简单流程，打开Properties属性页，点击流程空白处，在属性页中选择连接器，如图：</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.use.1.png"/>
            </imageobject></mediaobject>
          </listitem>
          <listitem>
            <para>点击添加->选择TestFixFlow分类下TestSendMessage连接器，如图：</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.use.2.png"/>
            </imageobject></mediaobject>
          </listitem>
          <listitem>
            <para>填写基本信息</para>
            <itemizedlist>
              <listitem><para>名称、描述用来描述这个连接器的作用。</para></listitem>
              <listitem><para>跳过策略，通过条件来设置次连接器的跳过策略。详细跳过策略介绍可参考<link linkend="bpmn.ExtensionElements.skip">跳过策略</link></para></listitem>
              <listitem>
                <para>定时器可以让我们方便的设置延迟，循环执行次功能</para>
                <para>当勾选了定时器配置中的 启用定时器之后 便可以在时间表达式中去指定 Trigger（触发器）。
                  对于时间表达式我们使用的是Quartz定时任务框架所带的功能。
                </para>
                <para>
                  这里我们说明一下：我们的时间表达式配置里边,可以指定一个Trigger，
                  也可以指定多个Trigger,可以指定在指定时间触发的Trigger，
                  也可以指定复杂的间歇性Trigger。如：
                </para>
                <programlisting language="java">import org.quartz.Trigger;
import com.founder.fix.fixflow.core.impl.util.QuartzUtil;

cal = Calendar.getInstance();
cal.add(Calendar.MINUTE, +1);
trigger1=QuartzUtil.createSimpleTrigger(processInfo,cal.getTime());
trigger2=QuartzUtil.createCronTrigger(processInfo, "0 0 12 * * ?");

List&lt;Trigger> triggers=new ArrayList&lt;Trigger>();
triggers.add(trigger1);
triggers.add(trigger2);
return triggers;          
                </programlisting>
              </listitem>
              <listitem>
                <para>连接器如果失效时，可以选择忽略或者抛出异常等。</para>
              </listitem>
            </itemizedlist>
            <para>这里我们只设置简单的当流程启动时给指定人员发送短信，点击下一步，如：</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.use.3.png"/>
            </imageobject></mediaobject>
          </listitem>
          <listitem><para>填写我们创建的两个参数：收件人号码和短信内容，点击下一步：</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.use.4.png"/>
            </imageobject></mediaobject>
            <para>当然我们这里的号码和短信内容和FixFlow流程中的其他配置一样，都可以写复杂的java代码的。</para>
          </listitem>
          <listitem>
            <para>配置输出参数，左边的result是我们创建连接器时的输出参数，右边是次流程定义的变量。</para>
          </listitem>
          <listitem>
            <para>点击完成，保存，发布流程。</para>
          </listitem>
          <listitem>
            <para>启动tomcat，访问bpmcenter，启动此流程，查看控制台输出：</para>
            <mediaobject ><imageobject>
              <imagedata align="center"  fileref="images/bpmn.ExtensionElements.connector.use.5.png"/>
            </imageobject></mediaobject>
          </listitem>
        </orderedlist>
        <para>配置在流程中的连接器XML文件表示如图：</para>
        <programlisting language="xml">&lt;fixflow:connectorInstance connectorId="TestSendMessage" packageName="com.founder.fix.fixflow.expand.connector.TestSendMessage" className="TestSendMessage" connectorInstanceId="2c2ee38b-785e-4f52-9112-8710980124ad" connectorInstanceName="发送短信" eventType="node-enter" errorHandling="抛出异常" errorCode="" isTimeExecute="true">
          &lt;documentation xsi:type="fixflow:Documentation">流程启动时给管理员发送短信&lt;/documentation>
          &lt;fixflow:connectorParameterInputs xsi:type="fixflow:ConnectorParameterInputs" id="receiveId" name="收件人号码" dataType="java.lang.String">
            &lt;fixflow:expression xsi:type="fixflow:Expression" name="&amp;quot;13022222222&amp;quot;">"13022222222"&lt;/fixflow:expression>
          &lt;/fixflow:connectorParameterInputs>
          &lt;fixflow:connectorParameterInputs xsi:type="fixflow:ConnectorParameterInputs" id="messageInfo" name="短信内容" dataType="java.lang.String">
            &lt;fixflow:expression xsi:type="fixflow:Expression" name="流程启动发送短信">"流程启动发送短信"&lt;/fixflow:expression>
          &lt;/fixflow:connectorParameterInputs>
          &lt;fixflow:connectorParameterOutputs xsi:type="fixflow:ConnectorParameterOutputs" variableTarget="${amount}">
            &lt;fixflow:expression xsi:type="fixflow:Expression">result&lt;/fixflow:expression>
          &lt;/fixflow:connectorParameterOutputs>
          &lt;fixflow:connectorParameterOutputsDef xsi:type="fixflow:ConnectorParameterOutputsDef" id="result" name="发送是否成功" dataType="java.lang.String"/>
          &lt;fixflow:skipComment xsi:type="fixflow:SkipComment">
            &lt;fixflow:expression xsi:type="fixflow:Expression" name="returnfalse;">return false;&lt;/fixflow:expression>
          &lt;/fixflow:skipComment>
          &lt;fixflow:timeExpression xsi:type="fixflow:timeExpression">
            &lt;fixflow:expression xsi:type="fixflow:Expression" name="importorg.quartz.Trigger;">import org.quartz.Trigger;
import com.founder.fix.fixflow.core.impl.util.QuartzUtil;

cal = Calendar.getInstance();
cal.add(Calendar.MINUTE, +1);
trigger1=QuartzUtil.createSimpleTrigger(processInfo,cal.getTime());
trigger2=QuartzUtil.createCronTrigger(processInfo, &amp;quot;0 0 12 * * ?&amp;quot;);

List&amp;lt;Trigger> triggers=new ArrayList&amp;lt;Trigger>();
triggers.add(trigger1);
triggers.add(trigger2);
return triggers;&lt;/fixflow:expression>
          &lt;/fixflow:timeExpression>
          &lt;fixflow:timeSkipExpression xsi:type="fixflow:timeSkipExpression">
            &lt;fixflow:expression xsi:type="fixflow:Expression" name="returnfalse;">return false;&lt;/fixflow:expression>
          &lt;/fixflow:timeSkipExpression>
        &lt;/fixflow:connectorInstance>          
        </programlisting>
        <para>主要节点和属性说明</para>
        <itemizedlist>
          <listitem>
            <para>fixflow:connectorInstance：连接器实例<itemizedlist>
              <listitem>
                <para>connectorId：连接器定义编号</para>
              </listitem>
              <listitem>
                <para>eventType：作用时机：节点进入、节点离开、任务分配、流程启动、流程结束等</para>
              </listitem>
              <listitem>
                <para>isTimeExecute：是否启动定时器</para>
              </listitem>
              <listitem>
                <para>errorHandling：错误机制：抛出异常、忽略错误并继续流程、抛出错误事件。</para>
              </listitem>
            </itemizedlist></para>
          </listitem>
          <listitem>
            <para>documentation：连接器描述</para>
          </listitem>
          <listitem>
            <para>fixflow:connectorParameterInputs：连接器输入参数</para>
          </listitem>
          <listitem>
            <para>fixflow:connectorParameterOutputs：连接器输出参数<itemizedlist>
              <listitem>
                <para>variableTarget：输出变量对应的目标变量</para>
              </listitem>
            </itemizedlist></para>
          </listitem>
          <listitem>
            <para>fixflow:skipComment：跳过策略</para>
          </listitem>
          <listitem>
            <para>timeExpression：启动定时器时的时间表达式</para>
          </listitem>
          <listitem>
            <para>fixflow:timeSkipExpression：时间表达式的跳过策略</para>
          </listitem>
          <listitem>
            <para>fixflow:expression：groovy代码或表达式。</para>
          </listitem>
        </itemizedlist>
        <para>至此，连接器的使用基本就结束了，需要注意的是当连接器作用在不同的地方时，其可选择的触发事件是不一样的。FixFlow为了方便用户，已经将
        项目中常用的连接器封装好了，比如：发送短信，发送邮件，超时自动处理，webService等。</para>
        
        <para>下面介绍两个最常用的连接器：</para>
        <orderedlist>
          <listitem>
            <para>超时处理，超时处理。</para>
          </listitem>
          <listitem>
            <para>自动发送邮件。这个经常使用在当流程到达某个节点时，自动给相关处理者发送一封提醒邮件</para>
          </listitem>
        </orderedlist>
        
      </section>
    </section>
    
    <section xml:id="bpmn.ExtensionElements.dataVariable">
      <title>数据变量</title>
        <para>数据变量是在流程运转中可以由用户控制的，可以在流程各个表达式中使用的变量定义。</para>
        <para>它分为瞬态变量和持久化变量，瞬态变量的生命周期为命令提交到令牌进入下一个节点清空数据之前。持久化变量是在使用此变量后，流程引擎会将数据持久化到数据库，在以后的各个节点状态均可直接使用。</para>
        <para>
          <emphasis role="bold">设计器使用</emphasis>
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ExtensionElements.dataVariable.designer.1.png"/>
          </imageobject></mediaobject>
        </para>
      <para> <emphasis role="bold">XML描述</emphasis></para>
        <programlisting language="xml">
&lt;fixflow:DataVariable id="amount" dataType="int" isPersistence="true" bizType="customVariable">
        &lt;fixflow:expression xsi:type="fixflow:Expression" name="4000">"4000"&lt;/fixflow:expression>
        &lt;fixflow:documentation xsi:type="fixflow:Documentation">&lt;/fixflow:documentation>
&lt;/fixflow:DataVariable>          
        </programlisting>
        <itemizedlist>
          <listitem><para>dataType：变量数据类型。</para></listitem>
          <listitem><para>isPersistence：是否持久化。</para></listitem>
          <listitem><para>bizType：变量业务类型，用户自己划分。</para></listitem>
          <listitem><para>fixflow:expression：命令表达式，这里代表默认值。</para></listitem>
          <listitem><para>fixflow:documentation：描述。</para></listitem>
        </itemizedlist>
      <para> <emphasis role="bold">设计器表达式中使用</emphasis></para>
      <programlisting language="java">${amount}=300;     </programlisting>
      <para> <emphasis role="bold">Java代码使用</emphasis></para>
      <programlisting language="java">//获取流程变量
Object variableValue = runtimeService.getProcessInstanceVariable(processInstanceId, "amount");      </programlisting>
    </section>
    
    <section xml:id="bpmn.ExtensionElements.skip">
      <title>跳过策略</title>
      <para>跳过策略一般作用于节点上，来指定在特殊状态下次节点直接跳过</para>
      <para> <emphasis role="bold">设计器定义如图</emphasis></para>
        <para>
          选中节点，点击properties属性框，选择跳过策略。
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ExtensionElements.skip.designer.1.png"/>
          </imageobject></mediaobject>
        </para>
        <para> <emphasis role="bold">XML描述</emphasis></para>
        <programlisting language="xml">&lt;fixflow:skipStrategy fixflow:isEnable="true">
    &lt;fixflow:expression xsi:type="fixflow:Expression" name="判断">if(${amount}>4000){
	    return true;
    }else{
	    return false;
    }&lt;/fixflow:expression>
    &lt;fixflow:skipAssignee xsi:type="fixflow:SkipAssignee">
       &lt;fixflow:expression xsi:type="fixflow:Expression" name="1200119390">"1200119390"&lt;/fixflow:expression>
    &lt;/fixflow:skipAssignee>
    &lt;fixflow:skipComment xsi:type="fixflow:SkipComment">
        &lt;fixflow:expression xsi:type="fixflow:Expression" name=金额太小就不用我审批了">"金额太小就不用我审批了。"&lt;/fixflow:expression>
     &lt;/fixflow:skipComment>
&lt;/fixflow:skipStrategy>
        </programlisting>
    </section>
    
    <section xml:id="bpmn.ExtensionElements.form">
      <title>任务表单</title>
      <section xml:id="bpmn.ExtensionElements.form.description">
        <title>描述</title>
        <para> 任务大致分为两种，流程默认表单，任务级别表单。
        <orderedlist>
          <listitem><para>默认表单：<link linkend="bpmn.process.defaultForm">默认表单</link></para></listitem>
          <listitem><para>任务级别表单：<link linkend="bpmn.UserTask.commonConfig">任务表单</link></para></listitem>
        </orderedlist>
          
        </para>
      </section>
     
      <section xml:id="bpmn.ExtensionElements.form.designer">
        <title>设计器配置</title>
        <para>
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ExtensionElements.form.designer.1.png"/>
          </imageobject></mediaobject>
          <mediaobject ><imageobject>
            <imagedata align="center"  fileref="images/bpmn.ExtensionElements.form.designer.2.png"/>
          </imageobject></mediaobject>
        </para>
      </section>
      <section xml:id="bpmn.ExtensionElements.form.xmlCode">
        <title>XML描述</title>
        <programlisting language="xml">
&lt;fixflow:formUri>
    &lt;fixflow:expression xsi:type="fixflow:Expression" id="Expression_5" name="DemoServlet">"DemoServlet?action=startOneTask"&lt;/fixflow:expression>
&lt;/fixflow:formUri>     
        </programlisting>
      </section>
    </section>
    
    <section xml:id="bpmn.ExtensionElements.taskTopic">
      <title>任务主题</title>
      <para>
        任务主题是流程实例的基本描述。
      </para>
      <para> <emphasis role="bold">设计器配置</emphasis></para>
      <para>
        <mediaobject ><imageobject>
          <imagedata align="center"  fileref="images/bpmn.ExtensionElements.taskTopic.1.png"/>
        </imageobject></mediaobject>
      </para>
      <para> <emphasis role="bold">XML描述</emphasis></para>
      <programlisting language="xml">&lt;fixflow:taskSubject id="TaskSubject_1">
     &lt;fixflow:expression xsi:type="fixflow:Expression" id="Expression_2" name="提交的**出差报销单">processInfo.getInitiator()+"提交的**出差报销单"&lt;/fixflow:expression>
 &lt;/fixflow:taskSubject>  </programlisting>
      <para> <emphasis role="bold">Java代码使用</emphasis></para>
      <programlisting language="java">ProcessInstance processInstance = runtimeService.getProcessInstance(processInstanceId);
String taskSubject = processInstance.getSubject();             </programlisting>
    </section>
    
    <section xml:id="bpmn.ExtensionElements.taskCommand">
      <title>任务命令</title>
      <para> 任务命令是一组预先配置的，能够驱动流程走向的命令的集合。</para>
      <para>任务命令的配置如图：
        <mediaobject ><imageobject>
          <imagedata align="center"  fileref="images/bpmn.ExtensionElements.taskCommand.1.png"/>
        </imageobject></mediaobject>
      </para>
      <para>其中每一个任务命令都会对应三个Java实现类：参数对象、执行器、过滤器。<itemizedlist>
          <listitem>
            <para>参数对象表明了此命令的运行需要提供哪些必要参数。</para>
          </listitem>
          <listitem>
            <para>过滤器是控制此命令在当前环境下是否显示的逻辑。如：接收任务命令只能在任务未被领取的时候出现。</para>
          </listitem>
          <listitem>
            <para>执行器是控制此命令如何驱动流程运转逻辑的实现。</para>
          </listitem>
      </itemizedlist></para>
      <para>当FixFlow提供的默认命令不满足用户需求的时候，用户可以很方便的自定义自己的任务命令按钮，只要实现上述三个类即可。</para>
      <para>流程中配置如图：
        <mediaobject ><imageobject>
          <imagedata align="center"  fileref="images/bpmn.ExtensionElements.taskCommand.2.png"/>
        </imageobject></mediaobject>
      </para>
      <para><emphasis role="bold">XML描述</emphasis></para>
      <programlisting language="xml"> &lt;fixflow:taskCommand id="HandleCommand_2" name="提交" commandType="startandsubmit" isVerification="true" isSaveData="true" isSimulationRun="false">
     &lt;fixflow:parameterExpression xsi:type="fixflow:Expression" name="System.out.println("启动命令执行啦。");">System.out.println("启动命令执行啦。");&lt;/fixflow:parameterExpression>
 &lt;/fixflow:taskCommand>             </programlisting>
      <itemizedlist>
        <listitem><para>fixflow:taskCommand：任务命令定义</para></listitem>
        <listitem><para> fixflow:parameterExpression：任务命令执行时需要执行的表达式或代码。</para></listitem>
      </itemizedlist>
      
      <para><emphasis role="bold">Java代码使用</emphasis></para>
      <programlisting language="java">//获取任务处理时应得到的命令
List&lt;TaskCommandInst> list = null;
//如果TaskId为空，说明是启动表单，获取启动相关命令，否则则获得处理命令
if(StringUtil.isNotEmpty(taskId)){
	list = engine.getTaskService().GetTaskCommandByTaskId(taskId, false);
}else{
	list = engine.getTaskService().getSubTaskTaskCommandByKey(processDefinitionKey);
}
        
//执行命令方法
//创建一个通用命令
ExpandTaskCommand expandTaskCommand = new ExpandTaskCommand();
//设置流程名
expandTaskCommand.setProcessDefinitionKey("Process_TaskServiceTest");
//设置流程的业务关联键
expandTaskCommand.setBusinessKey("BK_testStartProcessInstanceByKey");
//命令类型，可以从流程引擎配置中查询   启动并提交为startandsubmit
expandTaskCommand.setCommandType("startandsubmit");
//设置提交人
expandTaskCommand.setInitiator("1200119390");
//设置命令的id,需和节点上配置的按钮编号对应，会执行按钮中的脚本。
expandTaskCommand.setUserCommandId("HandleCommand_2");      </programlisting>
    </section>
    
    <section xml:id="bpmn.ExtensionElements.assignPolicy">
      <title>分配策略</title>
      <para>
        <link linkend="bpmn.UserTask.assignment">见任务分配</link>
      </para>
      
    </section>
    
  </section>
  
  <section xml:id="bpmn.FixFlow.ProcessEngine">
    <title>FixFlow Engine 运行机制及原理</title>
    <section xml:id="bpmn.FixFlow.ProcessEngine.Event">
      <title>FixFlow Event</title>
      <para>
        
      </para>
      
    </section>
    
    <section xml:id="bpmn.FixFlow.ProcessEngine.Script">
      <title>脚本语言</title>
      <para>
        
      </para>
      
    </section>
    
  </section>
  
  
</chapter>
